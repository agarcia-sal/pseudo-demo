Here is the pseudocode based on the provided code. It aims to clearly express the algorithm's logic while being easily understandable:

```
1. Read the input value for t (an integer representing the upper limit).

2. Initialize a variable named prime_count to 0 (this will store the number of semiprimes).

3. For each number i from 1 to t (inclusive):
    a. Initialize a variable named divisor_count to 0 (this will count distinct prime factors of i).
    b. Set a variable current_number to i (to manipulate during factorization).

    c. For each number j from 2 to (i - 1):
        i. Check if j is a divisor of current_number (if current_number modulo j equals 0):
            - If true, increment divisor_count by 1 (indicating a distinct prime factor).
            
            - While current_number is divisible by j (while current_number modulo j equals 0):
                - Divide current_number by j (reduce current_number by removing prime factor j).
    
    d. After the inner loop, check if divisor_count equals 2 (indicating that i has exactly two distinct prime factors):
        - If true, increment prime_count by 1 (this number i is a semiprime).
        
4. After all iterations, print the value of prime_count (the number of semiprime numbers found).
```

### Comments on the Pseudocode
- The key operations are clearly articulated, such as factorization and counting, using easy-to-understand language.
- Control structures like loops (*for each* and *while*) are described in simple terms.
- The focus remains on the overall algorithm rather than getting bogged down with any specific programming syntax or details.
