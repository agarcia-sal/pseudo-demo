**Purpose**: The code aims to count how many numbers between 1 and a given number (inclusive) are exactly semiprime, which is defined as a number that can be expressed as the product of two prime numbers.

---

**Pseudocode**:

1. **Get User Input:**  
   - Ask the user to enter a number which we will call `limit`.
   - Convert this input into an integer.

2. **Initialize Counter:**  
   - Set a variable `semiprimeCount` to 0. This variable will keep track of the number of semiprime numbers found.

3. **Loop Through Numbers:**  
   - For each number `currentNumber` from 1 to `limit` inclusive:
     - Set a variable `primeFactorCount` to 0. This will count how many distinct prime factors `currentNumber` has.
     - Set `tempNumber` to `currentNumber`. This variable will be used for factorization.

     - **Find Prime Factors:**  
       - For each possible factor `potentialFactor` starting from 2 up to one less than `currentNumber`:
         - Check if `tempNumber` is divisible by `potentialFactor`:
           - If it is divisible:
             - Increment `primeFactorCount` by 1.
             - While `tempNumber` is still divisible by `potentialFactor`:
               - Divide `tempNumber` by `potentialFactor`. This continuously reduces `tempNumber` until it can no longer be divided by `potentialFactor`.

     - **Check for Semiprime:**  
       - After checking all possible factors for `currentNumber`, if `primeFactorCount` is exactly 2:
         - Increment `semiprimeCount` by 1.

4. **Output Result:**  
   - After completing the analysis of all numbers up to `limit`, display the value of `semiprimeCount`. This represents the total number of semiprimes found.

---

**Comments for Clarity**:
- The outer loop iterates through every number to check for semiprimality.
- The inner loop checks for prime factors and counts distinct ones.
- The final count only increases when exactly 2 distinct prime factors are found, indicating the number is semiprime.

This pseudocode effectively captures the structure and logic of the original code while maintaining a focus on clarity and ease of understanding.
