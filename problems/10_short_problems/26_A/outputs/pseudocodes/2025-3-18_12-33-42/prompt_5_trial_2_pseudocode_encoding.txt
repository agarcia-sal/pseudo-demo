**Purpose:** The code aims to count and return the number of prime numbers less than or equal to a given integer input.

---

**Pseudocode:**

1. **Start the Program**
  
2. **Accept Input:**
   - Read an integer value called `upperLimit`.  // This is the total number up to which we want to find prime numbers.

3. **Initialize Counter for Primes:**
   - Set a variable called `primeCount` to 0.  // This keeps track of the number of prime numbers found.

4. **Loop Through Each Number:**
   - For each integer `currentNumber` from 1 to `upperLimit` (inclusive):
   
     1. **Initialize a Counter for Factors:**
        - Set a variable called `factorCount` to 0.  // This will count the number of factors for the current number.
        - Set a variable `tempNumber` to the value of `currentNumber`. // A temporary variable to manipulate the number.

     2. **Check for Factors:**
        - For each integer `potentialFactor` from 2 to `currentNumber - 1`:
          
          - If `tempNumber` is divisible by `potentialFactor` (i.e., if the remainder when dividing `tempNumber` by `potentialFactor` is zero):
            - Increase `factorCount` by 1.  // We have found a new factor.
            
            - While `tempNumber` can still be divided by `potentialFactor`: 
              - Divide `tempNumber` by `potentialFactor`.  // This removes all occurrences of the factor from the number.

     3. **Determine if Current Number is Prime:**
        - If `factorCount` is exactly 2:
          - Increase `primeCount` by 1.  // It is a prime number.

5. **Output the Result:**
   - Print `primeCount`.  // This displays how many prime numbers were found up to `upperLimit`.

**End the Program**

---

**Comments for Clarity:**
- The inner loop checks each number for divisibility starting from 2 to one less than the number, effectively looking for factors.
- A number is considered prime if it has exactly two distinct positive divisors: 1 and itself.
- The counting and factoring are done using a temporary variable to avoid altering the original number during factorization.

By following this structured approach, readers can easily grasp the logic behind the original code and its intended functionality.
