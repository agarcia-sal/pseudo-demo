Hereâ€™s the pseudocode representation of the provided code snippet. The goal here is to capture the essence of the algorithm while ensuring clarity and understanding.

---

**Pseudocode: Count Unique Prime Factors**

1. **Input:**
   - Read an integer `t` which represents the upper limit.

2. **Initialize:**
   - Set `resultCount` to 0 (This will hold the count of numbers with exactly two unique prime factors).

3. **Iterate through Numbers:**
   - For each number `currentNumber` from 1 to `t` inclusive:
     - Initialize `uniquePrimeFactorCount` to 0 (This will count the unique prime factors of `currentNumber`).
     - Set `tempNumber` to `currentNumber` (This variable will be modified to find prime factors).

4. **Find Prime Factors:**
   - For each potential divisor `potentialPrime` starting from 2 up to `currentNumber - 1`:
     - Check if `tempNumber` is divisible by `potentialPrime`:
       - If true, increment `uniquePrimeFactorCount` by 1 (Indicates a new unique prime factor was found).
       - While `tempNumber` is divisible by `potentialPrime`, perform the following:
         - Divide `tempNumber` by `potentialPrime` (Eliminate this prime factor from the number).

5. **Count Valid Numbers:**
   - After checking all potential divisors:
     - If `uniquePrimeFactorCount` equals 2 (Indicating `currentNumber` has exactly two unique prime factors):
       - Increment `resultCount` by 1.

6. **Output:**
   - Print `resultCount` (This represents the total number of numbers from 1 to `t` that have exactly two unique prime factors).

---

This pseudocode captures the overall logic of the original code without delving into specific programming details, making it accessible for readers seeking to understand the underlying algorithm.
