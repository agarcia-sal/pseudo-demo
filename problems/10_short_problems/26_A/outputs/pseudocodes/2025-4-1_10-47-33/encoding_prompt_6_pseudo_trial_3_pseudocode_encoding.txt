```plaintext
// Read an integer input that represents the upper limit for checking prime numbers
Read the integer value 't'

// Initialize a variable to keep track of the count of prime numbers found
Initialize 'prime_count' to 0

// Loop through each number from 1 to t (inclusive)
For each number 'i' from 1 to t do:
    
    // Initialize a counter to track the number of unique prime factors for the current number
    Initialize 'unique_prime_factors_count' to 0
    
    // Create a variable 'current_number' and set it to the current number 'i'
    Set 'current_number' to 'i'
    
    // Check for potential prime factors starting from 2 up to current_number - 1
    For each potential factor 'j' from 2 to (current_number - 1) do:
        
        // If 'j' is a factor of 'current_number'
        If (current_number is divisible by j) then:
            // Increment the count of unique prime factors
            Increment 'unique_prime_factors_count' by 1
            
            // Divide 'current_number' by 'j' until it is no longer divisible by 'j'
            While (current_number is divisible by j) do:
                Divide 'current_number' by j

    // After checking all factors, if the count of unique prime factors is exactly 2
    If (unique_prime_factors_count is equal to 2) then:
        // Increment the prime count, as this indicates 'i' is a prime number
        Increment 'prime_count' by 1

// After checking all numbers, output the total count of prime numbers found
Print the value of 'prime_count'
``` 

This pseudocode outlines the steps taken in the original code to count numbers that have exactly two unique prime factors, detailing the flow of logic and providing clarity for someone unfamiliar with coding syntax.
