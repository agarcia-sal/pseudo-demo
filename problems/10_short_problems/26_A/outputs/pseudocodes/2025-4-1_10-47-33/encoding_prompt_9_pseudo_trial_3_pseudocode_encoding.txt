**Purpose:** The algorithm counts how many numbers from 1 to a given number \( t \) are "semiprime," which means they have exactly two distinct prime factors.

**Pseudocode:**

1. **Start the program** and read an integer \( t \) from the user, representing the upper limit.

2. **Initialize a count** variable named `semiprimeCount` to 0. This will keep track of how many semiprime numbers are found.

3. **Loop through each number** \( currentNumber \) from 1 to \( t \) (inclusive):
   - **Set a counter** named `distinctPrimeCount` to 0. This will count the number of distinct prime factors of the current number.
   - **Set a variable** `number` equal to \( currentNumber \). This will be used to find prime factors.

4. **Loop through each potential factor** \( potentialFactor \) starting from 2 up to \( currentNumber - 1 \):
   - **Check if the current number** is divisible by \( potentialFactor \):
     - If true, increase `distinctPrimeCount` by 1 (indicating a new prime factor was found).
     - **While the current number is divisible** by \( potentialFactor \):
       - Divide `number` by \( potentialFactor \) (this reduces the current number by its prime factor).

5. **After checking all potential factors**:
   - **If `distinctPrimeCount` is equal to 2**:
     - Increase `semiprimeCount` by 1 (indicating another semiprime was found).

6. **Once all numbers have been checked**, output the value of `semiprimeCount`.

**End of program.**
