Here's the high-level pseudocode based on the provided Python code:

```
FUNCTION checkConsecutiveNumbers(n)
    INITIALIZE an array 'is_true' of size n with all values set to True
    INITIALIZE index 'j' to 0
    INITIALIZE step 'i' to 1

    WHILE step 'i' is less than or equal to 500000 DO
        IF 'is_true[j]' is True THEN
            SET 'is_true[j]' to False  // Mark the current position as False
        END IF
        
        INCREMENT step 'i' by 1
        UPDATE index 'j' to (j + i) MOD n  // Move to the next index based on the current step
    END WHILE

    INITIALIZE list 'remaining_true' with elements from 'is_true' that are still True

    IF the length of 'remaining_true' is equal to 0 THEN
        PRINT 'YES'  // All positions have been marked False
    ELSE
        PRINT 'NO'   // There are still True values indicating some positions are unmarked
    END IF
END FUNCTION
```

### Explanation of the Pseudocode:
1. **Input Handling**: The function accepts an integer `n`, representing the size of the boolean array.
2. **Initialization**: It creates an array `is_true` initialized to all True values indicating active positions.
3. **Modifying the Array**: A loop runs for a maximum of 500,000 iterations, checking and modifying elements in `is_true`.
4. **Index Management**: The current index `j` is updated based on the increment step size `i`, using modular arithmetic to wrap around the array.
5. **Final Check**: After the loop, it checks if any positions remain True and prints 'YES' or 'NO' accordingly. 

This pseudocode captures the algorithm's logic while abstracting away implementation details.
