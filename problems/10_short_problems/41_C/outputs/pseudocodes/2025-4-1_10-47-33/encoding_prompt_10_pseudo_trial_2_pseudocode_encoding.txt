Here's the pseudocode based on the provided code, following the steps outlined:

---

**Pseudocode:**

1. **Read Input:**
   - Set variable `inputString` to the value read from standard input, ensuring to remove any leading or trailing whitespace.

2. **Replace Substrings:**
   - Replace all occurrences of the substring "dot" in `inputString` with "." (a period).
   - Replace all occurrences of the substring "at" in `inputString` with "@" (an at symbol).

3. **Check Starting Character:**
   - If the first character of `inputString` is a period (`.`):
     - Prepend "dot" to `inputString` without the first character.

4. **Initialize Variables:**
   - Set variable `countAt` to 0 (used to track occurrences of the at symbol).
   - Create an empty list `resultList` to store processed characters.
   - Set variable `length` to 0 (not used later, but initialized).

5. **Handle Starting Character for `@`:**
   - If the first character of `inputString` is `@`:
     - Prepend "at" to `inputString` without the first character.

6. **Process Each Character:**
   - For each character `character` in `inputString`:
     - If `character` is `@`:
       - If `countAt` is greater than 0:
         - Append "at" to `resultList`.
         - Set `countAt` to 1.
       - Else:
         - Append `@` to `resultList`.
         - Set `countAt` to 1.
     - Else:
       - Append `character` to `resultList`.

7. **Join Result:**
   - Set variable `processedString` to the result of joining all elements in `resultList` into a single string.

8. **Check Ending Character:**
   - If the last character of `processedString` is a period:
     - Replace the last character with "dot".

9. **Output the Result:**
   - Print `processedString`.

---

**Assumptions:**
- Assumed that the input data will always be in a format where substrings "dot" and "at" can be replaced consistently.
- Assumed that the processed string length and conditions will handle edge cases, such as missing components or redundant symbols.

This pseudocode clearly outlines the logic and structure of the original code, emphasizing clarity and structured problem-solving.
