Given a problem description and its original code, generate clear, compact, and high-level pseudocode that is easy to read and understand. Use predominantly natural language with selective use of concise symbols and common abbreviations. Preserve original class and function names exactly, maintaining their nesting in classes/objects as in the original. Express logic preferably in one-line statements with minimal but consistent indentation for nested blocks. Use standard shorthand for variables (e.g., idx, cnt, tmp) and symbolic operators (&, |, ^, +, -, *, /, <, >, ≤, ≥, =, ≠). Avoid comments, explanations, summaries, or any output other than pure pseudocode. Numbering lines is optional; either number each line starting from 1 or omit line numbering, but do not add any extra formatting (no markdown, separators, or blank lines). Present control structures compactly, combining simple conditional or looping statements and updating variables inline whenever clarity is preserved.

Example style:  
in class <ClassName>  
in function <FunctionName>(parameters)  
let var be inferred type or explicit type  
x ← 0  
while x < n: x++  
for i in 0..n-1: if cond(i): do_something()  
if x > y: x ← y else: y ← x + 1  
call function(args)  
return result

Output only the pseudocode representing the original code’s logic following these guidelines strictly.