Translate the given code into clean, abstract pseudocode that precisely reflects its original logic, control flow, and data structures while maximizing clarity and readability. Preserve all original function and class names exactly as they appear, maintaining their hierarchical relationships and method signatures. Use uppercase for reserved keywords: FUNCTION, CLASS, IF, ELSE, FOR, WHILE, RETURN, SET, INCREMENT, DECREMENT, END IF, END FOR, END WHILE, END FUNCTION, END CLASS. Express all control structures explicitly but concisely, using common programming terms combined with natural language phrases to enhance understanding without unnecessary detail or simplification. Retain all variable names as in the source code unless a renaming clearly improves comprehension without breaking correspondence. Represent complex data types—such as trees, graphs, linked lists, and stacks—as abstract objects with properties and methods, not as raw language-specific containers or syntax. Avoid low-level syntax, specific language idioms, or literal code translations; instead, emphasize step-by-step logic suitable for direct human implementation. Do not include any comments, explanations, annotations, delimiters, or extra text—output only the pseudocode in a single continuous block that matches the original code’s structure and indentation level, appending explicit END statements (e.g., END FUNCTION, END CLASS) corresponding to each block. Structure conditionals and loops with matching end tokens for clarity. Use clear phraseology for operations (e.g., SET variable TO value, INCREMENT variable BY number, APPEND item TO list). For method returns, use RETURN followed by the returned expression or value. If typing information exists in the original signatures, incorporate it clearly but succinctly. Maintain direct, one-to-one correspondence to make the pseudocode amenable to verification and reimplementation without ambiguity or loss of detail.