```python
Translate the given pseudocode into idiomatic, efficient, and fully runnable Python 3 code, strictly preserving every class name, method/function name, parameter name, and their hierarchical structure exactly as given. Return your entire output wrapped inside a single Python code block like this:

```python
# translated Python code here
```

To maximize accuracy, robustness, and usability across a wide variety of problems, adhere to these precise guidelines:

1. Names & Structure:
   - Exactly retain all class names, method names, and parameter names from the pseudocode without any alteration or reordering.
   - Maintain the complete class/object hierarchy and method signatures exactly as in pseudocode.
   - Preserve all type hints as given or logically infer and supply explicit Python 3 type annotations if missing but clearly implied.

2. Syntax & Semantics:
   - Convert all pseudocode syntax and operators precisely into valid Python syntax: e.g., assignment arrows (←) become `=`, `null`/`nil`/`None` equivalents become `None` everywhere (class definitions, helpers, methods).
   - Replace any pseudocode boolean or control constructs with correct Python forms.
   - Use native Python data structures and idiomatic patterns for clarity and performance.
   - Include any necessary decorators (e.g., @staticmethod, @classmethod) exactly as required by the pseudocode signature.

3. Data Structures:
   - Detect custom data structures like linked lists (e.g., class ListNode), binary trees (TreeNode), graphs, etc. If used, provide a single canonical definition of each with standard Python style, including `__init__` with type hints.
   - Implement robust, production-grade builder/helper functions convertible from typical input forms (e.g., list representations with None placeholders) into these data structures.
   - Builders must handle all corner cases gracefully (empty inputs, one-node trees/lists, skewed/imbalanced shapes) and never assume inputs are already data structure instances.
   - Automatically integrate these builders into the solution methods so no method receives raw lists or primitives expecting `.next` or `.left` attributes—always convert first internally.
   
4. Input Handling & Safety:
   - All inputs that could be lists or primitive forms in test params (e.g., `root = [1,2,3,null,4]`) must be internally converted into appropriate class instances before any processing.
   - Prevent AttributeErrors by ensuring no code attempts to access attributes of raw lists or invalid types.
   - Never output or accept tokens like `null`, `nil`, or other pseudocode nulls; consistently use Python `None`.

5. Imports & Dependencies:
   - Import exactly what is needed for correctness and performance: standard modules (e.g., typing, collections, heapq, math, itertools) as applicable, no extraneous libraries.
   - Use `from typing import Optional, List, Dict` etc. for annotations where relevant.

6. Performance & Readability:
   - Optimize for runtime efficiency without sacrificing readability: use Pythonic idioms, list/dict comprehensions, generators, cached computations when beneficial.
   - Avoid redundant operations; minimize memory overhead.
   - Implement efficient traversal/build strategies for trees/lists/graphs.
   - Keep code concise yet clear and structured for immediate direct use in competitive programming or production.

7. Output Constraints:
   - Your final output must contain only the Python code block (no extra text, explanations, comments except extremely brief inline clarifications if absolutely necessary).
   - Do not insert any separator lines, headers, or non-functional strings.
   - The code should be ready-to-run as-is, suitable for instant submission or testing.

By following these enhanced instructions, your output will robustly solve any incoming pseudocode translation task, consistently passing extreme edge cases, preventing common errors (e.g., attribute access on raw lists), and producing idiomatic, performant Python solutions.


```