Given the pseudocode below, **without executing or simulating it**, carefully assess whether it is fully and unambiguously specified so that **any faithful implementation strictly following this pseudocode will pass all unit tests in every scenario, without exception**.

Output exactly one character per input pseudocode:

- **1** if and only if the pseudocode guarantees perfect reproducibility—complete clarity, deterministic correctness, and total coverage of all edge cases as required by a standard unit test suite;  
- **0** otherwise (if there is any ambiguity, omission, implicit assumption, incomplete interface, logical gap, or potential nondeterminism).

To determine this, rigorously verify the pseudocode against **all** the following criteria—answer “no” to any and output **0** immediately:

---

### 1. **Explicit and Precise Interface Definition**  
- The pseudocode’s entry point(s) (function, method, or class names) are explicitly stated and exactly match expected names and signatures in the testing framework (parameter names, order, types if given, and return types).  
- Inputs, outputs, and all parameters are fully declared or clearly defined with no ambiguity or missing elements.  
- No implicit inputs, outputs, or side channels (e.g., globals, external states, or environment assumptions).  
- All variables, constants, and data structures are explicitly declared or clearly introduced before use with unambiguous types or formats; initializations or starting states are clearly specified where required.

### 2. **Complete, Deterministic, and Unambiguous Algorithmic Specification**  
- Every control flow element (loops, recursion, conditionals) is fully specified with explicit start/end/bound conditions or clear termination guarantees for all valid inputs—no possibility of infinite loops or unbounded recursion.  
- Each computational step and state update is precisely described; no vague or language-dependent behavior is relied upon.  
- The logic fully realizes the problem’s stated or reasonably inferred intent with no missing crucial steps or branches.  
- All assumptions, preconditions, and invariants needed for correctness are explicitly given or unequivocally derivable solely from the pseudocode, never implied or left to guesswork.  
- No step or condition is open to multiple valid interpretations or ambiguous meanings.

### 3. **Exhaustive and Explicit Edge and Boundary Case Handling**  
- The pseudocode explicitly includes or unambiguously implies correct handling of all relevant edge cases and boundary values (e.g., empty inputs, minimal/maximal sizes, special or invalid inputs).  
- Array or string indices, offsets, and data accesses are precisely stated to prevent out-of-bound or undefined behavior under all valid inputs.  
- Exceptional or corner cases are clearly addressed or deliberately excluded with explicit notes; silent or implicit omission of edge-case behavior counts as uncertainty.

### 4. **Strict Implementation Independence and Full Determinism**  
- No references exist to external or global states, environmental variables, or methods/objects outside the pseudocode’s scope or inputs.  
- No platform-, language-, or environment-specific features are invoked.  
- No nondeterministic operations (such as randomization, concurrency, or relying on ordering of unordered collections) are present.  
- Given fixed inputs, the pseudocode deterministically produces a unique and fully defined output every time.

### 5. **Complete, Self-Contained, and Directly Translatable**  
- The pseudocode is standalone, requiring no external scaffolding, helper functions not defined within, or hidden dependencies to implement fully and correctly.  
- It can be directly translated into code that integrates seamlessly with standard unit testing harnesses without additional modification or external context.  
- If recursive or iterative, termination criteria are explicit and verifiable from the specification alone.

---

### Additional Operational Guidelines for Judgment:  
- Treat any uncertainty about variable initializations, control flow termination, data structure states, or interface signatures as failure (output **0**).  
- Do not fill in missing pieces by inference, “common sense,” or assumption—judge only on explicit and unequivocal content in the pseudocode.  
- Detect and reject pseudocode exhibiting contradictory steps, inconsistent updates, or logic conflicts.  
- Verify traceability of each variable and data transformation to ensure no gaps exist in understanding correctness or reachability of outputs.

---

**IMPORTANT:** Output must be strictly a single digit: **1** or **0**, with no additional text, formatting, or explanation.  
The output ordering must strictly correspond to the order in which pseudocodes are processed.

---

By applying this rigorous, criterion-driven evaluation to each pseudocode precisely as provided, you will maximize accuracy in distinguishing fully reproducible pseudocodes from incomplete or ambiguous ones, reducing false positives and false negatives effectively across diverse cases, including near-misses and cosmetic variants.