Given the pseudocode below, determine **without any execution, simulation, or guessing** whether it is fully self-contained, entirely explicit, and unambiguous such that **any faithful, specification-compliant implementation will pass all relevant unit tests exactly**.

Output **1** if and only if this pseudocode guarantees **complete reproducibility**—meaning there exists no interpretation or implementation variation based on it that would fail any unit test—and output **0** otherwise.

To decide, apply the following rigorous and exhaustive checklist, ensuring **every criterion is explicitly and precisely met, strictly from the pseudocode text alone**:

---

### 1. **Explicit and Standardized Interface & Structure**  
- The pseudocode defines **all expected top-level entities** (functions, procedures, methods, classes) with **unique, unambiguous, and case-consistent names** exactly matching the test harness specification.  
- Each function/method’s parameters are specified by **name, type, exact order, and semantics** explicitly and exhaustively, reflecting the exact testing interface—no ellipsis, defaults, optional or inferred parameters allowed.  
- Return values are fully described in number, type, and meaning, matching expected outputs precisely.  
- All variables and data structures are declared or introduced before use, with clearly specified, deterministic, and valid initial states or initialization steps. No implicit or uninitialized variables allowed.  
- The code’s overall modular and hierarchical structure (nesting, class membership, entry points) exactly conforms to the test environment interface requirements.

### 2. **Complete and Unambiguous Algorithm Specification**  
- All control flow constructs (loops, recursion, branches, conditionals) are described with **explicit, fully-defined conditions and ranges**, with proofs or clear guarantees of termination **for all valid inputs** (no infinite loops, no undefined halting behavior).  
- Every computational step is described precisely: all operations, data updates, side effects, and intermediate transformations must be fully traceable by reading the pseudocode—no dependence on external libraries, language-specific features, or implicit knowledge.  
- The algorithm fully addresses the problem scope it claims: no missing steps, no unstated assumptions or actions.  
- Preconditions, postconditions, and invariants relevant to correctness and completeness are explicitly stated or directly and unambiguously derivable from pseudocode content alone.  
- If any statement, operation, or logic branch can be reasonably interpreted multiple ways, or is underspecified or vague, output 0. Ambiguity is disqualifying.

### 3. **Thorough Edge Case and Boundary Handling**  
- The pseudocode explicitly enumerates or clearly and unambiguously implies correct handling of **all critical edge cases and boundaries** relevant to the problem, including but not limited to empty inputs, zero or minimal inputs, maximum size inputs, and invalid or special input values.  
- Indexing is precise with all bounds, offsets, and ranges defined so that no out-of-range or invalid access can occur.  
- Exceptional, corner, or error cases are either explicitly handled or explicitly declared and justified as out of scope.  
- Silent omission or implicit, guesswork-based handling of exceptional or boundary conditions is disallowed.

### 4. **Determinism and Environment Independence**  
- The pseudocode’s behavior and outputs depend solely on the declared input parameters; there is no reliance on external, global, mutable, or hidden state.  
- No use of randomness, concurrency, non-deterministic constructs, or unspecified operation order.  
- The output for any fixed valid input must be uniquely determined by the pseudocode’s steps without variability or ambiguity.

### 5. **Direct Translatability and Completeness Without External Dependencies**  
- The pseudocode is sufficiently detailed to be directly implementable as a standalone solution, without any supplementary specification, environment-specific fixes, or assumed helper code.  
- The interface matches exactly the expected test harness signature and types with no additions, omissions, or mismatches.  
- No implicit dependencies on external libraries, built-in functions beyond basic arithmetic, logical, or data structure operations clearly specified in the pseudocode.

---

### Decision and Output Instructions:  
- If **all** above stringent criteria are met explicitly and without exception, output exactly **`1`**.  
- If **any single** condition is unmet, ambiguous, incomplete, or contradicted, output exactly **`0`**.  
- **Do not perform any guesswork, inference beyond explicit pseudocode, or any external assumption; judge strictly on the letter of the pseudocode alone.**  
- Output only one digit per pseudocode input, in the order pseudocodes are received, with **no extra text, commentary, formatting, or explanation**.

---

This prompt enforces a **zero-tolerance, fully explicit reproducibility standard** designed to maximize precision and eliminate false positives/negatives by focusing on exact, strict specification completeness, determinism, edge coverage, and interface conformity. Use it to reliably distinguish pseudocode that guarantees success on all unit tests from that which does not.