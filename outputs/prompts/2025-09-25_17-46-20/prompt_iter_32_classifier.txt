Given the pseudocode below, determine with **absolute certainty and no execution or simulation** whether it is perfectly and unambiguously specified such that **any faithful implementation strictly following it will pass every unit test exactly**.

Output **1** if and only if the pseudocode guarantees **full reproducibility** (no ambiguity, no missing detail, no unstated assumption) that ensures all unit tests pass without exception.

Otherwise, output **0**. No extra text, formatting, or explanation—only one digit per pseudocode input, in input order.

To decide, verify all these criteria rigorously and holistically:

---

### 1. **Explicit and Exact Structural & Interface Specification**  
- The pseudocode defines all classes, functions, procedures, or methods with clear unique names precisely matching the testing environment’s expected signatures.  
- Function/method parameter names, order, count, and types must be **fully explicit and exactly match** the interface expected by the test harness.  
- Return type(s), meaning, and expected output format must be completely and clearly stated; no implicit assumptions about output form are allowed.  
- All variables, data structures, constants, and inputs must be explicitly declared or introduced, with precise initialization or guaranteed valid starting states prior to use—no undefined or implicit initial states.  
- The overall program structure (including entry points) aligns exactly with test expectations; no missing, extra, or renamed elements.

### 2. **Deterministic, Fully Detailed Algorithmic Flow**  
- Every control-flow construct (loops, recursion, conditionals) has **explicit, unambiguous, and exact** test conditions, loop bounds, and guaranteed termination conditions valid for **all possible valid inputs**.  
- No potential for infinite loops, missing exit conditions, or undecidable states.  
- Each computational step is clearly described including all data transformations, side effects, intermediate calculations, with no reliance on knowledge outside the pseudocode.  
- The algorithm completely covers the problem domain, with **no implicit gaps, unstated edge cases, or hidden assumptions** anywhere.  
- Any necessary invariants, preconditions, postconditions, or assumptions on input data correctness are explicitly stated or fully derivable only from provided pseudocode.  
- Any expression or step that admits multiple interpretations or ambiguity invalidates reproducibility.

### 3. **Explicit Handling or Clear Unambiguous Specification of All Edge and Corner Cases**  
- All relevant edge cases (empty inputs, minimal or maximal values, special input patterns, invalid inputs where applicable) are directly handled or clearly and unambiguously implied by the pseudocode logic.  
- Accesses to arrays, lists, or indexed structures define **precise and safe index bounds** preventing out-of-bounds or undefined data access under any valid input.  
- Exceptional, boundary, or corner cases that are not handled must be explicitly declared with no ambiguous silence; failing to specify or incorrectly imply such cases results in output 0.

### 4. **Environment Independence and Pure Determinism**  
- The pseudocode is fully self-contained and relies only on declared inputs and defined outputs; no external, global, hidden, or environment-dependent state affects behavior.  
- No non-deterministic elements: no randomness, no unspecified ordering of operations, no platform-dependent features or side effects.  
- For every fixed valid input, output must be uniquely and deterministically defined by the pseudocode without external influence.

### 5. **Direct Translatability and Strict Test Harness Conformance**  
- The pseudocode can be directly and immediately turned into a standalone implementation without requiring any unstated helper routines, scaffolding, or third-party libraries.  
- Function/class signatures, parameter names, types, and return formats align perfectly with those expected by the unit tests—no guessing or modifications required.  
- No missing critical implementation details that would force guesswork, assumptions, or environment-specific fixes.

---

### Decision Rules & Final Notes

- If **any doubt**, partial specification, implicit assumption, ambiguous phrasing, contradictory information, or missing detail exists, output **0**.  
- Do **not** infer, guess, or fill gaps by “common sense” or external knowledge; judge by **explicit content only**.  
- Recursive or iterative logic lacking a precise, provable termination condition on all valid inputs leads to output 0.  
- Ensure all variables, state changes, and intermediate operations are fully defined and traceable within the pseudocode.  
- Outputs must be absolutely reproducible, guaranteeing passing every unit test without exception.

---

**Output: exactly one digit (`1` or `0`) per pseudocode input line, no explanations or formatting.**  
`1` = fully reproducible, guaranteed passing all tests  
`0` = not reproducible, ambiguous, incomplete, or inconsistent

---

This prompt prioritizes **completeness**, **precision**, **determinism**, and **interface fidelity** to maximize accuracy and correctly differentiate perfectly reproducible pseudocode from those prone to failure.