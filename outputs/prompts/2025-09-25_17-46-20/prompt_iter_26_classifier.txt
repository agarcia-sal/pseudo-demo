Given the pseudocode below, **without executing or simulating it**, determine if it is fully and explicitly specified so that **any faithful implementation derived from this pseudocode will pass all relevant unit tests under the exact interface expected**.

Output **1** only if the pseudocode *unambiguously and completely* satisfies *every* one of the following comprehensive conditions; otherwise output **0**.

---

### A. Complete Interface and Structural Clarity:  
- The pseudocode explicitly defines all classes, functions, methods, procedures, and main entry points exactly as required by the test environment, including correct names, signatures, parameter lists (with clear order, types or domains if applicable), and explicit return types or output semantics.  
- All variables, constants, and data structures used are declared or introduced with precise definitions and initial values or states prior to any usage. There are no hidden or implicit dependencies on external or global state beyond inputs and outputs.  
- The pseudocode’s composition and structure correspond strictly to the unit test harness expectations, requiring no supplementary scaffolding, environment assumptions, or implicit context.

### B. Explicit and Deterministic Algorithmic Detail:  
- Control flows (loops, recursion, conditional branches) are exhaustively and clearly described with well-defined conditions, ranges, and guaranteed termination for all valid inputs, preventing infinite loops or unbounded recursion.  
- Each computation or data transformation step is fully specified: no unspecified side effects, no reliance on language-, implementation-, or hardware-dependent behavior, and no ambiguous or underspecified operations.  
- All logical algorithms address the full problem specification with no omitted intermediate steps or reasoning gaps.  
- All assumptions, invariants, preconditions, or conditions critical to correctness and reproducibility are either explicitly stated or unambiguously deducible strictly from the pseudocode content itself — never assumed or inferred beyond what is written.  
- Any potential ambiguity, multiple interpretations, or vague phrasing at any step immediately mandates outputting **0**.

### C. Exhaustive and Explicit Edge and Boundary Case Handling:  
- Handling of all meaningful edge cases—including empty inputs, maximum/minimum bounds, special or invalid inputs—is explicitly present or clearly ensured without ambiguity.  
- Indices, offsets, data access patterns, and boundary conditions are precisely defined to guarantee no out-of-bounds or undefined behavior for all valid inputs.  
- Exceptional cases and corner scenarios are explicitly addressed or deliberately and clearly excluded with justification; silent, implicit, or inconsistent handling is disallowed.

### D. Implementation Independence and Consistency:  
- The pseudocode contains no references to external state, environment variables, or side effects beyond declared inputs and outputs.  
- No reliance on randomness, non-deterministic operations, or undefined ordering/parallelism exists; every fixed input deterministically produces exactly one output.  
- No platform- or language-specific constructs, syntax, or behaviors are present that could impair faithful re-implementation.

### E. Self-Contained, Directly Translatable, and Test-Compatible:  
- The pseudocode stands alone and is complete: it does not require undeclared helper functions, external libraries, or hidden scaffolding.  
- Interfaces and internal design map immediately and transparently onto typical unit test harness requirements, needing no adaptations or extensions.  
- Variable names and parameter naming adhere exactly to expected test signatures, with no ambiguity or mismatch.

---

### Additional Operational Rules for Judgment:  
- Treat *any* uncertainty about variable initialization, control flow termination, return conditions, or side effects as cause for output **0**.  
- Do not “fill in” missing details by inference or common coding conventions; only explicit and unequivocal specification counts.  
- Confirm and mentally trace all data flow paths and transformations fully, including intermediate states in complex algorithms — any inconsistency or contradiction mandates output **0**.  
- Ensure that all input/output types, formats, and naming precisely match expected test interface without deviation.  
- Recursive or iterative constructs must include explicit guaranteed exit conditions preventing infinite operation for *all* inputs.

---

**Output instructions:**  
- Exactly one character per pseudocode input: **1** if and only if *all* above rigorous conditions are met without exception, otherwise **0**.  
- Output order corresponds exactly to the input pseudocode order.  
- No explanations, comments, formatting, whitespace, or additional text allowed—only the digit `1` or `0`.

---

This enhanced, precise, and operationally rigorous prompt is designed to decisively improve reproducibility classification accuracy by rejecting all unresolved ambiguities, enforcing complete edge coverage, strict termination guarantees, and exact interface adherence.