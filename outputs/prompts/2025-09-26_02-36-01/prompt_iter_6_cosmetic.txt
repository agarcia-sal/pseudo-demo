Given input pseudocode, produce a fully transformed version that adheres to these strict requirements:

- Functional equivalence: The output pseudocode must retain the exact original behavior, producing identical output, side effects, and adhering to all logic precisely.

- Idempotent identifiers and structure: Preserve verbatim all class names, function/method names, class inheritance, and object organization exactly as in the input pseudocode. Function/method signatures (name, parameters, order, and return types if given) must remain unchanged. Do not rename or restructure these elements.

- Maximize difference in all other code aspects, applying comprehensive, layered rewrites including but not limited to:  
  • Convert all loop forms into alternate logically equivalent constructs, completely changing their style (for ↔ while ↔ recursion ↔ tail recursion ↔ repeat-until).  
  • Globally rename every local variable, parameter, and temporary identifier to new, semantically consistent but unrelated names never used originally. Avoid repeating any original local or temporary name.  
  • Restructure all expressions deeply: switch arithmetic and logical equivalences, exploit identities, rewrite conditionals via De Morgan’s rules, replace compound operators with expanded forms and vice versa, reorder independent operations safely, use equivalent but differently formulated index computations.  
  • Drastically reshape control flow by splitting or merging conditionals or loops, unrolling or refolding iterations, inlining or extracting expressions or subcomputations, switching between early returns and deferred return variables.  
  • Introduce and remove intermediate temporary variables smartly to alter expression grouping and sequencing while preserving all dependencies and outcomes.  
  • Substitute literal constants consistently with expanded expressions (e.g., use sums or multiplications to express numeric literals), alternative boolean literal styles, and alternate explicit constant definitions or derivations.  
  • Vary all formatting styles thoroughly: change indentation, spacing, block delimiters, keyword casing, and line breaks to appear stylistically independent from the input.  
  • Change traversal order of data structures where output and side effects remain invariant (e.g., iterate forwards versus backwards).  
  • Replace direct calls to built-in or library routines with functionally identical custom helper subroutines defined locally, or vice versa.  
  • Convert iterative constructs to recursion and recursion to iteration wherever semantics allow.  
  • Re-express condition checks to equivalent alternative logical constructs, including nested ifs replaced with guard clauses or combined guards replaced by split conditionals.  
  • Avoid any reuse of original local variable or temporary identifiers; ensure all such names are newly generated and unrelated to originals.  
  • Preserve external API and interface identifiers exactly and verbatim with zero changes.

- Do not remove, add, or abstract any algorithms, data structures, steps, or conceptual elements. No optimizations or semantic shortcuts allowed that change or simplify the logic.

- The output must be exactly the rewritten pseudocode alone, presented as a self-contained, original-seeming, standalone elaboration distinct in syntax and style, but strictly semantically identical.

- This transformation applies universally to any input pseudocode regardless of domain or problem content.

- Your response must only be the transformed pseudocode text; omit any explanations, comments, annotations, or supplemental remarks.

- Emphasize layered orthogonal transformations leveraging syntax, semantics-preserving rewriting, control flow refactoring, identifier substitution, expression re-encodings, and formatting variation to force maximal syntactic divergence while preserving all named interface elements unmodified.

- Maintain provided function and class names and structure exactly as in the input.

- This prompt is designed to produce maximal surface-level divergence, generating rewritten pseudocode that appears fully independently implemented, with minimal lexical or structural resemblance to the original, beyond the essential preserved identifiers.

Output only the rewritten pseudocode.