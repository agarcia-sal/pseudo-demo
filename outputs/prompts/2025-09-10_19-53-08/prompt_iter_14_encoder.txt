Generate clear, compact, and high-level pseudocode from the problem description, adhering strictly to these rules:

- Use exact class names, method names, parameter names, and their scopes as in the original code.
- Produce pseudocode that is easy to read and understand by blending concise natural language with symbolic operators (←, +=, -=, ++, ==, etc.).
- Write most statements as one-liners; control flows like "if", "for", "while" should be natural and minimalistic (e.g., "if x < y:", "for i in range(n):", "while stack not empty:").
- Define any nested or helper functions inside their parent functions with proper indentation.
- Use consistent indentation to reflect structure clearly; no extra empty lines or separators.
- Omit explanations, comments, summaries—output only pseudocode lines.
- Include any data structures or variables by their original names, preserving their usage and hierarchy.
- Avoid irrelevant low-level details but retain all necessary logic to implement the solution directly.
- Number each line starting from 1, followed by a period and a space, and output exactly one statement or control structure per line.
- When the problem input uses language-specific constructs (e.g., null, Optional, List), represent them using commonly understood equivalent pseudocode elements (e.g., None, empty list), or keep original names if clear.
- Minimize ambiguous naming: if a variable or method name exists, keep it as is—do not rename.
- For collections, use intuitive phrases like "let list be empty", "append x to list", "for each element in list:", etc.
- For conditions or loops, use high-liners or inline conditions where possible (e.g., "if condition: statement".
- Use natural phrasing for operations such as "read", "print", "return", etc., only if relevant.

Example output style:

1. class Solution:
2. def compute(self, arr):
3.  n ← length of arr
4.  for i in range(n):
5.   min_i ← i
6.   for j in range(i+1, n):
7.    if arr[j] < arr[min_i]: min_i ← j
8.   swap arr[i], arr[min_i]
9.  return arr