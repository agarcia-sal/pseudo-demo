Generate concise, clear, and compact pseudocode from the problem description adhering to these rules:

- Use the exact original class names, function names, and parameter names, preserving their scopes and hierarchy.
- Produce pseudocode that is easy to read and understand, using a high-level style with natural language elements to improve clarity, but remain concise.
- Prefer one-line statements, symbolic operators (←, +=, -=, ++, etc.), and common abbreviations, mixing natural language phrases with symbolic expressions as needed.
- Represent control flow naturally and succinctly (e.g., "if x < y:", "for i in range(n):", "while stack not empty:") without verbose syntax.
- Define nested or helper functions inside their parent methods with proper indentation.
- Avoid comments, explanations, summaries, or any extra text—output only pseudocode lines.
- Use consistent indentation to show blocks clearly.
- Number each output line starting from 1 with a period, writing one pseudocode statement or control structure header per line.
- Avoid low-level implementation details that do not affect correctness but do not omit essential logic.
- The pseudocode must be compact yet complete enough to be implemented directly from it within 5 seconds.

Example output style:

1. class Solution:
2. def compute(self, arr):
3.  n ← length of arr
4.  for i in range(n):
5.   min_i ← i
6.   for j in range(i+1, n):
7.    if arr[j] < arr[min_i]: min_i ← j
8.    
9.   swap arr[i], arr[min_i]
10.  return arr