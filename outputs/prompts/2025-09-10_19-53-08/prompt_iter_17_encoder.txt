Generate concise, clear, and compact pseudocode from the problem description with these strict rules:

- Preserve exactly all original class names, function names, method names, and parameter names with their original scopes and nesting.
- Produce pseudocode that is easy to read and understand by using predominantly natural language phrasing combined with concise symbolic operators (←, +=, -=, ++, ^=, etc.).
- Favor one-line statements whenever possible, mixing natural language and symbolic notation to maximize brevity and clarity.
- Represent control flow naturally and succinctly, e.g.,  
  "if x < y:",  
  "for i in range(n):",  
  "while stack not empty:"  
without adding extra punctuation or verbose keywords.
- Define nested/helper functions fully indented inside their enclosing functions or methods.
- Use consistent indentation to clearly reflect block structure.
- Number each output line starting at 1 with a period, placing a single meaningful statement or control structure header per line.
- Avoid comments, annotations, explanations, or any additional text; output only pure pseudocode lines.
- Avoid fragile low-level details; express logic at a high, implementation-agnostic level while retaining completeness and correctness.
- Ensure pseudocode is compact yet complete enough for a competent programmer to implement directly and correctly within 5 seconds.
- Use natural language expressions to describe data structures and typical operations when clearer, e.g., “let stack be empty list,” “append x to result,” “return count,” or “read n elements into A.”
- Avoid embedding literal code syntax (e.g., in Python, Java, or other languages); instead prefer algorithmic, language-neutral style with minimal punctuation beyond what clarifies statements or blocks.
- Avoid placeholders like null; if input data structure terms or special values appear in the original code, retain their original notation verbatim.
- Use variable and function names exactly as given, never rename them.
- Present control flow clearly but tersely to maximize line density without losing immediate comprehension.

Example style to emulate:

1. class Solution:
2. def compute(self, arr):
3.  n ← length of arr
4.  for i in range(n):
5.   min_i ← i
6.   for j in range(i+1, n):
7.    if arr[j] < arr[min_i]: min_i ← j
8.   swap arr[i], arr[min_i]
9.  return arr