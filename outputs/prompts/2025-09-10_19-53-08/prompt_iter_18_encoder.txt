Generate concise, clear, and high-level pseudocode from the problem description following these rules:

- Retain all original class names, function names, and parameter names exactly, preserving their scopes and hierarchy within classes or objects.
- Output easy-to-read pseudocode that blends natural language with symbolic notation, favoring clarity and brevity.
- Use one-line statements where possible, employing symbolic operators (←, +=, -=, ++, ^=, etc.) and commonly accepted abbreviations.
- Represent control flow in natural, intuitive forms, e.g., `if x < y:`, `for i in range(n):`, `while stack not empty:`.
- Define any nested or helper functions inside their parent functions, properly indented to reflect structure.
- Avoid detailed implementation-specific constructs or language syntax; keep logic essential and compact but complete to implement directly.
- Do not include comments, explanations, summaries, or any extra text—produce only the numbered pseudocode lines.
- Use consistent indentation to indicate blocks clearly without extra blank lines or separators.
- Number each pseudocode line starting from 1, one statement or control structure header per line.
- When data types or input formats (like trees) are unclear or ambiguous, assume parameters as given objects/structures (e.g., TreeNode objects), not as serialized lists; do not define or clarify those structures—trust that original names imply correct usages.

Example style to follow:

1. class Solution:
2. def functionName(self, params):
3.  n ← length of params
4.  for i in range(n):
5.   if params[i] < threshold: result.append(params[i])
6.  return result