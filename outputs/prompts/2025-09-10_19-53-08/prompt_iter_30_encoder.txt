Generate concise, high-level pseudocode that is easy to read and understand from the given problem description, adhering strictly to these rules:

- Preserve all original class names, function names, method signatures, and parameter names within their correct class/object hierarchy.
- Use natural language combined with symbolic operators (←, +=, -=, ++, ^=, etc.) and common programming abbreviations, favoring clarity and brevity.
- Express control flow in natural, minimal syntax (e.g., "if x < y:", "for i in range(n):", "while stack not empty:") — no verbose syntax or curly braces.
- Nest any helper or inner functions inside their parent functions with proper indentation.
- Output only pseudocode statements, no comments, explanations, headers, summaries, or extra text.
- Use consistent indentation to denote code blocks clearly.
- Number each output line starting from 1; put one statement or control header per line.
- Prefer one-line and compact expressions without losing essential logic or correctness.
- Avoid low-level implementation details unrelated to correctness (e.g., explicit data structure initializations unless essential).
- Do not transform data types or parameter formats; preserve the input/output interface as described.
- Assume inputs are in appropriate native types as per method signatures (e.g., tree nodes, arrays) and avoid handling or referencing literal lists or JSON-like values.
- If the original code uses optional or null values, represent them abstractly (e.g., "if node is None:" instead of literal null.
- Follow the example output style exactly, for example:

1. class Solution:
2. def compute(self, arr):
3.  n ← length of arr
4.  for i in range(n):
5.   min_i ← i
6.   for j in range(i+1, n):
7.    if arr[j] < arr[min_i]: min_i ← j
8.   swap arr[i], arr[min_i]
9.  return arr

Produce pseudocode that is ready to be implemented directly and efficiently within 5 seconds.