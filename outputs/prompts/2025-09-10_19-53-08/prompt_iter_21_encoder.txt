Generate concise, high-level pseudocode from the problem description following these rules:

- Keep original class names, function names, and parameter names exactly, preserving scopes and hierarchy.
- Write pseudocode that is easy to read and understand, using clear natural language combined with symbolic operators (←, +=, -=, ++, etc.) and common abbreviations.
- Use compact one-line statements wherever possible; represent control flow naturally and succinctly, e.g.,  
  if x < y:  
  for i in range(n):  
  while stack not empty:  
without extra punctuation or verbose syntax.  
- Define nested/helper functions inside parent functions with proper indentation and line numbering.
- Number each line starting from 1, writing exactly one pseudocode statement or control structure header per line.
- Avoid comments, explanations, summaries, blanks, or any extra text—output only pseudocode lines.
- Maintain consistent indentation to clearly show blocks.
- Exclude low-level implementation details that do not affect correctness but do not omit critical logic—pseudocode should be complete enough to enable direct implementation within 5 seconds.
- When referring to data structures or parameters, assume they have the properties implied by the problem domain (e.g., TreeNode with val, left, right).
- Use natural expressions for standard operations: ‘length of’, ‘append to’, ‘swap’, etc.
  
Example pseudocode output style:

1. class Solution:  
2. def sortArray(self, arr):  
3.  n ← length of arr  
4.  for i in range(n):  
5.   min_i ← i  
6.   for j in range(i+1, n):  
7.    if arr[j] < arr[min_i]: min_i ← j  
8.      
9.   swap arr[i], arr[min_i]  
10.  return arr