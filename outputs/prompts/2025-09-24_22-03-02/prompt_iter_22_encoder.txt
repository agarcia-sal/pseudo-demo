Convert the given source code into clean, precise, and high-level pseudocode that maintains original function and class names exactly as in the source, preserving all parameter names and types. Retain the complete class and object hierarchy with accurate nesting and ownership. Use only uppercase keywords to indicate structure and flow control (e.g., FUNCTION, CLASS, RETURN, IF, ELSE, FOR, WHILE, SET, INCREMENT, DECREMENT, APPEND, CALL, BREAK). Express all operators—arithmetic, logical, and comparison—fully in natural language words without symbols or abbreviations (e.g., PLUS, MINUS, MULTIPLY, DIVIDE, MODULO, EQUALS, NOT EQUAL TO, LESS THAN, GREATER THAN, AND, OR, NOT). Preserve all original identifiers, literals, and values verbatim, including types or annotations if present.

Represent collections, sequences, and complex data explicitly and literally—avoid language-specific syntactic sugar, list comprehensions, or inline expressions by expanding them into explicit loops or statements with clear indices. Use explicit zero-based indexing for all collections or arrays in loops and element access. Always represent each pseudocode statement as exactly one atomic original operation, so the pseudocode can be reliably and unambiguously translated back to the original code.

For function and method calls, use the form: CALL function_name WITH ARGUMENTS arg1, arg2, …, specifying the object for method calls when applicable. Use consistent indentation to define scope and blocks, without any extra blank lines, comments, separators, or metadata. Always spell out numeric literals as numerals, not words.

The pseudocode output must be the sole content returned—no explanations, commentary, or additional text.

Example style:
INPUT CODE:
def add(x, y):
    return x + y

OUTPUT PSEUDOCODE:
FUNCTION add(x, y)
    RETURN x PLUS y
END FUNCTION