```
You are tasked with analyzing a given pseudocode solution to determine its *full reproducibility*—whether it contains all necessary and explicit elements such that an experienced developer can implement it exactly as specified and produce a program guaranteed to pass *all* relevant unit tests for its intended problem, without requiring any assumptions, external knowledge, or guesswork.

---

To decide whether the pseudocode is fully reproducible, rigorously evaluate it according to the detailed criteria below. If it meets *every* criterion, output **1**; otherwise, output **0**. Output only a single digit per input pseudocode, nothing else.

---

### Evaluation Criteria for Full Reproducibility

1. **Explicit Structural Definition:**  
   - The pseudocode must clearly define all top-level components it asserts, typically including a class (if relevant), with all functions/methods explicitly declared with names and *all* their parameters named, typed or described, and matching the intended problem input/output signature.  
   - No missing or vague parameter lists.  
   - Intermediate functions (e.g., helper or recursive functions) must be similarly defined with clear signatures.  
   - The pseudocode’s scope, boundaries, and hierarchical structure must be unambiguous.

2. **Complete and Precise Control Flow:**  
   - All loops, branches (if/else/switch), and recursion bases/conditions must be fully specified with explicit conditions and clear iteration or branching logic, allowing exact translation into executable code.  
   - No partial, informal, or fuzzy flow control expressions.  
   - Loop ranges and increments/decrements must be stated unambiguously (e.g., FROM X TO Y INCLUSIVE/EXCLUSIVE).  
   - Control flow constructs must properly open and close (no dangling or missing END statements).

3. **Detailed Operational Semantics:**  
   - Every operation (assignments, arithmetic, logic, data accesses) must be stated concretely and unambiguously. Avoid vague action words like “process”, “handle”, “do something”; instead, specify what exactly occurs.  
   - Data structures must be explicitly initialized, typed (even if informally), and manipulated with clear indexing and bounds.  
   - Any transformation or computation must specify exact operands, results, and storage.  
   - No operations should rely on implicit behavior or external assumptions (e.g., no “assume sorted”; instead specify how/when sorting happens).

4. **Comprehensive Input and Output Specification:**  
   - Inputs must be explicitly named and their relation to the function signature clear.  
   - Initial states of inputs and variables must be defined.  
   - Outputs or return values must be clearly stated, directly tied to inputs and internal computations without ambiguity.  
   - No missing return statements or undefined output conditions.

5. **No Omitted or Ambiguous Details (Self-Containment):**  
   - The pseudocode should not omit critical steps, corner case handling, initialization, cleanup, or finalization operations.  
   - It should contain all necessary definitions and logic to cover the full intended problem domain, including edge cases implied by the problem constraints.  
   - No reliance on assumed language features, helper libraries, or implicit shortcuts.  
   - No partial implementations or placeholders such as “TODO” or “...” or vague references.

6. **Correctness Implied for All Unit Tests:**  
   - The pseudocode must be a *complete* and *correct* solution such that renedering it verbatim into real code passes *every* unit test (including edge, corner, and error cases).  
   - If the pseudocode omits any condition, scenario, or correctness detail that could cause failure on any test, it is *not* reproducible.  
   - Partial solutions that work on “most” but not all tests count as not reproducible.

7. **Consistency and Syntax Validity:**  
   - The pseudocode must be internally consistent, with no conflicting definitions or contradictory statements.  
   - Syntax should be unambiguous and parseable into formal code structures without needing interpretation or correction.

---

### Your Output

- After thoroughly applying all criteria above, output a single integer:  
  - **1** if the pseudocode is fully reproducible per the strict definition above.  
  - **0** otherwise.

- The output sequence corresponds exactly to the input order of pseudocodes processed.

- Output strictly one digit per pseudocode, with no extra text, explanation, or formatting.

---

### Important Reminders

- Be conservative: borderline, nearly complete, or ambiguous pseudocode must be marked as **0**.  
- Reject pseudocode missing explicit function signatures, class definitions, parameter lists, or with vague/implicit logic.  
- Accept only pseudocode that enables accurate, direct implementation without added assumptions or filler.  
- This decision must hold for *all* unit tests, including edge cases, not just the majority.

---

Pseudocode:

```
<<INSERT PSEUDOCODE HERE>>
```
```
