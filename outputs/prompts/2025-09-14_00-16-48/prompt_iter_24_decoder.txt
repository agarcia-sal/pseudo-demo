```python
Translate the given pseudocode into a single, complete, executable, and idiomatic Python solution enclosed within one contiguous Python code block as shown:

```python
# your entire implementation here
```

Follow these enhanced and precise guidelines to maximize correctness, fidelity, and robustness:

1. **Exact Structural Fidelity:**  
   - Preserve all class, method, and function names, signatures (including parameter names and default values), return types, and class hierarchies exactly as in the pseudocode without any renaming, omission, or addition.  
   - Method and function scopes (static, instance, class) must remain as in the pseudocode.

2. **Strict Data Literal Conversion:**  
   - Convert all pseudocode null-like values (`null`, `nil`, `None`, or equivalents) to Python `None`, including when nested inside lists, dicts, default parameters, or any complex data structures.

3. **Comprehensive Helper Class and Utility Definitions:**  
   - Include full, standard, and fully functional helper data structures (like `TreeNode`, `ListNode`, `Node`, etc.) exactly as required by the pseudocode context.  
   - Implement constructors, attributes, and any typical conversion utilities commonly used to transform native Python types (e.g., lists) into these structures and vice versa, ensuring robust handling of `None` values and empty inputs.  
   - Utilities must be deterministic, thoroughly handling edge cases without raising exceptions.

4. **Minimal and Purposeful Comments:**  
   - Include comments *only* to clarify complex or non-obvious structural elements or to define the role of helper utilities.  
   - Avoid explanatory or debugging comments within core logic.

5. **No Extraneous Code or Side Effects:**  
   - Do not add any test harnesses, input prompts, print/debug statements, or `if __name__ == "__main__":` guards.  
   - Only provide the solution focused on the pseudocode logic and its correct input/output behavior.

6. **Dependencies and Libraries:**  
   - Restrict imports strictly to Python 3 standard libraries and well-established built-in modules (`typing`, `collections`, `heapq`, `itertools`, `math`, `functools`, etc.).  
   - Avoid any third-party or non-standard dependencies.

7. **Code Style, Readability & Typing:**  
   - Write idiomatic, clean Python 3 code with consistent style, including indentation, naming, and spacing.  
   - Use type hints consistently on all function signatures and class attributes as appropriate, leveraging `typing` (e.g., `Optional`, `List`, `Dict`, `Union`).  
   - Maintain the exact function signatures as in the pseudocode.

8. **Robustness and Edge Case Handling:**  
   - Ensure the code correctly handles all valid inputs and edge cases implied by the pseudocode, including empty or minimal inputs, unusual parameter values, or repeated elements.  
   - Guard against common runtime errors (e.g., attribute errors when receiving raw lists instead of nodes).  
   - Only add input validation or conversions if necessary to faithfully implement pseudocode logic.

9. **Optimal Performance Within Time Constraints:**  
   - Prioritize correctness and clarity first; then, if possible without sacrificing readability or faithfulness, optimize to run efficiently within a 5-second time limit on typical problem inputs.

10. **Output Format:**  
    - Return a *single*, continuous Python code snippet enclosed exclusively within triple backticks with the `python` language specifier, i.e.,

    ```python
    # Complete Python solution here
    ```

    - Do not output anything else (no text, no explanations, no delimiters).

11. **Input Pseudocode Placeholder:**  
    - Treat the given pseudocode literally as input; **do not** preprocess or modify it unless strictly converting it into syntactically valid Python code as required.

Input pseudocode:  
[Insert pseudocode here]
```