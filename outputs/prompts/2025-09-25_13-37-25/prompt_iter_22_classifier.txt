Given a pseudocode input describing a function or class method intended to solve a programming problem, output **one digit per input** — **1** if the pseudocode is strictly and fully reproducible, meaning *any* faithful, direct implementation derived solely and exactly from it will pass *all* valid, comprehensive unit tests for the problem; output **0** otherwise. Return no explanations, comments, or any extra text. The sequence of outputs must correspond exactly and only to the input sequence.

To decide, rigorously verify the following, rejecting if *any* criterion is unmet or ambiguous:

1. **Explicit Problem Context & Contract:**  
   The pseudocode fully and unambiguously defines the problem inputs (including data types and all valid value ranges), expected output format, and correctness criteria, without requiring any unstated assumptions or external context.

2. **Complete, Formalized Interface:**  
   The function or method signature is given explicitly with precise parameter names and types, return type, and full class or module context if applicable; this interface perfectly aligns with problem requirements and test harness expectations.

3. **Detailed, Deterministic Algorithmic Specification:**  
   Every step — initializations, control flow (loops, recursion, conditionals), variable updates, and termination conditions — is exhaustively and precisely described, covering all normal, edge, and boundary scenarios; no implicit, missing, or partial branches remain.

4. **Comprehensive Edge Case & Error Handling:**  
   All input edge cases, exceptional conditions, and input constraints are either explicitly handled or logically ensured by the pseudocode’s flow; no input can cause undefined, partial, or unpredictable behavior.

5. **Unambiguous Semantics of Operations:**  
   Each operation (arithmetic, indexing, data structure manipulation, mutation, function calling) is precisely and unambiguously specified with clear semantics; no vague, shorthand, or symbolic constructs that require interpretation beyond literal reading.

6. **Logical Consistency & Internal Coherence:**  
   The pseudocode contains no contradictions, omissions, or conflicts; data flow, control flow, and state transitions are sequentially and logically coherent such that implementation order and correctness are clear.

7. **Sufficient Completeness for Direct Implementation:**  
   The pseudocode can be translated verbatim into runnable source code in a standard programming language without conjecture, missing scaffolds, or added assumptions; helper routines or dependencies, if any, are fully specified within the pseudocode.

8. **Explicit Enforcement of All Constraints and Specifications:**  
   Any critical problem-specific constraints, invariants, and domain rules—such as input limitations, resource bounds, ordering or uniqueness conditions—are affirmatively and clearly enforced or guaranteed by the algorithm itself.

9. **Self-Containment & No Hidden Dependencies:**  
   The entire necessary logic and all required subroutines are completely included or defined; no reliance on unstated helper functions, external libraries, or omitted steps critical for correctness.

10. **Clear, Complete Class/Function Binding:**  
    The pseudocode defines all necessary declarations for proper binding, visibility, and namespace resolution (e.g., correct class definitions, method signatures, and access modifiers), ensuring the code can be instantiated and invoked exactly as required by automated tests.

11. **Precise Definition of Mutability and Side Effects:**  
    Any mutation of inputs or internal state is explicitly stated and consistent; side effects are fully described to guarantee the faithful behavior of any implementation derived from the pseudocode.

12. **Tolerance to Non-Impactful Stylistic Variation Only:**  
    Differences in variable, function, or class naming, formatting, or stylistic preferences that do *not* affect completeness or semantic correctness must not cause rejection.

**Critical:** If there exists *any* ambiguity, incompleteness, missing detail, logical gap, or room for divergent faithful implementations that could fail one or more unit tests, output **0**. Only output **1** when you are absolutely certain that *any* faithful, direct implementation derived exactly from the given pseudocode will pass every test case.

---

Output exactly one digit (1 or 0) per pseudocode input, in input order, and nothing else.