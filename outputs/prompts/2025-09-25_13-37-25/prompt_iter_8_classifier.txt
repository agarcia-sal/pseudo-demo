Given a pseudocode description of a complete function or class method intended to solve a programming problem with associated unit tests, your task is to determine if the pseudocode is *fully reproducible* — meaning that any direct implementation derived solely and exactly from the pseudocode will pass **all** valid unit tests without fail.

Output exactly one digit for each pseudocode input:

- Output **1** if and only if the pseudocode guarantees full reproducibility under the criteria below.
- Output **0** otherwise.

To decide, apply the following stringent, comprehensive checklist:

1. **Complete and Explicit Problem Definition:**  
   The pseudocode must fully define or unambiguously imply: input types and domains, output formats and constraints, and all relevant intermediate data structures or states. No crucial problem context is missing or assumed from outside.

2. **Clearly Defined Interface:**  
   The pseudocode includes a complete, self-contained function or method signature with explicit input parameter names and types, return type, and class or function scope, allowing direct and correct code translation without guessing names or interfaces.

3. **Fully Detailed Control Flow and Logic:**  
   All control elements (loops, recursion, conditionals) and data manipulations are precisely described, including exact loop boundaries, initialization steps, increments, recursive base and inductive cases, and termination conditions; no control-flow or logic elements rely on assumptions or gaps.

4. **Exhaustive Handling of Edge, Boundary, and Special Cases:**  
   Every relevant edge or special input scenario dictated by the problem context is addressed explicitly or logically guaranteed by the provided logic. The pseudocode precludes undefined, ambiguous, or unstated behaviors under any valid input.

5. **Unambiguous, Precise Operations and Notation:**  
   All operations (arithmetic, indexing, string manipulations, data structure changes) are specified unambiguously without shorthand, symbolic ambiguity, or vague terminology that requires external interpretation or assumptions beyond the pseudocode.

6. **Absolute Logical Consistency Without Gaps:**  
   No contradictions, omissions, or unclear transitions exist. Every step necessary for correctness is included explicitly—no implicit assumptions, side effects, default values, or external dependencies required.

7. **Complete Structural and Syntactic Readiness for Translation:**  
   The pseudocode’s organization and form allow straightforward, syntax-valid implementation in a standard programming language without needing to invent missing pieces or guess at implicit scaffolding.

8. **Correct Enforcement of All Problem Constraints and Domain Rules:**  
   All problem-specific limits, ranges, invariants, side conditions, and domain rules essential for correctness are enforced as described or guaranteed by the pseudocode.

9. **Total Self-Containment:**  
   The pseudocode is a standalone complete solution; it is not a partial fragment or snippet and does not rely on unstated helpers, external libraries, or omitted functional parts.

10. **Allowance for Logical Stylistic Variation Only:**  
    Differences in variable naming, indentation, formatting, or minor syntactic style do not affect correctness or reproducibility and must not cause rejection.

**Final Decision:**  
If *any* uncertainty, ambiguity, incomplete specification, missing interface details, unclear control flow, omitted edge case, logical inconsistency, dependency on external components, or vagueness exists such that some correct implementation derived from the pseudocode could fail one or more tests, output **0**. Otherwise, output **1**.

Output nothing else, no explanations or comments. Outputs correspond strictly, in order, to the pseudocode inputs fed.

---
*End of prompt.*