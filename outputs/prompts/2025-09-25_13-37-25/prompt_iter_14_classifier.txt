Given a pseudocode input describing a complete function or class method intended to solve a well-defined programming problem, your task is to determine with absolute certainty whether the pseudocode is *fully reproducible*. *Fully reproducible* means that a direct, unambiguous implementation derived solely from this pseudocode, without any external assumptions or interpretation, will pass **all** valid unit tests for the problem without exception.

You must output exactly one digit per pseudocode input:
- Output **1** if and only if the pseudocode fully meets *all* the stringent reproducibility criteria defined below.
- Output **0** otherwise.

To make your decision, carefully and exhaustively validate these ten rigorous criteria:

1. **Complete and Explicit Problem Specification**  
   The pseudocode fully defines or unambiguously implies: input parameters (names, types, and valid domains), expected output (type and format), and any necessary intermediate states or data structures. There are no missing or ambiguous problem constraints.

2. **Clear, Complete Interface Definition**  
   The pseudocode presents a concrete, self-contained function or method signature, including:
   - Function or method name and containing class or module scope if applicable.  
   - All input parameters clearly named and typed.  
   - Return type explicitly or implicitly defined through the return statement(s).  
   This enables straightforward mechanical translation to executable code.

3. **Exhaustive and Precise Algorithmic Logic**  
   The pseudocode explicitly describes all control flows and data operations without gaps or ambiguity, including:  
   - Initialization of all variables.  
   - Complete loop/recursion definitions with clear bounds and termination conditions.  
   - Full conditional logic covering all decision points.  
   - All data manipulations stated precisely (no shorthand or ellipses).  
   - No implicit assumptions about iteration counts or data structure states.

4. **Comprehensive Edge Case & Special Case Handling**  
   The pseudocode explicitly or logically guarantees correct handling of all relevant edge cases and special inputs, including but not limited to: empty inputs, minimal/maximal bounds, repeated elements, unexpected formats, or any cases described by the problem specification.

5. **Unambiguous, Well-Defined Operations**  
   All operations—arithmetic, indexing, string manipulation, data structure methods—are precisely defined and implementable without guesswork. Avoid vague phrasing such as “handle appropriately”, “optimize”, or undefined symbols. Clarify indexing bases (0-based or 1-based), data structure types, and operator precedence.

6. **Logical Consistency and Step Integrity**  
   The pseudocode contains no contradictions, omitted steps, or illogical transitions. All required computations and state updates appear explicitly. The flow is coherent, complete, and internally consistent. No external defaults, environment assumptions, or unstated side effects are required for correctness.

7. **Syntactic and Structural Completeness for Direct Translation**  
   The pseudocode is fully syntactically structured—complete blocks with proper nested indentation or delimiters (e.g., BEGIN/END, indentation, braces)—so it can be directly mapped to valid code without adding code, fixing syntax, or inferring missing parts.

8. **Strict Enforcement of Problem Constraints and Domain Rules**  
   All problem-specified constraints (e.g., range checks, data validation, maximum input sizes) and domain-specific rules (e.g., sorting order, numerical precision) are explicitly enforced in the logic or guaranteed by construction. No violations or ignored constraints.

9. **Total Self-Containment Without External Dependencies**  
   The pseudocode is a standalone solution: it does not rely on unstated helper functions, external libraries, environment state, or partial snippets. Any helper routines used must be explicitly included and fully defined within the given code.

10. **Robustness to Stylistic Variation Without Compromising Clarity**  
    Differences in naming conventions, formatting, minor language idiomatic variations, or notation style that do not affect semantic clarity or logical completeness must not result in rejection. Evaluate meaning, not style.

**Important:**  
If *any* ambiguity, missing element, implicit assumption, incomplete case coverage, unclear interface, or logical gap exists that could cause some direct implementations derived solely from the pseudocode to fail *any* valid unit test, output **0**.  
The decision must tolerate no uncertainty about universal test passing. Partial coverage or “almost always” correctness is insufficient.

**Output Format:**  
After receiving each pseudocode input, output exactly one digit—**only** `1` or `0` —corresponding to reproducible or not reproducible, respectively.  
Output the digits in the same order pseudocodes are given, without spaces, newlines, comments, or additional text.

---
*End of prompt.*