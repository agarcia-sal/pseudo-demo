Given a pseudocode input that fully defines a single function or class method intended to solve a well-defined programming problem, your task is to determine whether the pseudocode is **guaranteed reproducible**—meaning that any direct, faithful implementation derived exclusively and unambiguously from the pseudocode **will pass all valid unit tests associated with the problem without failure or error.**

Your output must be exactly one digit per pseudocode input, in the same order pseudocodes are provided, with no extra text, explanation, or whitespace:

- Output **1** if and only if the pseudocode is reproducible as defined below.  
- Output **0** otherwise.

To decide reproducibility, apply the following **strict criteria**. The pseudocode must satisfy **all** of these conditions **without exception**:

1. **Explicit Problem Definition and Interface**  
   - The pseudocode either explicitly states or unambiguously implies the complete problem context: input types, input constraints, output format, and any invariants or domain rules.  
   - The signature (function or method name, parameter names and types, return type) is fully specified and allows direct translation without assumptions.

2. **Self-Containment and Completeness**  
   - The pseudocode is a complete, independent unit of logic—no missing or implicit helper functions, no unstated dependencies, no reliance on external libraries or environment-specific defaults.  
   - All variables, data structures, and state transformations required are explicitly defined.

3. **Precision and Unambiguity of Operations and Control Flow**  
   - Every computational step and operation (arithmetic, indexing, conditionals, loops, recursion, data mutation) is clearly and concretely described without ambiguity, vague terms, or shorthand that require interpretation.  
   - Control structures include all necessary boundary conditions, initialization, iteration increments/decrements, recursion base and inductive cases without gaps or implicit assumptions.

4. **Comprehensive Edge Case and Error Handling**  
   - Every relevant edge case, special input scenario, or constraint condition dictated by the problem is addressed explicitly or is guaranteed by the logic.  
   - No possible input or execution path leads to undefined, partially defined, or ambiguous states.

5. **Logical Consistency and Soundness**  
   - The pseudocode contains no logical contradictions, no missing essential steps, and no unclear or incomplete transitions.  
   - Results are consistent with problem requirements under all valid inputs.

6. **Structurally Valid and Executable Representation**  
   - The pseudocode’s form and structure enable direct, syntax-valid translation into a standard programming language without guesswork, filling blanks, or adding missing pieces.

7. **Respect for Problem Constraints and Domain Rules**  
   - Any problem-specific limits, invariants, and correctness criteria are enforced or clearly guaranteed by the pseudocode.

8. **Tolerant of Non-Functional Stylistic Variations**  
   - Differences in naming conventions, formatting, or superficial style are allowed if they do not compromise clarity, completeness, or correctness.

**Important:** If **any** uncertainty remains—for example, if the pseudocode:  
- Lacks explicit interface definitions or complete problem context,  
- Omits or ambiguously specifies logic for any input or case,  
- Contains unclear or incomplete control flows,  
- Depends on unspecified steps, helper functions, or external context,  
- Presents operations or data manipulations that could be interpreted in multiple ways, or  
- May produce test failures or runtime errors in some legal implementation derived from it—  
then output **0**.

After careful, exhaustive verification according to the above conditions, emit **only** a single digit (1 or 0) per input pseudocode, in the order received, with no additional text or formatting.