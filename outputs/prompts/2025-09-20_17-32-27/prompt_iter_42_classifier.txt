Evaluate each pseudocode input separately and decide if it is **exactly and fully reproducible** under the meaning below:

- “Fully reproducible” means the pseudocode can be implemented verbatim, with no need for interpretation, assumptions, missing info, or external context, to produce a correct program that will pass **all legitimate unit tests** in the problem domain. This includes tests for normal cases, edge cases, boundary conditions, and error or invalid inputs where applicable.

For each pseudocode input, output a single digit with the following meaning:  
- Output **1** if the pseudocode is explicitly complete, deterministic, unambiguous, logically sound, and self-contained so that a direct implementation will unquestionably pass all valid tests without further detail or correction.  
- Output **0** if any ambiguity, incompleteness, vagueness, missing specification, implicit assumption, or contextual dependency exists that prevents guaranteed full correctness and reliable unit test passing.

---

### Evaluation criteria (all must be satisfied for output 1):

1. **Explicit and Complete Specification**  
   - All variables, inputs, outputs, functions, data structures, constants, and return types are clearly defined or precisely inferable from given information alone, without guessing.  
   - Input/output formats, types, ranges, and structures are fully specified or deterministically derivable from the pseudocode contents.  
   - No reliance on unspecified external libraries, global states, hidden system characteristics, or undeclared functions.

2. **Precisely Defined Logic and Exhaustive Control Flow**  
   - Every step, condition, loop, recursion, and control flow construct includes fully stated boundaries, invariant conditions, exit criteria, and branching to cover all valid scenarios with no gaps or implicit cases.  
   - No infinite loops or undefined halting behaviors.  
   - No vague instructions such as “handle errors,” “process accordingly,” or “update as needed” without explicit code-like detail.

3. **Deterministic and Well-Defined Operations**  
   - Indexing conventions, data mutations, arithmetic, comparisons, and side-effects are fully specified with consistent semantics so the sequence of operations and results are unequivocal.  
   - No ambiguous evaluation orders or unspecified mutations.

4. **Self-Contained and Context-Free**  
   - The entire solution stands independently and does not presuppose domain knowledge, platform-specific behavior, environmental states, or runtime conditions beyond what the pseudocode expresses.  
   - Dependencies or assumptions, if any, must be explicitly stated or inferable solely from the pseudocode.

5. **Complete Coverage of Edge, Boundary, and Error Cases**  
   - The pseudocode either handles all edge and boundary conditions explicitly or clearly makes those cases impossible by stated input constraints.  
   - No scenario leads to silent failures, undefined states, or incorrect behavior for any input in the declared domain.

6. **Logical Consistency and Semantic Coherence**  
   - No contradictions (e.g., use-before-assignment, conflicting conditions, inconsistent data states).  
   - The logic flows coherently toward solving the stated problem without ambiguous or incomplete transitions.

7. **Direct Implementability Without Interpretation or Supplementation**  
   - The pseudocode can be translated one-to-one into executable code without guessing, supplemental assumptions, or added information.  
   - All required initializations, index ranges, iterations, data manipulations, and return steps are fully detailed.

---

### Output format:

- For multiple pseudocode inputs, concatenate the digits (1 or 0) corresponding to each in input order, with no spaces, newlines, or any other characters.  
- Output only this digit string, nothing else.

---

### Judgment rules (internal; do not output):

- Any inferred or assumed missing detail results in output 0.  
- Ambiguous or incomplete edge case coverage results in 0.  
- Any dependency on non-explicit global state, environment, or language/platform behaviors results in 0.  
- Infinite or undefined loops cause 0.  
- Contradictory or logically incoherent steps cause 0.  
- Partial or approximate specification causes 0.  
- Only perfectly explicit, unambiguous, self-contained, and logically sound pseudocode yields 1.

---

**Summary:**  
Output 1 **only if** the pseudocode is a fully self-contained, logically complete, and perfectly explicit program specification ensuring direct implementation will pass **all** valid unit tests without further assumptions or corrections. Otherwise output 0.  

---

**Example outputs:**  
- Single fully reproducible pseudocode → `1`  
- Single incomplete or ambiguous pseudocode → `0`  
- Three inputs where first and third are reproducible, second is not → `101`  

---

**Strictly output only the concatenated string of 1s and 0s.**