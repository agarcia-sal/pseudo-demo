Given one or more pseudocode inputs, determine for each if it is **fully reproducible**, meaning it can be implemented exactly as written to pass **all valid unit tests**—including all edge, boundary, and exceptional cases—with no ambiguity, missing detail, or need for unstated assumptions.

For each pseudocode, output a single digit:

- `1` if it is **unambiguously complete and correct** so that any competent implementation from the pseudocode alone will pass every valid unit test,
- `0` otherwise.

Output the digits concatenated in the order the pseudocodes are provided, with no spaces, newlines, or extra characters.

---

### To judge **full reproducibility**, confirm **all** these conditions strictly hold:

1. **Complete and explicit definitions:**  
   - All variables, constants, data structures, functions, and procedures are fully defined or derivable within the pseudocode.  
   - Input parameters and outputs have clearly specified types, formats, and expected behaviors.  
   - No undefined, partially defined, or ambiguously referenced elements, including no unspecified helper methods or external dependencies.

2. **Precise, deterministic logic and control flow:**  
   - Control structures (loops, conditionals, recursion) have explicitly defined conditions, boundaries, and termination criteria without gaps or contradictions.  
   - Branching logic covers **all possible cases** explicitly; no missing branches or contradictory conditions.  
   - No infinite loops or unreachable code without clear rationale or exit.

3. **Clear, unambiguous operations and state changes:**  
   - All computations, state updates, side effects, and data manipulations are fully specified so the intended implementation is crystal-clear.  
   - Indexing, ordering, and references to collections or elements are explicit and consistent.  
   - No vague or overloaded operators, implicit conversions, or underspecified expressions.

4. **Complete self-containment and no hidden assumptions:**  
   - The entire problem context, environment, and dependencies are fully described within the pseudocode.  
   - No reliance on unstated external libraries, global state, input data beyond parameters, or domain knowledge.  
   - No implicit assumptions about input validity, encoding, or runtime behavior.

5. **Exhaustive edge case and error handling:**  
   - Boundary conditions, empty/minimal inputs, and exceptional or corner cases are either explicitly handled or logically guaranteed by the pseudocode structure to cause no failures.  
   - No undefined behaviors or silent failures for any valid input domain.

6. **Logical consistency and correctness of algorithm:**  
   - Variables and data are never used before assignment or definition.  
   - No semantic contradictions or conflicts in variable states or steps.  
   - Algorithmic steps and data manipulations are coherent, maintaining invariants and correctness throughout.

7. **Syntactic clarity supporting unambiguous interpretation:**  
   - Instructions are structured clearly with consistent naming and unambiguous referencing.  
   - No conflicting or multiple possible readings of the same instruction.

---

### Additional instructions:

- When multiple pseudocodes are provided, treat each independently and output one digit per pseudocode in the exact input order.  
- Output strictly the concatenated digits `1` or `0` with no separators or explanations.  
- Make strict binary judgments: any ambiguity, incomplete specification, missing edge-case handling, or need for assumption reduces reproducibility to `0`.  
- If partial correctness or probable correctness is implied but not guaranteed, output `0`.  
- Assume no external information beyond the pseudocode itself; reject reliance on external standard algorithms or implicit knowledge.

---

**Example outputs:**  
`1`  
`0`  
`101` (for three pseudocodes in input order)

---

This prompt upgrades reproducibility detection by:

- Highlighting **exhaustiveness in edge case and error handling** explicitly, to reduce false negatives on robust pseudocode.  
- Demanding **syntactic clarity and unambiguous referencing**, minimizing acceptance of underspecified code with potentially multiple interpretations.  
- Emphasizing **covering every logical path** with explicit conditions, disallowing any implicit branches or missing cases.  
- Enforcing **strict binary output** with no elaboration or leniency for partial correctness, maximizing precision and reliability of the output.  
- Using clear, precise language that focuses on universal pseudocode properties rather than problem-specific assumptions, ensuring general applicability and robust evaluation.

Use this prompt to assess pseudocode reproducibility effectively, balancing precision and strictness to maximize correct classification and overall performance within the 5-second decision constraint.