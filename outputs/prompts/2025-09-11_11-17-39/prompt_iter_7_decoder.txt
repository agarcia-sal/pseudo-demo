```python
You are given pseudocode describing Python classes, methods, and functions. Translate it into fully functional, efficient, and idiomatic Python 3 code with the following rules:

1. Preserve all original class names, method names, signatures, and the class/object structure exactly as in the pseudocode.
2. For any referenced data structures such as `TreeNode` or `ListNode`, define them with precise Python 3 type hints.
3. Provide robust and clean helper functions for constructing these data structures from standard input formats, e.g., lists representing binary trees or linked lists.
   - Input lists may contain `null` literals (as in JSON) to indicate missing nodes; your code must treat them correctly as Python `None`.
   - The helpers must handle edge cases like empty inputs, singleton inputs, and support typical traversal representations.
4. Implement code that assumes inputs may be raw data structures (e.g., list form) that require conversion before use.
   Your solution must therefore:
   - Detect when input arguments correspond to such inputs (e.g., root = [1,2,null]) and transform them internally.
   - Never assume input arguments are already constructed nodes unless explicitly given as such.
5. Optimize your solution for readability and idiomatic style but also for performance within a 5-second runtime limit.
6. Use only Python standard libraries or widely-used packages available in a typical Python 3 environment.
7. Do not include any explanatory comments outside the code block.
8. Do not print anything or include test cases.
9. Return only the complete, runnable Python code enclosed in a single markdown code block labeled ```python```.

Example:

```python
from typing import Optional, List
from collections import deque

class TreeNode:
    def __init__(self, val: int=0, left: Optional['TreeNode']=None, right: Optional['TreeNode']=None):
        self.val = val
        self.left = left
        self.right = right

def build_tree(nodes: List[Optional[int]]) -> Optional[TreeNode]:
    if not nodes or nodes[0] is None:
        return None
    root = TreeNode(nodes[0])
    queue = deque([root])
    i = 1
    while queue and i < len(nodes):
        node = queue.popleft()
        if i < len(nodes) and nodes[i] is not None:
            node.left = TreeNode(nodes[i])
            queue.append(node.left)
        i += 1
        if i < len(nodes) and nodes[i] is not None:
            node.right = TreeNode(nodes[i])
            queue.append(node.right)
        i += 1
    return root

# Your solution classes/methods follow below, e.g.
# class Solution:
#     def method(self, params):
#         ...

```
```