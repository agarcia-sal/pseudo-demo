```python
You are given pseudocode defining Python classes, methods, and functions that may work with common data structures such as binary trees and linked lists. Translate the pseudocode into fully-functional, efficient, and idiomatic Python 3 code. Follow these strict guidelines:

1. Exactly preserve all class names, method names, signatures, and the specified class/object structure from the pseudocode.

2. Define all referenced standard data structures (e.g., TreeNode, ListNode) with full Python 3 type hints.

3. For each standard data structure used, provide robust, reusable, and clean helper functions to construct these structures from typical input formats:
   - For trees, inputs will be lists with possible JSON-style null literals; treat these as Python None.
   - For linked lists, inputs will be lists that may contain None; treat None as the list terminator if encountered.
   - Your helpers must correctly handle empty lists, single-element lists, and all standard edge cases.
   - Ensure helpers perform thorough input validation and convert raw inputs to node-structured objects before they are used in methods.

4. Methods in solution classes should automatically detect and transform raw input formats (e.g., list inputs representing trees or linked lists) into the appropriate node-structured forms before proceeding.
   - Never assume inputs are pre-constructed node objects; always handle raw inputs gracefully.
   - This conversion step should be transparent to the method logic and maintain interface consistency.

5. Implement your solution for maximum readability, correctness, and idiomatic Python style, while ensuring performant execution within a 5-second runtime constraint.

6. Use only Python standard libraries or broadly available, well-established packages commonly present in Python 3 environments.

7. Include no explanatory comments outside the code block. Inside the code, brief, clear comments clarifying non-trivial logic are allowed.

8. Do NOT include any test code, input/output code, or print statements.

9. Return only the complete, runnable Python code, enclosed within a single markdown Python code block.

Example outline you must strongly consider following (adjusted to be robust and correct):

```python
from typing import Optional, List, Union
from collections import deque

class TreeNode:
    def __init__(self, val: int = 0, left: Optional['TreeNode'] = None, right: Optional['TreeNode'] = None):
        self.val = val
        self.left = left
        self.right = right

def build_tree(nodes: List[Union[int, None]]) -> Optional[TreeNode]:
    if not nodes or nodes[0] is None:
        return None
    root = TreeNode(nodes[0])
    queue = deque([root])
    i = 1
    n = len(nodes)
    while queue and i < n:
        node = queue.popleft()
        if i < n:
            left_val = nodes[i]
            if left_val is not None:
                node.left = TreeNode(left_val)
                queue.append(node.left)
            i += 1
        if i < n:
            right_val = nodes[i]
            if right_val is not None:
                node.right = TreeNode(right_val)
                queue.append(node.right)
            i += 1
    return root

class ListNode:
    def __init__(self, val: int=0, next: Optional['ListNode']=None):
        self.val = val
        self.next = next

def build_linked_list(values: List[Union[int, None]]) -> Optional[ListNode]:
    if not values:
        return None
    dummy = ListNode()
    current = dummy
    for v in values:
        if v is None:
            break
        current.next = ListNode(v)
        current = current.next
    return dummy.next

# In all solution methods:
# - If inputs are raw lists representing nodes, immediately convert them with these helpers.
# - Then implement the algorithm logic strictly on node objects.
# - Do not print anything, no test cases, no extra explanations outside code.
```
```