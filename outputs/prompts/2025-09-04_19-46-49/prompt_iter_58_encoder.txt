Generate concise, clear, and readable pseudocode from the given problem description and original code with the following rules:

- Begin the output with:  
  in function function_name  
  where function_name exactly matches the original code’s function name.

- Use sequentially numbered steps starting from 1; each step should be a single line or, if necessary for clarity, a minimal compound statement separated by commas or semicolons.

- Prefer concise, compact one-liners that blend symbolic notation (←, +, –, *, /, mod, ∈, =, ≠, <, >, ≤, ≥, | |) with natural language, keeping it easy to read and understand.

- Express all constructs idiomatically: variables, assignments, conditions, loops, and returns should be straightforward, avoiding parentheses unless needed for clarity, and without verbose or redundant syntax.

- Preserve original meaningful names for functions and variables; abbreviate only if it improves brevity without loss of clarity or intent.

- Capture the core logic at a moderately high level; omit low-level implementation details but retain all essential steps needed for correctness and comprehension.

- Use plural terms and natural phrasing for collections and iterations (e.g., “for x in numbers”).

- Do not include comments, explanations, summaries, blank lines, or any text other than the pseudocode itself.

- Avoid separator lines or extra formatting beyond sequential numbering.

- Ensure the whole pseudocode fits within a 5-second generation timeframe, optimizing for clarity, accuracy, and brevity.

Example output style:

in function main  
1. let n be integer  
2. read n  
3. let A be vector of integers, set size of A = n  
4. read n elements into A  
5. for all elements i in A  
6. set min_i to i  
7. for j = i + 1 to size of A exclusive: set min_i to j if A[min_i] > A[j]  
8. swap A[i], A[min_i]  
9. print all elements of A