Given the original pseudocode, produce an entirely restructured and lexically transformed equivalent version that preserves every aspect of the original semantics, behavior, inputs, outputs, side effects, and control flow logic exactly, while maximizing syntactic and structural divergence. Your rewritten pseudocode must adhere strictly to these rules:

1. Output **only** the transformed pseudocode—no comments, explanations, preambles, or annotations of any kind.

2. Keep **all class and function names identical**, preserving their full scoping, nesting, and signature (parameters and return types) without modification or omission. The class and function hierarchy must remain exactly as in the input.

3. Otherwise, perform **unrestricted, aggressive variations** including but not limited to:

 - Convert between all looping constructs (e.g., `for`, `while`, `repeat-until`), in any direction or indexing scheme, as long as iteration semantics are preserved.

 - Rename all variables, loop indices, and temporary identifiers freely and consistently, except class and function names.

 - Reorganize and rewrite expressions extensively by applying algebraic/logical equivalences, condition inversion, De Morgan’s laws, reordering operands where associative/commutative, distributing or factoring logic, restructuring boolean expressions, and equivalent arithmetic transformations.

 - Transform any conditional structures arbitrarily among `if`, `if-else`, nested `if`s, `switch-case`, `conditional expressions`, guards, or early returns, as long as logic stays identical.

 - Rearrange independent statements or combine/split sequential statements without altering program effects or data flow.

 - Change data structure indexing styles (e.g., zero-based to one-based, or vice versa), consistent with code logic, including ranges and slices.

 - Rewrite all literals, constants, numeric expressions, and index calculations using equivalent expressions (e.g., replacing `x + 1` with `1 + x`, or `(n - 1)` with `(n + (-1))`).

 - Swap assignment statement styles freely (e.g., compound assignments, separate declarations and assignments) as long as semantics remain identical.

 - Utilize alternative data access methods or container operations that preserve functionality.

4. Do **not** add or remove any classes or functions; do **not** change method signatures, class structures, or interfaces; disallow adding or removing any functionality.

5. Maintain the precise input/output contract, side effects, and data flow as in the original pseudocode.

6. Formatting should only reflect structural and syntactic transformations relevant to logic changes — do not apply extraneous stylistic or whitespace-only formatting changes unrelated to structural/semantic transformation.

Your output must be a valid and executable pseudocode that is functionally indistinguishable from the original but shows maximal diversity in syntax, structure, and lexical content within the constraints above.