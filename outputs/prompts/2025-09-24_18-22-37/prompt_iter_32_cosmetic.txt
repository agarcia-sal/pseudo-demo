Rewrite the given pseudocode into a brand-new version that preserves *exactly* the original semantics—including all outputs, side effects, behaviors, and control flow outcomes for every valid input—while maximizing lexical, syntactic, structural, and stylistic divergence. Your task is to generate pseudocode that looks radically different but is fully equivalent.

Strict constraints and mandatory transformations:

1. **Do not rename or restructure any functions, methods, classes, or interfaces.** Preserve all names, signatures, inheritance, and class/object hierarchies exactly as in the original.

2. **Rename all local variables and parameters consistently to fresh, unrelated identifiers everywhere they appear.** Do not touch any global variables, constants, or identifiers outside the function/local scope.

3. **Rebuild all control flows by applying any and multiple of these transformations as appropriate, ensuring semantic identity:**
   - Convert FOR loops ↔ WHILE loops arbitrarily.
   - Rewrite IF-ELSE chains into SWITCH-CASE or nested guards, and vice versa.
   - Flatten nested conditionals or create nesting to invert the original structure.
   - Shuffle or reorder independent conditional branches or loops.
   - Rewrite multiple return points as single consolidated exit or convert single returns to early returns.
   - Implement guarding conditions, guard clauses, or boolean negations to reorganize logical tests.

4. **Rearrange independent statements, expressions, and computations whenever data dependencies allow, to create new execution paths or orderings without affecting outcomes.**

5. **Transform all expressions thoroughly:**
   - Break down compound expressions into multiple intermediate assignments or merge simple sequential assignments into compound expressions.
   - Replace operators with logically equivalent synonyms (e.g., `!=` ↔ `not equal to`; logical AND `∧` ↔ explicit conjunction; array access via indices ↔ explicit `.at()` methods or alternative allowed syntax).
   - Vary numeric literal representations by expanding, factoring, or converting between hexadecimal, decimal, arithmetic operations, or constants without changing value.

6. **Traverse data structures in varied ways wherever possible:**
   - Convert index-based iteration into element-based iteration, and vice versa.
   - Reverse iteration directions or choose randomized traversal orders when it does not alter results.
   - Reorder accesses to data structures respecting data and semantic dependencies.

7. **Introduce new helper or temporary variables and intermediate data structures as needed to maximize structural differences while avoiding ambiguity or inconsistent reuse.**

8. **Randomize formatting aggressively: combine or split lines, vary indentation and whitespace, introduce blank lines, and reorder grouping constructs freely—always preserving valid pseudocode syntax.**

9. **Do not apply any semantic simplifications, algorithmic shortcuts, or built-in/lib shortcuts that shortcut explicit operations, reduce stepwise computations, or change complexity or behavior.**

Output constraints:

- The output must be *only* the rewritten pseudocode, exactly as valid pseudocode text. No explanations, comments, delimiters, metadata, or additional text.
- Preserve all function and class names, including their hierarchical and object structural positions, unchanged.
- Guarantee that the transformed pseudocode is semantically identical for every valid input and matches the original’s outputs and side effects exactly.

Your goal is to generate a rewritten pseudocode version that achieves maximal semantic fidelity together with maximal structural, lexical, syntactic, and stylistic novelty compared to the input pseudocode, ensuring robustness and correctness in strict testing environments. Output only the transformed pseudocode itself.