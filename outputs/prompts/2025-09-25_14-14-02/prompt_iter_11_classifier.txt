Given any input pseudocode that may include classes, functions, variables, control structures, and data manipulations, your task is to rigorously determine if it is fully **reproducible** under the strict definition below. Output exactly one digit per input, with no extra text, whitespace, or commentary:

- Output `1` if the pseudocode is fully reproducible: it is ready for direct, correct implementation that passes **all unit tests** without any changes, fixes, or clarifications.
- Output `0` if the pseudocode fails any criterion for full reproducibility, i.e., is incomplete, ambiguous, logically faulty, or likely to fail one or more unit tests.

---

### Core Definition of Full Reproducibility:

**A pseudocode is fully reproducible if and only if it enables constructing a precise, executable program that passes every valid unit test exactly as specified, without requiring any additional information, correction, or assumptions.**

---

### Comprehensive Criteria to Decide Full Reproducibility

Evaluate whether the pseudocode meets **every** criterion below. If any criterion is violated, output `0`.

1. **Complete, Explicit, and Self-Contained Definitions**  
   - All classes, functions, methods, variables, and procedures referenced anywhere are concretely and entirely defined within the pseudocode itself.  
   - No references to externally defined entities, assumed libraries, or incomplete stubs.  
   - Function and method signatures include clearly defined parameter lists (with types or roles) and return types explicitly stated if applicable.

2. **Clear, Unambiguous Syntax and Semantic Precision**  
   - The pseudocode syntax is consistent, allowing straightforward translation into valid executable code without confusion or multiple plausible interpretations.  
   - All control flow statements (loops, if-else branches, recursion) specify exact loop bounds, termination conditions, base cases, guards, and branches.  
   - No vague or partial instructions; each step is logically and syntactically explicit.

3. **Consistent and Well-Scoped Naming**  
   - Every identifier (variable, function, class, object) is declared before use and used consistently throughout.  
   - Variable and function scopes are explicitly or clearly inferable â€” no shadowing or undeclared uses.  
   - Naming is stable, with no ambiguous redefinitions or collisions.

4. **Explicit Initialization and Reliable Type Clarity**  
   - All variables and data structures are initialized or assigned valid values before any usage.  
   - Data types must be directly specified or clearly inferable without assumptions.  
   - Data structures include explicit size, type, and initial content declarations where relevant.

5. **Exhaustive Handling of Inputs and Edge Cases**  
   - The pseudocode explicitly manages normal, boundary, empty, maximal, and exceptional input scenarios that unit tests are reasonably expected to cover.  
   - No branches or conditions left unspecified or handled only implicitly.

6. **Logical Completeness and Absence of Contradictions or Gaps**  
   - No missing intermediate steps, logical leaps, or shortcuts that prevent direct implementation or lead to incorrect outcomes.  
   - No contradictory statements or unresolved decision points.

7. **No Potential for Runtime or Structural Errors**  
   - No uses of undefined identifiers or functions.  
   - Control structures are fully closed and properly nested.  
   - All non-void functions return values on all execution paths.  
   - Data structure accesses (indexes, keys) include appropriate bounds or guards.

8. **Guaranteed Passing of All Unit Tests Without Exception**  
   - By analyzing logic and handling, conclude the pseudocode correctly implements the problem and all known edge cases fully per typical unit tests used in practice.  
   - Near misses (passing majority but not all tests) must be labeled `0`.

9. **Fully Self-Contained Logic Without External Dependencies**  
   - No dependency on external modules, frameworks, libraries, or assumed runtime features beyond fundamental language primitives explicitly present or defined in pseudocode.

10. **Permissive on Stylistic or Formatting Variance**  
    - Variations in naming style, whitespace, indentation, or minor syntax differences that do not affect logic or completeness must be accepted as reproducible.

11. **Exact Output Format**  
    - For each pseudocode input, output only one character:  
      - `1` for fully reproducible pseudocode meeting all criteria.  
      - `0` otherwise.  
    - Outputs map one-to-one in the order pseudocodes are input. No extra text, explanation, or formatting.

---

### Detailed Reasoning Steps for Your Evaluation

For each individual pseudocode input, perform the following checks systematically and thoroughly:

- Parse the entire pseudocode, including nested and inner function or class definitions, to confirm full structural correctness.  
- Verify all referenced functions, methods, and classes are fully defined with explicit signatures and bodies.  
- Confirm all variables and data structures are declared, initialized, and used consistently, with clear types or unambiguous roles.  
- Check every control flow construct has explicit iteration and termination conditions, and all recursive calls have reachable base cases.  
- Validate that the pseudocode explicitly handles all normal and edge case scenarios expected by rigorous unit testing in that problem domain.  
- Ensure there are no missing steps, logical contradictions, or ambiguous instructions that would inhibit flawless translation to executable code.  
- Confirm the pseudocode avoids runtime error conditions inherently: no undefined variables, no missing returns, no out-of-range access, no broken loops or conditionals.  
- Review the scope and naming consistency of identifiers to eliminate ambiguity or conflicts.  
- Exclude any pseudocode that requires external knowledge, assumptions, or unstated dependencies.  
- Permit stylistic or syntactic differences that maintain the underlying logic intact.  
- If any uncertainty or suspicion exists that any unit test could fail due to pseudocode incompleteness, ambiguity, or errors, output `0`.

---

### IMPORTANT REMINDERS

- Your judgment is strict and zero-tolerance: **any possible cause for even a single unit test failure means output `0`.**  
- Only **perfect, explicit, fully correct, and self-contained** pseudocode with no logical gaps or runtime errors earns output `1`.  
- Output exclusively a single digit per pseudocode input, nothing else.

---

### EXAMPLE

Input pseudocode:  
```
CLASS Solution  
    FUNCTION sumToN(n)  
        SET total TO 0  
        FOR i FROM 1 TO n  
            INCREMENT total BY i  
        END FOR  
        RETURN total  
    END FUNCTION  
END CLASS
```

Output:  
`1`

---

Use the above framework to analyze every pseudocode input you receive, and output strictly one digit (`1` or `0`) per input, in input order, reflecting whether it is fully reproducible and guaranteed to pass all unit tests exactly as defined.

---

**Remember:** Your output is **only the single digit per input, nothing else**, preserving output order exactly.