Given an input pseudocode, output **exactly one integer per input**—`1` if it is fully reproducible, and `0` otherwise. Output **nothing else**, no whitespace, punctuation, or explanations. The output order corresponds exactly to the input order.

---

## Task: Determine if the pseudocode is **fully reproducible**, i.e., the pseudocode contains a *complete, precise, unambiguous, and implementable* specification that—without need for external assumptions, modifications, or additional definitions—can be translated directly into working code that will pass **all unit tests** (including all edge cases) with no runtime errors or logic faults.

---

## Your evaluation MUST rigorously check ALL of the following:

### 1. Full and Explicit Definition
- **Every function, method, procedure, class, or module invoked or referenced is fully and explicitly defined within the pseudocode.**  
- No reliance on external libraries, implicit standard functions, or missing helper routines is allowed.  
- Return types, argument types (if any), and function signatures must be stated clearly or inferable without ambiguity.

### 2. Identifiers and Naming Consistency
- All variable, function, and data structure names must be explicitly declared or introduced before use.  
- Identifiers used in control flow, assignments, returns, or expressions must exactly match their definitions (no undefined or misspelled names).  
- Naming consistency must be maintained throughout the pseudocode.

### 3. Initialization and Variable Scope
- All variables must be initialized (assigned a starting value) prior to use; no usage of uninitialized variables.  
- Variable types and scopes must be clear or deterministically inferable, with no ambiguous or conflicting scoping rules.

### 4. Complete and Unambiguous Control Flow
- All loops, branches, and conditionals have well-defined and explicit start/end conditions, loop bounds, and coverage of all cases (including else/default branches).  
- Recursive functions must have clearly specified base cases and recursive progression ensuring termination.  
- No partial, implicit, or underspecified control flow paths are allowed.

### 5. Comprehensive Data Structure Specification
- All data structures used must have explicit type definitions (e.g., array, list, map, set), sizes/dimensions (if applicable), and initialization states.  
- All operations (insert, remove, access, update) on data structures must be explicitly described with clear indexing or key specifications.

### 6. Exhaustive Handling of Edge and Corner Cases
- Explicit handling of all edge cases, including minimum/maximum input sizes, empty inputs, boundary values, special values (e.g., zero, null), and exceptional inputs is required.  
- Functions must have clearly specified return values for all inputs and termination conditions.

### 7. Logical Consistency and Completeness
- No contradictory instructions or mutually exclusive operations within the same scope.  
- Every step and transformation must have a clear, justified purpose.  
- No omitted intermediate steps essential for correctness.

### 8. Zero Ambiguity or Runtime Risk
- The pseudocode must contain zero errors that could cause runtime errors if implemented as-is, such as:  
  - Using undefined variables or functions  
  - Out-of-bounds indexing or invalid key lookups without proper checks  
  - Missing or inconsistent return statements  
  - Invalid or mismatched function calls/signatures  
  - Incomplete or missing control flow branches

### 9. Fully Robust Behavior Under All Valid Inputs
- The pseudocode specification must be sufficiently complete to pass **all unit tests**, including comprehensive and stress tests, without modifications or fixes.

### 10. Self-Containment and Internal Coherence
- The pseudocode forms a fully self-contained implementation.  
- All internal components and calls coherently interoperate.  
- No implicit dependencies, assumptions, or external context required.

### 11. Minor Stylistic Variations Allowed
- Variations in naming conventions, formatting, or stylistic preferences do **not** disqualify reproducibility, provided the logic remains crystal clear and unambiguous.

### 12. Strict 100% Passing Criterion
- If the pseudocode would fail **any single unit test case or trigger any runtime error**, output `0`. Partial success is not enough.

---

## Additional Criteria for Multi-Function/Class Pseudocode:
- The main function/class to be tested **must be clearly identifiable**.  
- Helper functions or nested functions must be fully integrated and defined.  
- Interfaces, inputs, and outputs must be well specified.

---

## Instructions for Your Judgment:

1. Thoroughly analyze the entire pseudocode snippet from start to finish.  
2. Verify conformance with **all** the criteria above.  
3. Decide if the pseudocode, as-is, is guaranteed to be translated into **correct, fully working code passing every unit test** (including edge cases).  
4. Output `1` if yes, otherwise `0`.

---

## Important:

- **Output exactly one integer per pseudocode input — `1` or `0` only.**  
- **No additional text, explanation, formatting, or whitespace.**  
- The order of output corresponds exactly to the order pseudocodes are fed.  
- Maintain a zero-tolerance approach: any implied, missing, or ambiguous elements that might cause failure to pass all tests must result in `0`.  
- Do *not* be lenient for near misses or partial correctness.

---

## Example:

Input pseudocode:  
```
CLASS Solution
    FUNCTION sumToN(n)
        SET total TO 0
        FOR i FROM 1 TO n
            INCREMENT total BY i
        END FOR
        RETURN total
    END FUNCTION
END CLASS
```

Output:  
`1`

---

Apply this exhaustive, precision-driven evaluation to confidently discriminate truly reproducible pseudocode from those that are incomplete, ambiguous, or error-prone.

---

**REMEMBER: ONLY output `1` or `0`. NOTHING ELSE.**