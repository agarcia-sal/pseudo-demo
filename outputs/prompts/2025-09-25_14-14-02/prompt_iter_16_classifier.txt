Given an input of arbitrary pseudocode—potentially containing any combination of classes, functions, methods, variables, control flows, data structures, and nested constructs—your task is to decide **with absolute certainty** whether the pseudocode is **directly reproducible** into a fully functioning program that will pass **every possible unit test** *without any modification, addition, or correction*.

---

### Definitions and Core Requirements:

**Directly reproducible** means: The pseudocode can be implemented *exactly as given*, as a complete, unambiguous, and logically flawless program that passes all unit tests in any standard testing framework for the described problem.

---

### Your output instructions:

- For *each* pseudocode input, output exactly a single digit:
  - `1` if it **meets all reproducibility criteria** strictly.
  - `0` otherwise.
- No additional text, spaces, newlines, or punctuation.
- Preserve the input order; one digit output per input, line-by-line or sequence order.
- No explanations or comments in output.

---

### Rigorous and Exhaustive Criteria for Judging Reproducibility:

1. **Complete, Explicit, Self-Contained Definitions**  
   - All entities (classes, functions, methods, types, variables, procedures) that are mentioned anywhere must be defined fully and explicitly within the pseudocode.  
   - No references to external code, undefined helper functions, or assumptions of built-in functions unless explicitly specified or trivially standard language primitives.  
   - Function and method signatures must be complete, specifying: parameter names, types (or clear roles), return types, and all relevant details for unambiguous implementation.

2. **Unambiguous Syntax and Semantics**  
   - The pseudocode structure must be sufficiently well-defined to convert straightforwardly into syntactically valid, executable code in a typical programming language (e.g., Python, Java, C++).  
   - Control structures (loops, conditionals, recursion) must specify clear starting and ending points, iteration counts or conditions, all branches fully detailed, and no implicit or ambiguous behavior.  
   - Recursive procedures must include clear, reachable base cases.

3. **Consistent and Complete Naming and Scoping**  
   - Every identifier (variable, function, class, object) must be declared before use, with no ambiguous or inconsistent naming.  
   - Variable scope must be clearly inferable from context; no implicit, hidden, or global state assumptions that are undefined.

4. **Fully Specified and Initialized Data**  
   - All variables and data structures must be explicitly initialized before use.  
   - Data types—explicit, implied but unambiguous, or clear from context—must be consistent and not contradict themselves.  
   - Data structures’ size, content, initial values, and operations must be transparent and fully defined.

5. **Exhaustive Handling of Inputs and Edge Cases**  
   - The pseudocode must explicitly handle all plausible input cases, including empty inputs, boundary cases, minimal and maximal values, unusual or pathological inputs as expected per typical unit tests.  
   - No partial, incomplete, or implicit handling of exceptional or edge conditions allowed.

6. **Logical Completeness and Soundness**  
   - The pseudocode must lack contradictions, logical gaps, or omissions in control flow or computation steps.  
   - Every computational step, assignment, and operation needed to produce correct output must be present and well-defined without shortcuts or assumptions.

7. **Error-Free Runtime Behavior and Structural Integrity**  
   - No use of undefined or uninitialized variables or procedures.  
   - All functions with return types must have guaranteed, properly located return statements.  
   - Data access operations must be guaranteed safe (e.g., no ambiguous out-of-bound indexing without explicit guards).  
   - Syntax of all control structures must be complete and properly nested (no unclosed loops or conditionals).  
   - All declared function and method signatures must be used consistently.

8. **Full Robustness to Pass *All* Unit Tests**  
   - The pseudocode must be robust and accurate enough to pass all conceivable unit tests designed for its problem domain — not just the majority, but every single one.  
   - Near-complete or “almost there” solutions that fail any unit test, or rely on test-case-specific quirks, should be labeled `0`.

9. **Self-Contained Implementation With No External Dependencies**  
   - All logic, steps, and components must be internally defined or clearly derivable from the pseudocode itself.  
   - No assumed external libraries, modules, or system-specific dependencies beyond basic language primitives.

10. **Permissible Stylistic Flexibility**  
    - Differences in naming style, indentation, or minor syntax variants that don’t affect the semantics or completeness should **not** cause rejection.  
    - Emphasis is on logical correctness, completeness, and clarity, *not* style.

11. **Strict Zero-Tolerance Judgement**  
    - If *any* ambiguity, omission, or error exists that might cause failure of even a single unit test, output `0`.  
    - Output `1` only for fully explicit, correct, and exhaustive pseudocode implementations with no conceivable defects.

---

### Your Evaluation Procedure (Mentally or Programmatically):

- Parse pseudocode globally and fully, including nested definitions and structures.  
- Verify all definitions and signatures are complete and explicit.  
- Confirm that every identifier is declared before use and scopes are clear.  
- Check that variables and data structures are initialized explicitly and used consistently.  
- Analyze every control flow branch, loop, and recursion for complete specification and correctness.  
- Confirm all usual and edge input cases (e.g., empty inputs, zero-length, maximum sizes) are explicitly handled.  
- Look for contradictions, missing steps, or illogical instructions that prevent direct implementation.  
- Confirm no runtime errors or undefined behavior possible from the pseudocode.  
- Judge whether this pseudocode would unambiguously pass every unit test without corrections.  
- Allow stylistic or formatting differences only if they do not obscure meaning or completeness.  
- If any uncertainty remains about possible test failures, output `0`.

---

### Illustrative Examples:

**Example 1 (Reproducible, outputs 1):**

```
CLASS Solution
    FUNCTION sumToN(n)
        SET total TO 0
        FOR i FROM 1 TO n
            INCREMENT total BY i
        END FOR
        RETURN total
    END FUNCTION
END CLASS
```

Output:  
`1`

**Example 2 (Missing base case in recursion → outputs 0):**

```
FUNCTION factorial(n)
    IF n = 0 THEN
        RETURN 1
    ELSE
        RETURN n * factorial(n - 1)
    END IF
END FUNCTION
```

Output:  
`0`  (if base case or edge condition missing or ambiguous)

---

### IMPORTANT REMINDERS:

- Your judgment must be deterministic and strict, with no false positives.  
- You only output `1` or `0` per pseudocode input, nothing else.  
- Order matters; output must correspond one-to-one to input pseudocode order.  
- Consider rigorously *all* aspects of code completeness, correctness, and robustness, not just syntax or superficial checks.

---

Use these instructions to provide **the most precise and reliable classification of pseudocode reproducibility possible**. Only `1` for guaranteed fully reproducible pseudocode, `0` otherwise.