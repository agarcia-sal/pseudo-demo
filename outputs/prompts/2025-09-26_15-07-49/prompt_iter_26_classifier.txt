Given a pseudocode snippet intended as a full, self-contained solution implementing a specified interface, determine—*with absolute certainty and without guesswork*—whether the pseudocode is fully **reproducible**. Here, **reproducible** strictly means the pseudocode is sufficiently and precisely defined to be directly translated into correct, executable code that will **pass all valid unit tests** for its described problem, *without modifications or assumptions*.

To decide, perform a comprehensive and criterion-driven audit of the pseudocode against the following pillars:

---

**1. Exact Interface and Structural Integrity**  
- Confirm the presence of all classes, functions, and methods exactly as required by the problem interface, including exact names, parameter lists, and expected return formats.  
- Verify a uniquely identifiable and properly scoped entry point method matching the interface specification.  
- Check that all variables, parameters, and data identifiers are declared or introduced explicitly before use, with no name clashes or undeclared symbols.  

**2. Fully Specified, Unambiguous Logic Flow**  
- Every computational step (assignments, control structures such as loops and conditionals, recursion, returns) must be clearly and deterministically detailed.  
- Confirm all branches—even edge and exceptional cases—are handled explicitly or are clearly and rigorously accounted for within the pseudocode.  
- Ensure loop and recursion termination conditions are evident, to guarantee no infinite cycles or ambiguous halting behavior.  
- Detect any unreachable code, contradictory statements, or implicit assumptions that could affect correctness.  

**3. Well-Defined Data Structures and Access Patterns**  
- Confirm that all data structures (arrays, lists, dictionaries, stacks, queues, sets, etc.) are precisely described with types, sizes, and indexing conventions clearly declared or unambiguously inferable.  
- Every data access and mutation must be within valid bounds, using consistent indexing bases (0-based or 1-based) aligned with described conventions.  
- Track initialization and mutation of data to ensure no use of uninitialized variables, hidden states, or side effects unexplained or unmanageable in a direct implementation.  

**4. Clear Syntax and Conventional Semantics**  
- Pseudocode syntax must align with well-understood programming constructs and idioms readily translatable to a real programming language.  
- Operators, function calls, control flow constructs, and data operations should be non-ambiguous, avoiding invented notation or shorthand requiring subjective interpretation.  
- Naming and code style must be internally consistent to avoid confusion or errors during translation.  

**5. Exact Parameter and Return Matching for Test Compatibility**  
- The signature of the public interface (class/method/function names and parameters) must exactly match what test harnesses expect, with proper types and order.  
- All helper or internal methods called must be present and accessible as defined within scope.  

---

Output a **single digit only** with no spaces, explanation, or extra text:

- Output `1` if and only if *every* one of the above criteria is fully met without exception or ambiguity, guaranteeing that the pseudocode is *directly and reliably* convertible into an implementation passing **all valid unit tests**.  
- Output `0` if *any* one criterion fails, if there is any missing detail, ambiguity, naming mismatch, undefined behavior, or anything that prevents guaranteed reproducibility or test success.  

Process the pseudocodes *in the input order* and output the corresponding sequence of digits (one per pseudocode), preserving this order exactly.

```
<PSEUDOCODE HERE>
```