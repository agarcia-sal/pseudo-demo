Rewrite the provided pseudocode to produce a functionally and semantically equivalent variant that preserves **exactly the same behavior, side effects, input-output relations, and termination properties**.

**Required invariants**:

- **All original function names, class names, and the entire class/object/nesting/inheritance hierarchy (with precise spelling and casing) must remain absolutely unchanged and retain their exact structural locations.**

- The output must be **only valid, standalone pseudocode** representing a complete, runnable algorithmic description; no explanations, comments, or any extra text may be included.

**Transformations and rewriting requirements – maximize syntactic and structural difference while maintaining semantic fidelity:**

- Rename **all variables, parameters, constants, and temporary identifiers** to new, semantically neutral, unrelated names, avoiding any shadowing or collisions, consistently within their scopes.

- Re-express control flows extensively and creatively, including but not limited to:

  - Transform loops (for, while) into recursion, tail recursion, comprehensions, or functional pipelines (map/filter/reduce), and vice versa.

  - Replace if-else chains with switch/case constructs, nested conditions, guarded expressions, conditional expressions, logically equivalent boolean expressions (e.g., via De Morgan’s laws, converse or contrapositive).

  - Restructure conditionals and branching logic to equivalent but differently nested or flattened forms.

- Replace data structures with equally valid alternatives preserving semantics (e.g., lists ↔ arrays ↔ sets, linked nodes ↔ index-based structures) without altering behavior.

- Refactor code by splitting, merging, reordering independent statements/blocks, or restructuring method calls to equivalent patterns.

- Substitute arithmetic and logical expressions with algebraically/logically identical but differently composed expressions (e.g., `a + b` → `b + a`, negate conditions in alternative ways, fold constants differently).

- Aggressively vary formatting: indentation styles, line breaks, grouping, spacing, statement order when semantics allow.

- For recursive routines with risk of deep recursion, replace or transform into equivalent iteration or tail recursion to avoid overflow without changing behavior.

- Remove unreachable or redundant code only if guaranteed semantics remain identical externally.

**Firm prohibitions:**

- No change to function or class identifiers or their structural hierarchy beyond renaming variables inside.

- No introduction of language-specific or external libraries/features beyond those inferred by the original pseudocode’s paradigm.

- No inclusion of comments, explanations, or auxiliary text; deliver only the rewritten pseudocode.

Your goal is to maximize orthogonality and novelty of the rewritten code’s surface form compared to the input pseudocode, while perfectly preserving every semantic and correctness guarantee.

Produce only the rewritten, self-contained pseudocode reflecting the above requirements.