Rewrite the given pseudocode to produce a functionally equivalent and rigorously semantically identical version that adheres to all the following strict rules:

1. Preserve **every original behavior exactly**: this includes all input-output relations, side-effects, termination guarantees, exception/failure behaviors, and correctness without any deviation.

2. Retain **all original function names, class names, and exactly the same class/object nesting and inheritance hierarchies** unchanged in both spelling and capitalization. No changes to any top-level or nested scopes, modules, or structural declarations.

3. Output **only valid, fully self-contained pseudocode for the rewritten program**, with no explanations, comments, notes, or extraneous text.

4. Replace **all local identifiers** (variables, parameters, constants, temporaries, loop indices, auxiliary names) with freshly generated semantically neutral names. These new names must be consistent, unique within their scopes, and must never collide with any existing names or keywords.

5. Maximize structural, syntactic, and stylistic difference from the original pseudocode by combining many transformations from the list below—apply them exhaustively and creatively (where each transformation strictly preserves semantics and correctness):

   - Convert all loops to equivalent recursion (including tail recursion where feasible), iterator pipelines, comprehensions, or alternative control constructs; alternatively, convert recursive calls into iterative loops.

   - Extensively restructure conditionals by transforming if-else chains into switch/case statements, nested guards, ternary expressions, logical equivalences using Boolean algebra (De Morgan’s laws, distribution, factoring), or equivalent rewritten branches.

   - Introduce logically equivalent but syntactically different arithmetic and boolean expressions by changing evaluation order, factoring, applying distributive laws, constant folding/unfolding, or rewriting modulo/divisions exactly equivalently.

   - Employ alternative but semantically equivalent data structure representations such as arrays vs. lists vs. sets, linked vs. indexed collections, flattening or nesting collections differently, preserving all data semantics.

   - Arbitrarily reorder, merge, or split code blocks or statements wherever behavior and control flow remain strictly unaltered.

   - Aggressively diversify formatting: vary indentation styles, line breaks, spacing, statement ordering, block delimiters, or explicit flow control statements (like gotos or labeled breaks) where allowed.

   - Ensure all recursive procedures that could cause excessive call depth are replaced with tail-recursive or iterative implementations to avoid non-terminating recursion or stack overflows without changing semantics.

6. Do **not** add any new functionality or features beyond the original pseudocode’s expressive domain or concepts; do not remove any reachable or meaningful code unless it is truly redundant or provably unreachable and its removal preserves exact external behavior.

7. Fully preserve all identifiers used for functions, classes, and their hierarchical containment exactly; only rename uncovered locals and inner scopes.

8. Output must be precisely the transformed pseudocode program alone, without any additional text before or after.

9. Apply renaming, control-flow restructuring, and expression rewriting in a combined, maximal, and deliberate fashion to achieve the greatest possible orthogonality and novelty from the original, while guaranteeing absolutely no semantic divergence or correctness compromise.

Your response format must be:

```
<transformed pseudocode here>
```

and nothing else.

This prompt aims to produce transformed pseudocode variants that score maximally on correctness, test pass rates, and semantic equivalence while drastically minimizing superficial resemblance to the original source code.