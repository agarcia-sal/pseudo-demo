{
  "prompt": "```python\n\"\"\"\nYou are given a piece of pseudocode describing one or more functions and/or classes.\nTranslate the entire pseudocode faithfully into fully working Python code according to these requirements:\n\n- Preserve EXACTLY all function names, parameter names, class names, method names, and their structure.\n- Keep class and object hierarchies identical to the pseudocode, with no renaming or restructuring.\n- Provide precise Python type hints for all parameters and return types, inferred logically.\n- Include all necessary imports *at the top* of the code block to ensure correctness and efficiency. Use only standard libraries or well-established, widely used packages if they meaningfully improve clarity, performance, or correctness.\n- Handle all edge, boundary, or implicit cases robustly, preserving clarity without excess complexity.\n- Write clean, idiomatic, and efficient Python code using language features suited to the task (e.g., comprehensions, built-ins, standard library modules).\n- Add minimal, focused inline comments only to clarify nonobvious parts for an experienced Python reader.\n- Do NOT include print statements, debugging code, test scaffolds, or any extraneous text outside the code block.\n- Return ONLY a single Python code block with no additional text or explanation.\n- Ensure the code runs correctly within 5 seconds on typical inputs.\n\nYour output must be enclosed in a single Python code block formatted as:\n\n```python\n# your code here\n```\n\nThe goal is a robust, clear, idiomatic, and fully functional Python translation that matches the pseudocode precisely, maximizes correctness and readability, and handles all cases gracefully.\n\"\"\"\n```",
  "response": "```python\n\"\"\"\nYou are given a piece of pseudocode describing one or more functions and/or classes.\nTranslate the entire pseudocode faithfully into fully working Python code according to these requirements:\n\n- Preserve EXACTLY all function names, parameter names, class names, method names, and their structure.\n- Keep class and object hierarchies identical to the pseudocode, with no renaming or restructuring.\n- Provide precise Python type hints for all parameters and return types, inferred logically.\n- Include all necessary imports *at the top* of the code block to ensure correctness and efficiency. Use only standard libraries or well-established, widely used packages if they meaningfully improve clarity, performance, or correctness.\n- Handle all edge, boundary, or implicit cases robustly, preserving clarity without excess complexity.\n- Write clean, idiomatic, and efficient Python code using language features suited to the task (e.g., comprehensions, built-ins, standard library modules).\n- Add minimal, focused inline comments only to clarify nonobvious parts for an experienced Python reader.\n- Do NOT include print statements, debugging code, test scaffolds, or any extraneous text outside the code block.\n- Return ONLY a single Python code block with no additional text or explanation.\n- Ensure the code runs correctly within 5 seconds on typical inputs.\n\nYour output must be enclosed in a single Python code block formatted as:\n\n```python\n# your code here\n```\n\nThe goal is a robust, clear, idiomatic, and fully functional Python translation that matches the pseudocode precisely, maximizes correctness and readability, and handles all cases gracefully.\n\"\"\"\n```",
  "score": 0.9058280028429282,
  "feedback": "The following are 20 lines of pseudocode of a random subset of the problems along with their decoded codes.\n\nPseudocode for Problem 1:\n```\nFUNCTION encode_cyclic(input_string)\n    SET groups TO EMPTY LIST\n    FOR index FROM 0 TO (LENGTH OF input_string PLUS 2) DIVIDED BY 3 MINUS 1\n        SET start_index TO 3 MULTIPLIED BY index\n        SET end_index TO MINIMUM OF (3 MULTIPLIED BY index PLUS 3) AND LENGTH OF input_string\n        APPEND SUBSTRING OF input_string FROM start_index TO end_index TO groups\n    FOR EACH group IN groups\n        IF LENGTH OF group IS EQUAL TO 3\n            REPLACE group WITH CONCATENATION OF SUBSTRING OF group FROM INDEX 1 TO END AND group AT INDEX 0\n    SET result_string TO CONCATENATION OF ALL GROUPS\n    RETURN result_string\nEND FUNCTION\n\nFUNCTION decode_cyclic(input_string)\n    RETURN encode_cyclic(encode_cyclic(input_string))\nEND FUNCTION\n```\n\nDecoded code for Problem 1:\nfrom typing import List\n\n\ndef encode_cyclic(input_string: str) -> str:\n    groups: List[str] = []\n    n = (len(input_string) + 2) // 3\n    for index in range(n):\n        start_index = 3 * index\n        end_index = min(3 * index + 3, len(input_string))\n        groups.append(input_string[start_index:end_index])\n    for i, group in enumerate(groups):\n        if len(group) == 3:\n            groups[i] = group[1:] + group[0]\n    result_string = ''.join(groups)\n    return result_string\n\n\ndef decode_cyclic(input_string: str) -> str:\n    return encode_cyclic(encode_cyclic(input_string))\n\nError(s) from the decoded code for Problem 1:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp0qrr5eoo/solution_0.py\", line 24, in <module>\\n    check(decode_cyclic)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp0qrr5eoo/solution_0.py\", line 22, in check\\n    assert candidate(encoded_str) == str\\nNameError: name \\'encoded_str\\' is not defined\\n']\n\nPseudocode for Problem 2:\n```\nFUNCTION poly(list_of_coefficients, point_value)\n    RETURN SUM OF (coefficient MULTIPLIED BY point_value RAISED TO power) FOR EACH power, coefficient IN ENUMERATE(list_of_coefficients)\nEND FUNCTION\n\nFUNCTION find_zero(list_of_coefficients)\n    SET begin_point TO -1.0\n    SET end_point TO 1.0\n    WHILE poly(list_of_coefficients, begin_point) MULTIPLIED BY poly(list_of_coefficients, end_point) IS GREATER THAN 0\n        SET begin_point TO begin_point MULTIPLIED BY 2.0\n        SET end_point TO end_point MULTIPLIED BY 2.0\n    END WHILE\n    WHILE end_point MINUS begin_point IS GREATER THAN 1e-10\n        SET center_point TO (begin_point PLUS end_point) DIVIDED BY 2.0\n        IF poly(list_of_coefficients, center_point) MULTIPLIED BY poly(list_of_coefficients, begin_point) IS GREATER THAN 0\n            SET begin_point TO center_point\n        ELSE\n            SET end_point TO center_point\n        END IF\n    END WHILE\n\nDecoded code for Problem 2:\nfrom typing import List\n\ndef poly(list_of_coefficients: List[float], point_value: float) -> float:\n    return sum(coefficient * point_value**power for power, coefficient in enumerate(list_of_coefficients))\n\ndef find_zero(list_of_coefficients: List[float]) -> float:\n    begin_point = -1.0\n    end_point = 1.0\n    while poly(list_of_coefficients, begin_point) * poly(list_of_coefficients, end_point) > 0:\n        begin_point *= 2.0\n        end_point *= 2.0\n    while end_point - begin_point > 1e-10:\n        center_point = (begin_point + end_point) / 2.0\n        if poly(list_of_coefficients, center_point) * poly(list_of_coefficients, begin_point) > 0:\n            begin_point = center_point\n        else:\n            end_point = center_point\n    return begin_point\n\nError(s) from the decoded code for Problem 2:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpqhz28rvz/solution_0.py\", line 23, in <module>\\n    check(find_zero)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpqhz28rvz/solution_0.py\", line 21, in check\\n    assert math.fabs(poly(coeffs, solution)) < 1e-4\\nNameError: name \\'coeffs\\' is not defined\\n']\n\nPseudocode for Problem 3:\n```\nFUNCTION change_base(integer_number, base_number)\n    SET result_string TO empty string\n    WHILE integer_number GREATER THAN 0\n        SET result_string TO string representation of (integer_number MODULO base_number) CONCATENATED WITH result_string\n        SET integer_number TO integer_number INTEGER-DIVIDED BY base_number\n    RETURN result_string\nEND FUNCTION\n```\n\nDecoded code for Problem 3:\nfrom typing import Union\n\ndef change_base(integer_number: int, base_number: int) -> str:\n    if integer_number == 0:\n        return \"0\"\n    result_string = \"\"\n    while integer_number > 0:\n        result_string = str(integer_number % base_number) + result_string\n        integer_number //= base_number\n    return result_string\n\nError(s) from the decoded code for Problem 3:\n['  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpv4fs8vwu/solution_5.py\", line 15\\n    check(change_base)\\nIndentationError: expected an indented block\\n']\n\nPseudocode for Problem 4:\n```\nFUNCTION encode_shift(string_input)\n    RETURN concatenation OF \n        FOR each character IN string_input\n            CHARACTER WITH ASCII VALUE:\n                ((ASCII VALUE OF character PLUS 5 MINUS ASCII VALUE OF 'a') MODULO 26) PLUS ASCII VALUE OF 'a'\nEND FUNCTION\n\nFUNCTION decode_shift(string_input)\n    RETURN concatenation OF \n        FOR each character IN string_input\n            CHARACTER WITH ASCII VALUE:\n                ((ASCII VALUE OF character MINUS 5 MINUS ASCII VALUE OF 'a') MODULO 26) PLUS ASCII VALUE OF 'a'\nEND FUNCTION\n```\n\nDecoded code for Problem 4:\ndef encode_shift(string_input: str) -> str:\n    return ''.join(\n        chr(((ord(char) + 5 - ord('a')) % 26) + ord('a')) for char in string_input\n    )\n\n\ndef decode_shift(string_input: str) -> str:\n    return ''.join(\n        chr(((ord(char) - 5 - ord('a')) % 26) + ord('a')) for char in string_input\n    )\n\nError(s) from the decoded code for Problem 4:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpruc6e9n_/solution_0.py\", line 15, in <module>\\n    check(decode_shift)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpruc6e9n_/solution_0.py\", line 13, in check\\n    assert candidate(copy.deepcopy(encoded_str)) == str\\nNameError: name \\'copy\\' is not defined\\n']\n\nPseudocode for Problem 5:\n```\nFUNCTION add(integer_x, integer_y)\n    RETURN integer_x PLUS integer_y\nEND FUNCTION\n```\n\nDecoded code for Problem 5:\ndef add(integer_x: int, integer_y: int) -> int:\n    return integer_x + integer_y\n\nError(s) from the decoded code for Problem 5:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmppbmsuuzc/solution_4.py\", line 9, in <module>\\n    check(add)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmppbmsuuzc/solution_4.py\", line 8, in check\\n    x, y = random.randint(0, 1000), random.randint(0, 1000)\\nNameError: name \\'random\\' is not defined\\n']\n\nPseudocode for Problem 6:\n```\nFUNCTION mean_absolute_deviation(list_of_numbers)\n    SET mean_value TO SUM OF list_of_numbers DIVIDED BY LENGTH OF list_of_numbers\n    SET total_absolute_deviation TO SUM OF EACH ABSOLUTE VALUE OF (element MINUS mean_value) FOR EACH element IN list_of_numbers\n    SET mean_absolute_deviation_value TO total_absolute_deviation DIVIDED BY LENGTH OF list_of_numbers\n    RETURN mean_absolute_deviation_value\nEND FUNCTION\n```\n\nDecoded code for Problem 6:\nfrom typing import List\n\ndef mean_absolute_deviation(list_of_numbers: List[float]) -> float:\n    n = len(list_of_numbers)\n    if n == 0:\n        raise ValueError(\"list_of_numbers must not be empty\")\n    mean_value: float = sum(list_of_numbers) / n\n    total_absolute_deviation: float = sum(abs(element - mean_value) for element in list_of_numbers)\n    mean_absolute_deviation_value: float = total_absolute_deviation / n\n    return mean_absolute_deviation_value\n\nPseudocode for Problem 7:\n```\nFUNCTION skjkasdkd(list_of_integers)\n    FUNCTION isPrime(number)\n        FOR divisor FROM 2 TO INTEGER_PART OF SQUARE_ROOT OF number INCLUSIVE\n            IF number MODULO divisor EQUALS 0\n                RETURN False\n        END FOR\n        RETURN True\n    END FUNCTION\n\n    SET maximum_prime_value TO 0\n    SET index TO 0\n    WHILE index LESS THAN LENGTH OF list_of_integers\n        IF list_of_integers AT index GREATER THAN maximum_prime_value AND isPrime(list_of_integers AT index)\n            SET maximum_prime_value TO list_of_integers AT index\n        INCREMENT index BY 1\n    END WHILE\n\n    SET digit_sum TO 0\n    FOR EACH digit_character IN STRING REPRESENTATION OF maximum_prime_value\n\nDecoded code for Problem 7:\nfrom math import isqrt\nfrom typing import List\n\n\ndef skjkasdkd(list_of_integers: List[int]) -> int:\n    def isPrime(number: int) -> bool:\n        if number < 2:\n            return False\n        for divisor in range(2, isqrt(number) + 1):\n            if number % divisor == 0:\n                return False\n        return True\n\n    maximum_prime_value: int = 0\n    index: int = 0\n    while index < len(list_of_integers):\n        value = list_of_integers[index]\n        if value > maximum_prime_value and isPrime(value):\n            maximum_prime_value = value\n        index += 1\n\nPseudocode for Problem 8:\n```\nFUNCTION get_row(list_of_lists, target_integer)\n    SET coordinate_list TO empty list\n    FOR each row_index FROM 0 TO LENGTH OF list_of_lists MINUS 1\n        FOR each column_index FROM 0 TO LENGTH OF list_of_lists AT row_index MINUS 1\n            IF element at list_of_lists[row_index][column_index] EQUALS target_integer\n                APPEND tuple (row_index, column_index) TO coordinate_list\n    SET coordinate_list TO coordinate_list SORTED BY column_index IN DESCENDING ORDER\n    SET coordinate_list TO coordinate_list SORTED BY row_index IN ASCENDING ORDER\n    RETURN coordinate_list\nEND FUNCTION\n```\n\nDecoded code for Problem 8:\nfrom typing import List, Tuple\n\ndef get_row(list_of_lists: List[List[int]], target_integer: int) -> List[Tuple[int, int]]:\n    coordinate_list: List[Tuple[int, int]] = []\n    for row_index in range(len(list_of_lists)):\n        for column_index in range(len(list_of_lists[row_index])):\n            if list_of_lists[row_index][column_index] == target_integer:\n                coordinate_list.append((row_index, column_index))\n    # Sort by column_index descending\n    coordinate_list.sort(key=lambda x: x[1], reverse=True)\n    # Sort by row_index ascending (stable sort preserves previous order for same row_index)\n    coordinate_list.sort(key=lambda x: x[0])\n    return coordinate_list\nAvg Passing Rate for ALL the problems: 0.9058280028429282"
}