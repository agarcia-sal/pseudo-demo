{
  "prompt": "Translate the following pseudocode into working Python code. Ensure the code is clean, efficient, and correctly implements the described logic. Enclose **all** the code within a single Python code block marked with triple backticks:\n\n```python\n# Your translated code here\n```\n\nKeep in mind:\n- The function should be optimized to run and return results within 5 seconds.\n- Use clear variable names and comments if helpful.\n- Do not include any explanation outside the code block.",
  "response": "Translate the following pseudocode into working Python code. Ensure the code is clean, efficient, and correctly implements the described logic. Enclose **all** the code within a single Python code block marked with triple backticks:\n\n```python\n# Your translated code here\n```\n\nKeep in mind:\n- The function should be optimized to run and return results within 5 seconds.\n- Use clear variable names and comments if helpful.\n- Do not include any explanation outside the code block.",
  "score": 0.8921464108031273,
  "feedback": "The following are 20 lines of pseudocode of a random subset of the problems along with their decoded codes.\n\nPseudocode for Problem 1:\nFUNCTION encode_shift(s: string) RETURNS string\n    INITIALIZE result as empty string\n    FOR EACH character ch IN s DO\n        COMPUTE shifted_value = ((ASCII value of ch + 5 - ASCII value of 'a') MODULO 26) + ASCII value of 'a'\n        APPEND character with ASCII value shifted_value TO result\n    END FOR\n    RETURN result\nEND FUNCTION\n\nFUNCTION decode_shift(s: string) RETURNS string\n    INITIALIZE result as empty string\n    FOR EACH character ch IN s DO\n        COMPUTE shifted_value = ((ASCII value of ch - 5 - ASCII value of 'a') MODULO 26) + ASCII value of 'a'\n        APPEND character with ASCII value shifted_value TO result\n    END FOR\n    RETURN result\nEND FUNCTION\n\nDecoded code for Problem 1:\ndef encode_shift(s: str) -> str:\n    result = []\n    for ch in s:\n        shifted_value = ((ord(ch) + 5 - ord('a')) % 26) + ord('a')\n        result.append(chr(shifted_value))\n    return ''.join(result)\n\ndef decode_shift(s: str) -> str:\n    result = []\n    for ch in s:\n        shifted_value = ((ord(ch) - 5 - ord('a')) % 26) + ord('a')\n        result.append(chr(shifted_value))\n    return ''.join(result)\n\nError(s) from the decoded code for Problem 1:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpp3qnhywf/solution_0.py\", line 18, in <module>\\n    check(decode_shift)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpp3qnhywf/solution_0.py\", line 16, in check\\n    assert candidate(copy.deepcopy(encoded_str)) == str\\nNameError: name \\'copy\\' is not defined\\n']\n\nPseudocode for Problem 2:\nFUNCTION change_base(x: INTEGER, base: INTEGER) RETURNS STRING\n    SET ret TO empty string\n    WHILE x > 0 DO\n        PREPEND string representation of (x MOD base) TO ret\n        SET x TO x DIVIDED BY base (integer division)\n    END WHILE\n    RETURN ret\nEND FUNCTION\n\nDecoded code for Problem 2:\ndef change_base(x: int, base: int) -> str:\n    if x == 0:\n        return \"0\"\n    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret\n\nError(s) from the decoded code for Problem 2:\n['  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpvdz_mi5d/solution_5.py\", line 13\\n    check(change_base)\\nIndentationError: expected an indented block\\n']\n\nPseudocode for Problem 3:\nFUNCTION encode_cyclic(s: string) RETURNS string\n    SET groups TO empty list\n    FOR i FROM 0 TO (length of s + 2) DIVIDED BY 3 MINUS 1\n        SET start_index TO 3 * i\n        SET end_index TO minimum of (3 * i + 3) and length of s\n        APPEND substring of s from start_index up to end_index TO groups\n    END FOR\n\n    FOR each group IN groups\n        IF length of group EQUALS 3 THEN\n            REPLACE group WITH substring of group from index 1 to end CONCATENATED WITH first character of group\n        ELSE\n            KEEP group AS IS\n        END IF\n    END FOR\n\n    RETURN concatenation of all groups as a single string\nEND FUNCTION\n\nFUNCTION decode_cyclic(s: string) RETURNS string\n\nDecoded code for Problem 3:\ndef encode_cyclic(s: str) -> str:\n    groups = []\n    n = len(s)\n    # Split s into groups of 3 characters\n    for i in range((n + 2) // 3):\n        start_index = 3 * i\n        end_index = min(3 * i + 3, n)\n        group = s[start_index:end_index]\n        groups.append(group)\n\n    # Rotate each full-length group by moving first char to the end\n    for i in range(len(groups)):\n        group = groups[i]\n        if len(group) == 3:\n            groups[i] = group[1:] + group[0]\n\n    return ''.join(groups)\n\n\ndef decode_cyclic(s: str) -> str:\n\nError(s) from the decoded code for Problem 3:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp5kfqr1tb/solution_0.py\", line 27, in <module>\\n    check(decode_cyclic)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp5kfqr1tb/solution_0.py\", line 25, in check\\n    assert candidate(encoded_str) == str\\nNameError: name \\'encoded_str\\' is not defined\\n']\n\nPseudocode for Problem 4:\nFUNCTION rounded_avg(n, m)\n    IF m < n THEN\n        RETURN -1\n    END IF\n\n    SET summation TO 0\n    FOR i FROM n TO m DO\n        summation \u2190 summation + i\n    END FOR\n\n    SET average TO summation / (m - n + 1)\n    SET rounded_average TO ROUND(average)\n    SET binary_result TO CONVERT_TO_BINARY(rounded_average)\n\n    RETURN binary_result\nEND FUNCTION\n\nDecoded code for Problem 4:\ndef rounded_avg(n, m):\n    # Return -1 if m is less than n\n    if m < n:\n        return -1\n\n    # Calculate the sum from n to m inclusive using arithmetic series formula for efficiency\n    count = m - n + 1\n    summation = (n + m) * count // 2\n\n    # Calculate the average and round it\n    average = summation / count\n    rounded_average = round(average)\n\n    # Convert the rounded average to binary string without the '0b' prefix\n    binary_result = bin(rounded_average)[2:]\n\n    return binary_result\n\nError(s) from the decoded code for Problem 4:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpothff2gd/solution_0.py\", line 21, in <module>\\n    check(rounded_avg)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpothff2gd/solution_0.py\", line 20, in check\\n    assert candidate(1, 5) == \"0b11\"\\nAssertionError\\n']\n\nPseudocode for Problem 5:\nFUNCTION add(x: INTEGER, y: INTEGER)\n    RETURN x + y\nEND FUNCTION\n\nDecoded code for Problem 5:\ndef add(x: int, y: int) -> int:\n    return x + y\n\nError(s) from the decoded code for Problem 5:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp9xenmnpk/solution_4.py\", line 9, in <module>\\n    check(add)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp9xenmnpk/solution_4.py\", line 8, in check\\n    x, y = random.randint(0, 1000), random.randint(0, 1000)\\nNameError: name \\'random\\' is not defined\\n']\n\nPseudocode for Problem 6:\n```\nFUNCTION minSubArraySum(nums)\n    SET max_sum TO 0\n    SET current_sum TO 0\n\n    FOR EACH num IN nums\n        SET current_sum TO current_sum + (-num)\n        IF current_sum < 0 THEN\n            SET current_sum TO 0\n        END IF\n        SET max_sum TO MAXIMUM OF current_sum AND max_sum\n    END FOR\n\n    IF max_sum == 0 THEN\n        SET max_sum TO MAXIMUM OF (-i) FOR EACH i IN nums\n    END IF\n\n    SET min_sum TO -max_sum\n    RETURN min_sum\nEND FUNCTION\n\nDecoded code for Problem 6:\ndef min_subarray_sum(nums):\n    max_sum = 0\n    current_sum = 0\n\n    for num in nums:\n        current_sum += -num\n        if current_sum < 0:\n            current_sum = 0\n        max_sum = max(current_sum, max_sum)\n\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n\n    min_sum = -max_sum\n    return min_sum\n\nError(s) from the decoded code for Problem 6:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpzs5svx5c/solution_0.py\", line 19, in <module>\\n    check(minSubArraySum)\\nNameError: name \\'minSubArraySum\\' is not defined\\n']\n\nPseudocode for Problem 7:\n```\nFUNCTION poly(xs: list, x: float)\n    RETURN sum of (coeff * (x raised to power i)) for each index i and coefficient coeff in xs\n\nFUNCTION find_zero(xs: list)\n    SET begin to -1.0\n    SET end to 1.0\n    WHILE poly(xs, begin) multiplied by poly(xs, end) is greater than 0\n        SET begin to begin multiplied by 2.0\n        SET end to end multiplied by 2.0\n    WHILE (end minus begin) is greater than 1e-10\n        SET center to (begin plus end) divided by 2.0\n        IF poly(xs, center) multiplied by poly(xs, begin) is greater than 0\n            SET begin to center\n        ELSE\n            SET end to center\n    RETURN begin\n```\n\nDecoded code for Problem 7:\ndef poly(coefficients, x):\n    \"\"\"Evaluate the polynomial with given coefficients at x.\"\"\"\n    return sum(coeff * (x ** i) for i, coeff in enumerate(coefficients))\n\ndef find_zero(coefficients):\n    \"\"\"Find a root of the polynomial using the bisection method.\"\"\"\n    begin, end = -1.0, 1.0\n\n    # Expand interval until a sign change is found\n    while poly(coefficients, begin) * poly(coefficients, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n\n    # Bisection method to find root within precision 1e-10\n    while end - begin > 1e-10:\n        center = (begin + end) / 2.0\n        if poly(coefficients, center) * poly(coefficients, begin) > 0:\n            begin = center\n        else:\n            end = center\n\nError(s) from the decoded code for Problem 7:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpnsn19rh9/solution_0.py\", line 27, in <module>\\n    check(find_zero)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpnsn19rh9/solution_0.py\", line 25, in check\\n    assert math.fabs(poly(coeffs, solution)) < 1e-4\\nNameError: name \\'coeffs\\' is not defined\\n']\n\nPseudocode for Problem 8:\nFUNCTION sort_even(l: list) RETURNS list\n    SET evens TO sublist of l at even indices (0, 2, 4, ...)\n    SET odds TO sublist of l at odd indices (1, 3, 5, ...)\n    SORT evens in ascending order\n    SET ans TO empty list\n    FOR each pair (e, o) IN parallel iteration over evens and odds\n        APPEND e TO ans\n        APPEND o TO ans\n    END FOR\n    IF length of evens > length of odds THEN\n        APPEND last element of evens TO ans\n    END IF\n    RETURN ans\nEND FUNCTION\n\nDecoded code for Problem 8:\ndef sort_even(lst):\n    # Extract elements at even indices\n    evens = lst[0::2]\n    # Extract elements at odd indices\n    odds = lst[1::2]\n\n    # Sort the evens in ascending order\n    evens.sort()\n\n    ans = []\n    # Iterate over pairs of evens and odds\n    for e, o in zip(evens, odds):\n        ans.append(e)\n        ans.append(o)\n\n    # If there are more evens than odds, append the last even\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n\n    return ans\nAvg Passing Rate for ALL the problems: 0.8921464108031273"
}