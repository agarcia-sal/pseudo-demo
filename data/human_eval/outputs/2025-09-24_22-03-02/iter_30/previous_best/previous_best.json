{
  "prompt": "Convert the given source code into clear, concise, and abstract high-level pseudocode that faithfully preserves all original function and class names, parameters, and their full hierarchical nesting and ownership. Maintain exact identifier names, literals, and types if present. Use uppercase keywords only (e.g., FUNCTION, CLASS, RETURN, IF, ELSE, FOR, WHILE, SET, INCREMENT, DECREMENT, APPEND, CONCATENATE, CALL, BREAK) to represent control flow and operations. Express all operators exclusively in full natural language words (e.g., PLUS, MINUS, MULTIPLY, DIVIDE, MODULO, EQUALS, NOT EQUAL TO, LESS THAN, GREATER THAN, AND, OR, NOT), never symbols or abbreviations.\n\nAvoid language-specific syntax, idioms, or shortcuts such as comprehensions or inline expressions. Instead, represent all control flow explicitly with loops and conditionals and expand all compound operations into atomic steps. Use explicit indexing when accessing sequences or collections, always specifying indices clearly. Represent collections and sequences in descriptive literal forms (e.g., LIST WITH ELEMENTS EMPTY, RANGE FROM zero TO n MINUS ONE). Show function and method calls explicitly as \"CALL function WITH ARGUMENTS ...\" or \"CALL method ON object WITH ARGUMENTS ...\", clearly specifying targets and arguments in natural language. Use consistent indentation to denote blocks and scopes and do not include blank lines, comments, separators, or any text other than the pseudocode itself. Each pseudocode line must correspond to exactly one atomic original statement or logically indivisible operation, ensuring perfect semantic fidelity with zero ambiguity or loss.\n\nAlways use numeric literals as numerals. The output should be solely the pseudocode text with no explanation or additional content.",
  "response": "Convert the given source code into clear, concise, and abstract high-level pseudocode that faithfully preserves all original function and class names, parameters, and their full hierarchical nesting and ownership. Maintain exact identifier names, literals, and types if present. Use uppercase keywords only (e.g., FUNCTION, CLASS, RETURN, IF, ELSE, FOR, WHILE, SET, INCREMENT, DECREMENT, APPEND, CONCATENATE, CALL, BREAK) to represent control flow and operations. Express all operators exclusively in full natural language words (e.g., PLUS, MINUS, MULTIPLY, DIVIDE, MODULO, EQUALS, NOT EQUAL TO, LESS THAN, GREATER THAN, AND, OR, NOT), never symbols or abbreviations.\n\nAvoid language-specific syntax, idioms, or shortcuts such as comprehensions or inline expressions. Instead, represent all control flow explicitly with loops and conditionals and expand all compound operations into atomic steps. Use explicit indexing when accessing sequences or collections, always specifying indices clearly. Represent collections and sequences in descriptive literal forms (e.g., LIST WITH ELEMENTS EMPTY, RANGE FROM zero TO n MINUS ONE). Show function and method calls explicitly as \"CALL function WITH ARGUMENTS ...\" or \"CALL method ON object WITH ARGUMENTS ...\", clearly specifying targets and arguments in natural language. Use consistent indentation to denote blocks and scopes and do not include blank lines, comments, separators, or any text other than the pseudocode itself. Each pseudocode line must correspond to exactly one atomic original statement or logically indivisible operation, ensuring perfect semantic fidelity with zero ambiguity or loss.\n\nAlways use numeric literals as numerals. The output should be solely the pseudocode text with no explanation or additional content.",
  "score": 2.8144475830766496,
  "feedback": "The following are 20 lines of original code of a random subset of the problems along with their pseudocodes.\n\nOriginal Code for Problem 1:\n    result = []\n\n    for i in range(len(string)):\n        result.append(string[:i+1])\n    return result\n\n\nPseudocode for Problem 1:\nFUNCTION all_prefixes WITH PARAMETER string OF TYPE str RETURNS List OF str\n    SET result TO LIST WITH ELEMENTS EMPTY\n    SET length TO CALL len WITH ARGUMENTS string\n    SET i TO 0\n    WHILE i LESS THAN length\n        SET prefix TO EMPTY STRING\n        SET j TO 0\n        WHILE j LESS THAN i PLUS 1\n            SET prefix TO prefix CONCATENATE CALL string AT INDEX j\n            INCREMENT j BY 1\n        APPEND prefix TO result\n        INCREMENT i BY 1\n    RETURN result\n\nError(s) from the decoded code for Problem 1:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpdj3uq8d6/solution_0.py\", line 19, in <module>\\n    check(all_prefixes)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpdj3uq8d6/solution_0.py\", line 18, in check\\n    assert candidate(\\'\\') == []\\nAssertionError\\n']\n\nOriginal Code for Problem 2:\n    return encode_cyclic(encode_cyclic(s))\n\n\nPseudocode for Problem 2:\nFUNCTION encode_cyclic WITH PARAMETER s OF TYPE STRING\n    SET groups TO LIST WITH ELEMENTS EMPTY\n    SET length_s TO CALL length ON s\n    SET count_groups TO CALL integer division OF (length_s PLUS 2) BY 3\n    SET index_i TO 0\n    WHILE index_i LESS THAN count_groups\n        SET start_index TO 3 MULTIPLY index_i\n        SET end_index_candidate TO 3 MULTIPLY index_i PLUS 3\n        IF end_index_candidate GREATER THAN length_s\n            SET end_index TO length_s\n        ELSE\n            SET end_index TO end_index_candidate\n        END IF\n        SET substring TO CALL substring ON s FROM start_index TO end_index MINUS 1\n        APPEND substring TO groups\n        INCREMENT index_i BY 1\n    END WHILE\n    SET new_groups TO LIST WITH ELEMENTS EMPTY\n    SET index_j TO 0\n    SET count_groups TO CALL length ON groups\n\nError(s) from the decoded code for Problem 2:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp6_1zekq4/solution_0.py\", line 45, in <module>\\n    check(decode_cyclic)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp6_1zekq4/solution_0.py\", line 43, in check\\n    assert candidate(encoded_str) == str\\nNameError: name \\'encoded_str\\' is not defined\\n']\n\nOriginal Code for Problem 3:\n    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret\n\n\nPseudocode for Problem 3:\nFUNCTION change_base(x INTEGER, base INTEGER)\n    SET ret TO EMPTY STRING\n    WHILE x GREATER THAN 0\n        SET remainder TO x MODULO base\n        SET remainder_str TO CALL str WITH ARGUMENTS remainder\n        SET ret TO CONCATENATE remainder_str AND ret\n        SET x TO x DIVIDED BY base\n    RETURN ret\n\nError(s) from the decoded code for Problem 3:\n['  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpw2645wga/solution_5.py\", line 13\\n    check(change_base)\\nIndentationError: expected an indented block\\n']\n\nOriginal Code for Problem 4:\n    return sorted(sorted(arr), key=lambda x: bin(x)[2:].count('1'))\n\n\nPseudocode for Problem 4:\nFUNCTION sort_array WITH PARAMETER arr\n    SET sorted_arr TO CALL sorted WITH ARGUMENTS arr\n    DEFINE length_arr AS CALL length ON sorted_arr\n    SET result TO LIST WITH ELEMENTS EMPTY\n    FOR index FROM 0 TO length_arr MINUS 1\n        SET min_index TO index\n        FOR j FROM index PLUS 1 TO length_arr MINUS 1\n            SET x_binary TO CALL binary_representation_of INTEGER sorted_arr AT min_index\n            SET count_ones_min TO 0\n            FOR k FROM 2 TO CALL length ON x_binary MINUS 1\n                IF CALL character AT POSITION k IN x_binary EQUALS '1'\n                    INCREMENT count_ones_min BY 1\n            SET y_binary TO CALL binary_representation_of INTEGER sorted_arr AT j\n            SET count_ones_j TO 0\n            FOR k FROM 2 TO CALL length ON y_binary MINUS 1\n                IF CALL character AT POSITION k IN y_binary EQUALS '1'\n                    INCREMENT count_ones_j BY 1\n            IF count_ones_j LESS THAN count_ones_min OR (count_ones_j EQUALS count_ones_min AND sorted_arr AT j LESS THAN sorted_arr AT min_index)\n                SET min_index TO j\n        IF min_index NOT EQUAL TO index\n\nError(s) from the decoded code for Problem 4:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpc363293y/solution_0.py\", line 42, in <module>\\n    check(sort_array)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpc363293y/solution_0.py\", line 41, in check\\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\\nAssertionError\\n']\n\nOriginal Code for Problem 5:\n    begin, end = -1., 1.\n    while poly(xs, begin) * poly(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) / 2.0\n        if poly(xs, center) * poly(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n\n\nPseudocode for Problem 5:\nFUNCTION poly WITH PARAMETERS xs AS LIST, x AS FLOAT\n    SET result TO 0.0\n    SET n TO LENGTH OF xs\n    SET i TO 0\n    WHILE i LESS THAN n\n        SET coeff TO ELEMENT AT INDEX i IN xs\n        SET power TO CALL math.pow WITH ARGUMENTS x, i\n        SET term TO coeff MULTIPLY power\n        SET result TO result PLUS term\n        INCREMENT i BY 1\n    END WHILE\n    RETURN result\nEND FUNCTION\n\nFUNCTION find_zero WITH PARAMETER xs AS LIST\n    SET begin TO -1.0\n    SET end TO 1.0\n    SET value_begin TO CALL poly WITH ARGUMENTS xs, begin\n    SET value_end TO CALL poly WITH ARGUMENTS xs, end\n    SET product TO value_begin MULTIPLY value_end\n\nError(s) from the decoded code for Problem 5:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpyf2hol54/solution_0.py\", line 43, in <module>\\n    check(find_zero)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpyf2hol54/solution_0.py\", line 41, in check\\n    assert math.fabs(poly(coeffs, solution)) < 1e-4\\nNameError: name \\'coeffs\\' is not defined\\n']\n\nOriginal Code for Problem 6:\n    return x + y\n\n\nPseudocode for Problem 6:\nFUNCTION add WITH PARAMETERS x AS int, y AS int\n    RETURN x PLUS y\n\nError(s) from the decoded code for Problem 6:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpkm2c2_ak/solution_4.py\", line 9, in <module>\\n    check(add)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpkm2c2_ak/solution_4.py\", line 8, in check\\n    x, y = random.randint(0, 1000), random.randint(0, 1000)\\nNameError: name \\'random\\' is not defined\\n']\n\nOriginal Code for Problem 7:\n    return [(i * x) for i, x in enumerate(xs)][1:]\n\n\nPseudocode for Problem 7:\nFUNCTION derivative WITH PARAMETER xs OF TYPE list\n    SET result TO LIST WITH ELEMENTS EMPTY\n    SET index TO 0\n    WHILE index LESS THAN LENGTH OF xs\n        SET product TO index MULTIPLY xs AT index\n        APPEND product TO result\n        INCREMENT index BY 1\n    END WHILE\n    SET result TO SLICE OF result FROM INDEX 1 TO LENGTH OF result MINUS ONE\n    RETURN result\nEND FUNCTION\n\nError(s) from the decoded code for Problem 7:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp3n1umoz4/solution_0.py\", line 13, in <module>\\n    check(derivative)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp3n1umoz4/solution_0.py\", line 12, in check\\n    assert candidate([3, 1, 2, 4, 5]) == [1, 4, 12, 20]\\nAssertionError\\n']\n\nOriginal Code for Problem 8:\n    if n == 0:\n        return [1]\n    my_tri = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_tri.append(i / 2 + 1)\n        else:\n            my_tri.append(my_tri[i - 1] + my_tri[i - 2] + (i + 3) / 2)\n    return my_tri\n\n\nPseudocode for Problem 8:\nFUNCTION tri WITH PARAMETER n\n    IF n EQUALS 0 THEN\n        RETURN LIST WITH ELEMENTS 1\n    END IF\n\n    SET my_tri TO LIST WITH ELEMENTS 1 AND 3\n\n    FOR i FROM 2 TO n PLUS 1 MINUS 1 DO\n        IF i MODULO 2 EQUALS 0 THEN\n            SET value TO 1 PLUS i DIVIDE BY 2\n            CALL APPEND value ON my_tri\n        ELSE\n            SET left TO VALUE AT INDEX i MINUS 1 IN my_tri\n            SET middle TO VALUE AT INDEX i MINUS 2 IN my_tri\n            SET right TO 3 PLUS i DIVIDE BY 2\n            SET value TO left PLUS middle PLUS right\n            CALL APPEND value ON my_tri\n        END IF\n    END FOR\n\n\nError(s) from the decoded code for Problem 8:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpwex0g5eo/solution_0.py\", line 22, in <module>\\n    check(tri)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpwex0g5eo/solution_0.py\", line 21, in check\\n    assert candidate(3) == [1, 3, 2.0, 8.0]\\nAssertionError\\n']\nScore of (4*(Average word length) + passing rate) for ALL the problems: 2.8144475830766496"
}