```
FUNCTION count_nums(tau)
  FUNCTION digits_sum(mu)
    FUNCTION multsign(rho, sigma)
      SWITCH
        CASE rho < 0:
          RETURN sigma * -1
        DEFAULT:
          RETURN sigma
      END SWITCH
    END FUNCTION

    FUNCTION abs_val(phi)
      RETURN (phi * -1) * ((phi < 0) ? 1 : 0) + phi * ((phi < 0) ? 0 : 1)
    END FUNCTION

    SET kappa TO 1
    SWITCH 
      CASE mu < 0:
        SET mu TO abs_val(mu)
        SET kappa TO multsign(mu, kappa)
    END SWITCH

    FUNCTION str_to_digits(chi)
      FUNCTION recurse(idx, res)
        IF idx >= LENGTH(chi)
          RETURN res
        END IF
        RETURN recurse(idx + 1, res + [INTEGER(chi AT idx)])
      END FUNCTION
      RETURN recurse(0, [])
    END FUNCTION

    SET digits AS str_to_digits(STRING(mu))
    SET digits AT 0 TO digits AT 0 * kappa

    FUNCTION sum_digits(lst)
      FUNCTION fold_sum(lst_inner, acc, n)
        IF n >= LENGTH(lst_inner)
          RETURN acc
        END IF
        RETURN fold_sum(lst_inner, acc + lst_inner AT n, n + 1)
      END FUNCTION
      RETURN fold_sum(lst, 0, 0)
    END FUNCTION

    RETURN sum_digits(digits)
  END FUNCTION

  FUNCTION map_list(lst, fn)
    FUNCTION recurse_map(ix, acc)
      IF ix >= LENGTH(lst)
        RETURN acc
      END IF
      RETURN recurse_map(ix + 1, acc + [fn(lst AT ix)])
    END FUNCTION
    RETURN recurse_map(0, [])
  END FUNCTION

  FUNCTION filter_list(lst, pred)
    FUNCTION recurse_filter(ix, acc)
      IF ix >= LENGTH(lst)
        RETURN acc
      END IF
      IF pred(lst AT ix)
        RETURN recurse_filter(ix + 1, acc + [lst AT ix])
      ELSE
        RETURN recurse_filter(ix + 1, acc)
      END IF
    END FUNCTION
    RETURN recurse_filter(0, [])
  END FUNCTION

  SET omega TO map_list(tau, digits_sum)
  SET psi TO filter_list(omega, FUNCTION(x) RETURN x > 0 END FUNCTION)

  RETURN LENGTH(psi)
END FUNCTION
```