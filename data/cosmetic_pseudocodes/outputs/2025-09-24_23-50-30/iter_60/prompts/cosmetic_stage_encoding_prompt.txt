Rewrite the given pseudocode to produce a *maximally transformed* version that is **functionally equivalent and behaviorally identical** under these strict conditions:

- **Preserve all original functionality exactly:** input/output behavior, side effects, error handling, termination and correctness guarantees must remain unchanged.

- **Retain verbatim all original function names, class names, and the precise class/object nesting and inheritance structure.** These must appear exactly as in the input without any renaming or restructuring.

- **Only transform identifiers that are*local* to functions or procedures** (such as parameters, local variables, constants, and temporaries). Rename all of these to completely new, unrelated, semantically neutral identifiers, consistently and without collisions inside their scope.

- **Output only complete, valid pseudocode** for the *same* program. Under no circumstances include explanations, comments, markup, or any extra text.

- **Apply aggressive, diverse, combined transformations** to achieve maximal syntactic, structural, lexical, and stylistic divergence, including but not limited to:

  - Convert all loop forms (for, while, repeat-until) into semantically equivalent recursion (preferably tail recursion where applicable) or vice versa. Replace iterative with declarative styles such as comprehensions, pipelines, functional folds/maps where expressible.

  - Thoroughly restructure all conditional logic: transform if-else chains into switch/case or nested guards; rewrite boolean expressions using distributive, associative, De Morgan laws; swap condition order or invert logic with logical equivalences; transform ternaries into full conditionals or inline expressions.

  - Change data structure representations where semantics permit (e.g., lists â†” arrays, sets, linked structures), ensuring all semantic behaviors match exactly.

  - Arbitrarily reorder, split, merge, or regroup statements and blocks where it preserves semantics and termination.

  - Rewrite arithmetic and logical expressions to logically equivalent but syntactically different forms: reorder operations, reorder operands in commutative operators, factor or expand expressions, fold constants differently, introduce logically redundant operations if semantics remain correct.

  - Modify formatting drastically: vary indentation patterns, line breaks, spacing, and statement ordering without affecting meaning.

  - Replace recursive implementations prone to deep call stacks with iterative or explicitly tail-recursive variants that preserve correctness but avoid stack overflow.

  - When possible, refactor control flow constructs into more orthogonal or alternative paradigms covered by original pseudocode semantics (e.g., tail recursion to iteration; iteration to recursion; single loop to nested loops; conditionals to pattern matching or case statements).

- **Do NOT add new features, remove required logic, or introduce language/paradigm features not supported by the original pseudocode.**

- **Remove only code proven to be unreachable or truly redundant, but only if it does not alter observable behavior, side effects, or termination.**

- Maintain **type and data flow equivalences precisely**, including order of operations and side effects.

Your output MUST contain ONLY the resulting transformed pseudocode, no explanation or comment, strictly adhering to the above constraints.

This transformation aims to produce a pseudocode version that is as different as possible in form and structure from the original while preserving *every aspect* of program semantics exactly, enabling full reimplementation that passes all behavioral tests and maximizes linguistic novelty at the same time.