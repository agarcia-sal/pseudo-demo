Rewrite the input pseudocode to produce a semantically exact and behaviorally identical variant that satisfies all of the following requirements:

- Preserve every functional detail **with absolute fidelity**: all outputs, side effects, input-output contracts, error cases, termination conditions, and logical correctness must be intact and indistinguishable from the original.

- Retain all **function names, class names, and their nesting and inheritance relations unchanged**. The exact spelling, letter casing, and hierarchical structure of these must remain unaltered.

- The rewritten pseudocode output must contain **only complete, valid pseudocode that can replace the original as-is**, containing **no explanations, comments, annotations, or extra text**—just the transformed code.

- All other identifiers — including local variables, parameters, constants, temporaries — must be consistently renamed to fresh, unrelated, semantically neutral names that neither collide nor shadow any existing identifiers within their scope.

- Achieve maximal syntactic, lexical, and structural divergence from the original by applying a rich, diverse combination of transformations, including but not limited to:

  * Convert iterative loops (for, while) to equivalent recursion (preferably tail-recursive where possible) or to comprehensions, iterators, or alternative control constructs; conversely convert recursion into iteration appropriately.

  * Dramatically restructure conditional logic by applying any combination of: converting if-else chains to switch/case or pattern-guards, distributing/de Morgan’s laws, boolean algebra rewrites, condition negations/flips, ternary expansions or compressions, nested-to-flat or flat-to-nested transformations—always preserving exact truth conditions.

  * Substitute semantically identical data structure representations where feasible (e.g., arrays ⇄ linked lists ⇄ sets ⇄ hash maps) without losing any behavioral nuance.

  * Arbitrarily reorder, split, or merge blocks and statements wherever the execution order and effects remain precisely the same.

  * Refactor expressions into logically equivalent but syntactically distinct forms—reassociating arithmetic, refactoring factoring, constant folding/unfolding, Boolean expressional rewrites, operator reordering consistent with associativity/commutativity.

  * Amplify superficial differences via formatting transformations: change indentation style (spaces vs tabs), vary line breaks, reorder statements (where order-independent), expand or condense expressions, alter use of whitespace, and vary naming styles of renamed variables.

  * Replace all recursion that risks deep call stacks with equivalent iterative or tail-recursive forms that maintain semantics but prevent stack overflow.

- Do not introduce any novel language features, paradigms, or constructs not present in the original pseudocode.

- Only remove unreachable or provably redundant code fragments **if** and **only if** elimination does not alter the observable behavior in any way.

- The output must be a drop-in replacement for the original pseudocode, differing strongly in surface form but indistinguishable in operational effect. 

**Important:** Output exactly and only the fully transformed pseudocode, adhering meticulously to these requirements, avoiding any preamble or postamble. The focus is on maximizing orthogonality and novelty while perfectly preserving all semantics, correctness, and interface details—including all function and class names and object structures exactly as in the original.