{
  "prompt": "Rewrite the given pseudocode to produce a functionally equivalent and semantically identical version that meets all the following criteria:\n\n- Preserve **exactly all original behaviors, side-effects, input-output contracts, termination conditions, and correctness** in every detail.\n\n- Maintain **all original function names, class names, class/object nesting structures, and inheritance hierarchies unchanged** (including exact spelling and casing).\n\n- Produce output containing **only valid, complete pseudocode** for the same program \u2014 no explanations, comments, or extra text permitted.\n\n- Replace **all other identifiers (local variables, parameters, constants, temporaries)** with freshly invented, unrelated, semantically neutral names that do **not collide** anywhere in their scope, and remain consistent throughout.\n\n- Maximize syntactic and structural divergence from the original by applying **diverse, combined transformations**, including but not limited to:\n\n  - Converting loops (for, while) to recursive or tail-recursive calls, iterator pipelines, comprehensions, or equivalent control flows, and vice versa.\n\n  - Reorganizing conditional logic extensively \u2014 converting if-else chains to switch/case, nested guards, ternaries, De Morgan or Boolean algebra rewrites, restructuring boolean expressions, or logically equivalent condition replacements.\n\n  - Using alternative, equivalent data structure representations where semantics allow (e.g., lists to arrays or sets, linked forms to indexed), preserving all behaviors.\n\n  - Reordering, splitting, merging, or regrouping blocks and statements arbitrarily wherever behavior is unaffected.\n\n  - Rewriting expressions to logically equivalent but syntactically distinct forms\u2014altering arithmetic order, factoring, boolean negations, constant folding variations, etc.\n\n  - Aggressively varying formatting\u2014indentation styles, line breaks, spacing, statement ordering\u2014to maximize surface-level difference.\n\n  - Ensuring recursive functions with potential deep recursion are replaced by iterative or tail-recursive variants that avoid stack overflow, without changing semantics.\n\n- Do **not** add or remove any functionality, or introduce any new language or paradigm elements beyond those in the original pseudocode.\n\n- Eliminate only unreachable or truly redundant code **if and only if** this preserves full external behavior.\n\nYour output must contain **only the transformed pseudocode** adhering to these rigorous constraints, achieving maximal orthogonality and novelty while perfectly preserving the original\u2019s semantics and correctness guarantees.",
  "response": "Rewrite the given pseudocode to produce a functionally equivalent and semantically identical version that meets all the following criteria:\n\n- Preserve **exactly all original behaviors, side-effects, input-output contracts, termination conditions, and correctness** in every detail.\n\n- Maintain **all original function names, class names, class/object nesting structures, and inheritance hierarchies unchanged** (including exact spelling and casing).\n\n- Produce output containing **only valid, complete pseudocode** for the same program \u2014 no explanations, comments, or extra text permitted.\n\n- Replace **all other identifiers (local variables, parameters, constants, temporaries)** with freshly invented, unrelated, semantically neutral names that do **not collide** anywhere in their scope, and remain consistent throughout.\n\n- Maximize syntactic and structural divergence from the original by applying **diverse, combined transformations**, including but not limited to:\n\n  - Converting loops (for, while) to recursive or tail-recursive calls, iterator pipelines, comprehensions, or equivalent control flows, and vice versa.\n\n  - Reorganizing conditional logic extensively \u2014 converting if-else chains to switch/case, nested guards, ternaries, De Morgan or Boolean algebra rewrites, restructuring boolean expressions, or logically equivalent condition replacements.\n\n  - Using alternative, equivalent data structure representations where semantics allow (e.g., lists to arrays or sets, linked forms to indexed), preserving all behaviors.\n\n  - Reordering, splitting, merging, or regrouping blocks and statements arbitrarily wherever behavior is unaffected.\n\n  - Rewriting expressions to logically equivalent but syntactically distinct forms\u2014altering arithmetic order, factoring, boolean negations, constant folding variations, etc.\n\n  - Aggressively varying formatting\u2014indentation styles, line breaks, spacing, statement ordering\u2014to maximize surface-level difference.\n\n  - Ensuring recursive functions with potential deep recursion are replaced by iterative or tail-recursive variants that avoid stack overflow, without changing semantics.\n\n- Do **not** add or remove any functionality, or introduce any new language or paradigm elements beyond those in the original pseudocode.\n\n- Eliminate only unreachable or truly redundant code **if and only if** this preserves full external behavior.\n\nYour output must contain **only the transformed pseudocode** adhering to these rigorous constraints, achieving maximal orthogonality and novelty while perfectly preserving the original\u2019s semantics and correctness guarantees.",
  "score": 0.8191717396110366,
  "feedback": "The following are 20 lines of original pseudocode of a random subset of the problems along with their modified pseudocodes.\n\nPseudocode for Problem 1:\n```\nFUNCTION how_many_times(alpha, beta)\n    SET gamma TO LENGTH OF alpha - LENGTH OF beta\n    SET delta TO 0\n    LABEL omega\n    IF delta > gamma THEN GOTO zeta\n        IF beta = SUBSTRING OF alpha FROM delta TO (delta + LENGTH OF beta)\n            SET epsilon TO 1\n        ELSE\n            SET epsilon TO 0\n        ENDIF\n        SET delta TO delta + 1\n        SET gamma TO gamma + 0\n        SET gamma TO gamma\n        SET sigma TO delta\n        SET omega TO epsilon + omega\n        SET omega TO epsilon + omega\n        IF epsilon = 1 THEN\n            SET zeta TO omega\n        ENDIF\n\nModified Pseudocode for Problem 1:\n```\nFUNCTION how_many_times(original_string, target_substring)\n    SET occurrence_count TO 0\n    FOR each index FROM 0 TO LENGTH OF original_string MINUS LENGTH OF target_substring\n        IF SUBSTRING OF original_string FROM index TO index PLUS LENGTH OF target_substring EQUALS target_substring\n            INCREMENT occurrence_count BY 1\n    RETURN occurrence_count\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 1:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmprzp6jcon/solution_1.py\", line 23, in <module>\\n    check(how_many_times)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmprzp6jcon/solution_1.py\", line 22, in check\\n    assert candidate(\\'xyxyxyx\\', \\'x\\') == 4\\nAssertionError\\n']\n\nPseudocode for Problem 2:\n```\nFUNCTION fizz_buzz(index_z)\n  VAR acc_seq \u2190 []\n  VAR recur_append \u2190 FUNCTION(j, seq)\n    IF j = index_z THEN\n      RETURN seq\n    ELSE\n      VAR cond_val \u2190 NOT((j MOD 11) \u2260 0 AND (j MOD 13) \u2260 0)\n      VAR updated_seq \u2190 IF cond_val THEN seq + [j] ELSE seq\n      RETURN recur_append(j + 1, updated_seq)\n    END IF\n  END FUNCTION\n\n  acc_seq \u2190 recur_append(0, acc_seq)\n\n  VAR fold_str \u2190 FUNCTION(lst, acc)\n    IF lst = [] THEN\n      RETURN acc\n    ELSE\n      RETURN fold_str(lst[1:], acc + TO_STRING(lst[0]))\n\nModified Pseudocode for Problem 2:\n```\nFUNCTION fizz_buzz(integer_n)\n    SET list_of_numbers TO empty list\n    FOR each integer_i IN range FROM 0 TO integer_n EXCLUSIVE\n        IF integer_i MODULO 11 EQUALS 0 OR integer_i MODULO 13 EQUALS 0\n            APPEND integer_i TO list_of_numbers\n        END IF\n    END FOR\n    SET concatenated_string TO empty string\n    FOR each number IN list_of_numbers\n        CONCATENATE string representation of number TO concatenated_string\n    END FOR\n    SET count_of_sevens TO 0\n    FOR each character_c IN concatenated_string\n        INCREMENT count_of_sevens BY (character_c EQUALS '7')\n    END FOR\n    RETURN count_of_sevens\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 2:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpimhzt8ir/solution_5.py\", line 35, in <module>\\n    check(fizz_buzz)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpimhzt8ir/solution_5.py\", line 34, in check\\n    assert candidate(4000) == 192\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpimhzt8ir/solution_5.py\", line 15, in fizz_buzz\\n    acc_seq = recur_append(0, acc_seq)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpimhzt8ir/solution_5.py\", line 13, in recur_append\\n    return recur_append(j + 1, updated_seq)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpimhzt8ir/solution_5.py\", line 13, in recur_append\\n    return recur_append(j + 1, updated_seq)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpimhzt8ir/solution_5.py\", line 13, in recur_append\\n    return recur_append(j + 1, updated_seq)\\n  [Previous line repeated 993 more times]\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpimhzt8ir/solution_5.py\", line 9, in recur_append\\n    if j == index_z:\\nRecursionError: maximum recursion depth exceeded in comparison\\n']\n\nPseudocode for Problem 3:\n```\nFUNCTION modp(x1, x2)\n result_accumulator \u2190 1\n PROCEDURE loop_recursion(y1)\n  IF y1 = x1 THEN\n   RETURN result_accumulator\n  ELSE\n   result_accumulator \u2190 (result_accumulator + result_accumulator) MOD x2\n   RETURN loop_recursion(y1 + 1)\n  END IF\n END PROCEDURE\n RETURN loop_recursion(0)\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 3:\n```\nFUNCTION modp(integer_n, integer_p)\n    SET result_value TO 1\n    FOR each integer_index FROM 0 TO integer_n MINUS 1\n        SET result_value TO (2 MULTIPLIED BY result_value) MODULO integer_p\n    RETURN result_value\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 3:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp01iccfiw/solution_1.py\", line 17, in <module>\\n    check(modp)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp01iccfiw/solution_1.py\", line 16, in check\\n    assert candidate(1101, 101) == 2\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp01iccfiw/solution_1.py\", line 14, in modp\\n    return loop_recursion(0)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp01iccfiw/solution_1.py\", line 12, in loop_recursion\\n    return loop_recursion(y1 + 1)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp01iccfiw/solution_1.py\", line 12, in loop_recursion\\n    return loop_recursion(y1 + 1)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp01iccfiw/solution_1.py\", line 12, in loop_recursion\\n    return loop_recursion(y1 + 1)\\n  [Previous line repeated 993 more times]\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp01iccfiw/solution_1.py\", line 9, in loop_recursion\\n    if y1 == x1:\\nRecursionError: maximum recursion depth exceeded in comparison\\n']\n\nPseudocode for Problem 4:\n```\nFUNCTION longest(zeta) \n  DEFINE FUNCTION hunt_eta(theta, i)\n    IF i < 0 THEN \n      RETURN None \n    ELSE \n      SELECT:\n        CASE LENGTH(theta[i]) = MAXIMUM OF LENGTH(x) FOR x IN theta:\n          RETURN theta[i]\n        DEFAULT:\n          RETURN hunt_eta(theta, i - 1)\n      END SELECT\n    END IF\n  END FUNCTION\n\n  RETURN hunt_eta(zeta, (LENGTH(zeta) - 1))\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 4:\n```\nFUNCTION longest(list_of_strings)\n    IF list_of_strings IS EMPTY\n        RETURN None\n    END IF\n\n    SET maximum_length TO MAXIMUM OF LENGTH OF each string IN list_of_strings\n    FOR each string IN list_of_strings\n        IF LENGTH OF string EQUALS maximum_length\n            RETURN string\n        END IF\n    END FOR\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 4:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp2t1wikku/solution_1.py\", line 16, in <module>\\n    check(longest)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp2t1wikku/solution_1.py\", line 15, in check\\n    assert candidate([\\'x\\', \\'y\\', \\'z\\']) == \\'x\\'\\nAssertionError\\n']\n\nPseudocode for Problem 5:\n```\nFUNCTION rounded_avg(p, q)\n    IF NOT (p <= q)\n        RETURN -1\n    ENDIF\n\n    VAR idx <- p\n    VAR totalSum <- 0\n\n    WHILE idx <= q\n        totalSum <- totalSum + idx\n        idx <- idx + 1\n    ENDWHILE\n\n    VAR countElements <- (q - p + 1)\n    VAR meanValue <- totalSum * 1.0 / countElements\n    VAR nearestInteger <- (meanValue + 0.5) - ((meanValue + 0.5) MOD 1)\n    VAR binString <- \"\"\n    VAR tempVal <- nearestInteger\n\n\nModified Pseudocode for Problem 5:\n```\nFUNCTION rounded_avg(n, m)\n    IF m IS LESS THAN n\n        RETURN -1\n    SET summation TO 0\n    FOR each integer i FROM n TO m INCLUSIVE\n        INCREMENT summation BY i\n    SET average_value TO summation DIVIDED BY (m MINUS n PLUS 1)\n    SET rounded_average TO ROUND average_value TO NEAREST INTEGER\n    SET binary_representation TO BINARY FORMAT OF rounded_average\n    RETURN binary_representation\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 5:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpkr0rwx0c/solution_0.py\", line 32, in <module>\\n    check(rounded_avg)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpkr0rwx0c/solution_0.py\", line 31, in check\\n    assert candidate(1, 5) == \"0b11\"\\nAssertionError\\n']\n\nPseudocode for Problem 6:\n```\nFUNCTION get_row(pyramid_chain, direction_code)\n  LET prism_array = []\n  LET prism_nest = 0\n  WHILE prism_nest < LENGTH(pyramid_chain)\n    LET beam_pos = 0\n    WHILE beam_pos < LENGTH(pyramid_chain AT prism_nest)\n      LET gate = pyramid_chain[prism_nest][beam_pos]\n      IF NOT (gate != direction_code)\n        prism_array APPEND (prism_nest, beam_pos)\n      ENDIF\n      beam_pos = beam_pos + 1\n    ENDWHILE\n    prism_nest = prism_nest + 1\n  ENDWHILE\n  prism_array = SORT(prism_array, KEY = LAMBDA x: x[0])\n  prism_array = SORT(prism_array, KEY = LAMBDA x: -x[1])\n  RETURN prism_array\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 6:\n```\nFUNCTION get_row(two_dimensional_list, target_integer)\n    SET coordinates TO EMPTY LIST\n    FOR each row_index FROM 0 TO LENGTH OF two_dimensional_list MINUS 1\n        FOR each column_index FROM 0 TO LENGTH OF two_dimensional_list AT row_index MINUS 1\n            IF two_dimensional_list AT row_index AT column_index EQUALS target_integer\n                APPEND TUPLE(row_index, column_index) TO coordinates\n    SET coordinates TO coordinates SORTED BY SECOND ELEMENT IN DESCENDING ORDER\n    SET coordinates TO coordinates SORTED BY FIRST ELEMENT IN ASCENDING ORDER\n    RETURN coordinates\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 6:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp8eltkqyg/solution_0.py\", line 25, in <module>\\n    check(get_row)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp8eltkqyg/solution_0.py\", line 20, in check\\n    assert candidate([\\nAssertionError\\n']\n\nPseudocode for Problem 7:\n```\nFUNCTION largest_divisor(omega)\n    VARIABLE psi = omega - 1\n    WHILE psi > 0\n        IF (omega - ((omega \\ psi) * psi)) = 0 THEN\n            RETURN psi\n        END IF\n        SET psi = psi - 1\n    END WHILE\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 7:\n```\nFUNCTION largest_divisor(integer_n)\n    FOR each integer_i IN REVERSED RANGE FROM 0 TO integer_n EXCLUDING integer_n\n        IF integer_n MODULO integer_i EQUALS 0\n            RETURN integer_i\nEND FUNCTION\n```\n\nPseudocode for Problem 8:\n```\nFUNCTION search(sequence)\n    SET counts TO ARRAY OF ZEROS WITH SIZE (MAXIMUM ELEMENT IN sequence) + 1\n    DEFINE PROCEDURE update_counts(seq, pos)\n        IF pos EQUALS LENGTH OF seq\n            RETURN\n        SET counts AT seq AT pos TO counts AT seq AT pos + 1\n        CALL update_counts(seq, pos + 1)\n    CALL update_counts(sequence, 0)\n    SET result TO -1\n    DEFINE PROCEDURE find_result(idx)\n        IF idx GREATER THAN LENGTH OF counts - 1\n            RETURN\n        IF NOT (counts AT idx < idx)\n            SET result TO idx\n        CALL find_result(idx + 1)\n    CALL find_result(1)\n    RETURN result\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 8:\n```\nFUNCTION search(list_of_integers)\n    SET frequency_list TO list_of_zeros WITH LENGTH max_value_in list_of_integers PLUS 1\n    FOR each integer IN list_of_integers\n        INCREMENT frequency_list AT POSITION integer BY 1\n    SET answer TO -1\n    FOR each index FROM 1 TO LENGTH OF frequency_list MINUS 1\n        IF frequency_list AT POSITION index IS GREATER THAN OR EQUAL TO index\n            SET answer TO index\n    RETURN answer\nEND FUNCTION\n```\nScore of Passing Rate - BLEU Score for ALL the problems: 0.8191717396110366"
}