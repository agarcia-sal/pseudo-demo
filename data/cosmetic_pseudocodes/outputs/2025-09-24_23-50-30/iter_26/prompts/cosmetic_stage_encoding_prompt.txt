Rewrite the given pseudocode so that it retains **exactly the same functionality, behaviors, side-effects, input-output contracts, and termination conditions**, **with absolutely no changes to function names, class names, nor the class/object/nesting/inheritance hierarchy** (including their exact spellings and casing).

**Constraints**:

- The output must be only **valid, self-contained pseudocode** reflecting a complete alternative representation of the original logic; do **NOT** include any explanations, comments, or auxiliary text.

- Strictly preserve **function and class identifiers and structural positions**; all other identifiers (variables, parameters, constants, temporary names) must be **renamed to unrelated, semantically neutral alternatives**, avoiding collisions and ensuring consistent usage within their scopes.

- Maximize syntactic and structural novelty by applying extensive, combined transformations to the pseudocode, such as:

  - Converting iterative constructs (for, while) into recursion, tail recursion, comprehensions, filter/map pipelines, or other equivalent control flows—and vice versa.

  - Altering conditional logic by replacing if-else chains with switch/case, guarded clauses, nested conditions, ternary expressions, De Morgan’s transformations, and logically equivalent but differently structured boolean expressions.

  - Re-expressing data structures using equivalent alternatives (e.g., sets ↔ lists ↔ arrays; linked structures ↔ indexed structures) wherever semantics permit, without changing overall behavior.

  - Restructuring code by splitting, merging, or reordering statements and blocks when harmless to semantics.

  - Using alternative but logically identical arithmetic and logical computations (e.g., `a + b` → `b + a`, `!(x AND y)` → `!x OR !y`, folding constants differently).

  - Reformatting aggressively with varied indentation, line breaks, grouping, spacing, and statement order to maximize surface syntactic difference.

  - For recursive methods susceptible to deep recursion, replace with equivalent iterative or tail-recursive methods to avoid overflow risks without functional changes.

- Do not introduce any new language-specific features, libraries, or constructs beyond those implied by the original pseudocode's paradigm and idioms.

- Remove unreachable or redundant code **only if** this does not alter any external behavior.

Produce only the rewritten pseudocode fulfilling all above requirements, optimizing for maximal orthogonality and novelty from the original, **while perfectly preserving all semantic and correctness guarantees.**