Rewrite the given pseudocode into a fully functionally equivalent version that satisfies **all** the criteria below:

- **Strictly retain all original behavior with zero deviation:** input/output relations, side effects, termination and correctness must be identical in every detail.

- Preserve **all function names, class names, nesting, and inheritance structures exactly as in the original**—including spelling, casing, and hierarchy—without any alteration.

- Produce as output **only valid, complete pseudocode representing the entire program** or function as in the input.  
  Do **not** include explanations, comments, summaries, or any additional text—only pseudocode.

- Rename **all other identifiers** (local variables, parameters, temporary variables, constants, loop counters, labels, etc.) with freshly created, unrelated, semantically neutral names that **do not conflict** within their scope, and are used consistently throughout.

- Aggressively maximize syntactic and structural divergence from the original by thoughtfully combining multiple transformational strategies such as:

  - Converting loops (for, while) to recursion, tail recursion, iterator pipelines, comprehensions, or other equivalent control flows, and vice versa.

  - Restructuring conditionals thoroughly: replace if-else chains by switch/case, nested guards, ternary expressions, or logically equivalent boolean formula transformations using De Morgan’s laws, factoring, distribution, or rewriting boolean terms.

  - Replacing data structures with equivalent representations where behavior allows (for example, sets for lists when order is irrelevant, or arrays for linked lists), preserving all semantics precisely.

  - Reordering, merging, splitting, grouping, or flattening code blocks and statements arbitrarily as long as semantics are preserved.

  - Reformulating expressions into logically and mathematically equivalent but syntactically different forms by reordering operations, factoring elements differently, applying distributive or associative laws, using alternative arithmetic sequences, negations, or constant folding variants.

  - Altering formatting dramatically—vary indentation, insert line breaks or join lines, reorder statements where order doesn’t affect outcome—to maximize surface-level textual difference.

  - Transform recursive functions at risk of deep recursion into iterative or tail-recursive variants using explicit stacks or accumulators that guarantee no stack overflow without changing semantics.

- Disallow any **addition or removal of functionality**, or introduction of new language features/paradigms beyond those used in the original pseudocode.

- Remove only code that is provably unreachable or genuinely redundant **if and only if** doing so does not affect externally observable behavior.

- Ensure your output is **syntactically valid pseudocode**, complete, and ready to be parsed/executed in place of the original.

- Your version should be **maximally “orthogonal” (distinct) from the input pseudocode in syntax and structure** while **perfectly preserving semantic equivalence and correctness**.

Remember: The output must contain **only the transformed pseudocode** adhering strictly to the above requirements, with no additional text or explanation.

This rigorous approach ensures that the transformed pseudocode is strikingly different but functionally identical, with all naming and structural constraints precisely enforced.