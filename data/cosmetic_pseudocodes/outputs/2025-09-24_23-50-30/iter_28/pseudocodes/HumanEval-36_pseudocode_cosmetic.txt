```
FUNCTION fizz_buzz(integer_n)
    FUNCTION collect_divisible(accumulator_a, index_b, limit_c)
        IF index_b EQUALS limit_c
            RETURN accumulator_a
        END IF
        SWITCH ( (index_b MODULO 11 EQUALS 0), (index_b MODULO 13 EQUALS 0) )
            CASE (true, _):
                RETURN collect_divisible(accumulator_a CONCATENATED WITH [index_b], index_b + 1, limit_c)
            CASE (_, true):
                RETURN collect_divisible(accumulator_a CONCATENATED WITH [index_b], index_b + 1, limit_c)
            DEFAULT:
                RETURN collect_divisible(accumulator_a, index_b + 1, limit_c)
        END SWITCH
    END FUNCTION

    LIST sequence_d IS collect_divisible([], 0, integer_n)

    FUNCTION accumulate_string(source_list_e, index_f, acc_str_g)
        IF index_f EQUALS LENGTH(source_list_e)
            RETURN acc_str_g
        END IF
        RETURN accumulate_string(
            source_list_e,
            index_f + 1,
            acc_str_g CONCATENATED WITH STRINGIFY(source_list_e[index_f])
        )
    END FUNCTION

    STRING concatenation_h IS accumulate_string(sequence_d, 0, "")

    FUNCTION count_char_occurrences(text_i, position_j, target_k, tally_l)
        IF position_j EQUALS LENGTH(text_i)
            RETURN tally_l
        END IF
        BOOLEAN is_match_m IS (text_i[position_j] EQUALS target_k)
        RETURN count_char_occurrences(
            text_i,
            position_j + 1,
            target_k,
            tally_l + (IF is_match_m THEN 1 ELSE 0)
        )
    END FUNCTION

    RETURN count_char_occurrences(concatenation_h, 0, '7', 0)
END FUNCTION
```