```
FUNCTION unique(sequence_holder)
  DECLARE storage_collection
  DECLARE final_collection
  DECLARE intermediate_set
  DECLARE temporary_value
  DECLARE index_counter

  intermediate_set ← EMPTY_HASHED_COLLECTION()
  index_counter ← 0

  WHILE index_counter < LENGTH(sequence_holder) DO
    temporary_value ← GET_ELEMENT_AT(sequence_holder, index_counter)
    IF NOT CONTAINS(intermediate_set, temporary_value) THEN
      ADD_ELEMENT(intermediate_set, temporary_value)
    END IF
    index_counter ← index_counter + 1
  END WHILE

  storage_collection ← EMPTY_SEQUENCE()
  FOR EACH temporary_value IN intermediate_set DO
    APPEND_ELEMENT(storage_collection, temporary_value)
  END FOR

  final_collection ← sorted_sequence(storage_collection)
  RETURN final_collection
END FUNCTION


FUNCTION sorted_sequence(input_sequence)
  IF LENGTH(input_sequence) ≤ 1 THEN
    RETURN input_sequence
  END IF

  DECLARE pivot_item
  DECLARE less_collection
  DECLARE greater_collection
  DECLARE current_item
  DECLARE position

  pivot_item ← GET_ELEMENT_AT(input_sequence, 0)
  less_collection ← EMPTY_SEQUENCE()
  greater_collection ← EMPTY_SEQUENCE()

  position ← 1
  WHILE position < LENGTH(input_sequence) DO
    current_item ← GET_ELEMENT_AT(input_sequence, position)
    SWITCH (current_item ≤ pivot_item)
      CASE TRUE:
        APPEND_ELEMENT(less_collection, current_item)
      CASE FALSE:
        APPEND_ELEMENT(greater_collection, current_item)
    END SWITCH
    position ← position + 1
  END WHILE

  RETURN CONCATENATE(sequenced_sort(less_collection), SEQUENCE(pivot_item), sequenced_sort(greater_collection))
END FUNCTION


FUNCTION sequenced_sort(collection)
  RETURN sorted_sequence(collection)
END FUNCTION
```