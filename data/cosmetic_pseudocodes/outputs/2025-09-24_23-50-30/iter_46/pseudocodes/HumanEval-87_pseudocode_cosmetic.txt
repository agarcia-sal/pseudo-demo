```
FUNCTION get_row(kappa_lambda, mu)
  LET alpha_beta_gamma = []
  LET delta_zeta = 0
  WHILE delta_zeta <= (LENGTH(kappa_lambda) + (-1))
    LET eta_theta = 0
    WHILE eta_theta <= (LENGTH(kappa_lambda[delta_zeta]) - 1)
      SWITCH NOT(NOT(kappa_lambda[delta_zeta][eta_theta] = mu))
        CASE TRUE:
          alpha_beta_gamma := alpha_beta_gamma + [(delta_zeta, eta_theta)]
        CASE FALSE: 
          ;  // no operation
      END SWITCH
      eta_theta := eta_theta + 1
    END WHILE
    delta_zeta := delta_zeta + 1
  END WHILE

  LET iota = alpha_beta_gamma

  FUNCTION sort_by_second_descending(list_1)
    IF LENGTH(list_1) < 2 THEN
      RETURN list_1
    END IF
    LET pivot = list_1[0]
    LET left_partition = []
    LET right_partition = []
    FOR EACH epsilon IN list_1[1..]
      IF epsilon[2] >= pivot[2] THEN
        left_partition := left_partition + [epsilon]
      ELSE
        right_partition := right_partition + [epsilon]
      END IF
    END FOR
    RETURN sort_by_second_descending(left_partition) + [pivot] + sort_by_second_descending(right_partition)
  END FUNCTION

  LET kappa_lambda = sort_by_second_descending(iota)
  
  FUNCTION sort_by_first_ascending(list_2)
    IF LENGTH(list_2) < 2 THEN
      RETURN list_2
    END IF
    LET pivot = list_2[0]
    LET left_partition = []
    LET right_partition = []
    FOR EACH omega IN list_2[1..]
      IF omega[1] < pivot[1] THEN
        left_partition := left_partition + [omega]
      ELSE
        right_partition := right_partition + [omega]
      END IF
    END FOR
    RETURN sort_by_first_ascending(left_partition) + [pivot] + sort_by_first_ascending(right_partition)
  END FUNCTION

  LET alpha_beta_gamma = sort_by_first_ascending(kappa_lambda)

  RETURN alpha_beta_gamma
END FUNCTION
```