```
FUNCTION sort_even(list_of_elements)
    SET accumulator TO EMPTY LIST
    SET first_subset TO EMPTY LIST
    SET second_subset TO EMPTY LIST
    SET index_counter TO 0

    WHILE index_counter < LENGTH OF list_of_elements DO
        IF index_counter MODULO 2 EQUALS 0 THEN
            APPEND list_of_elements[index_counter] TO first_subset
        ELSE
            APPEND list_of_elements[index_counter] TO second_subset
        END IF
        SET index_counter TO index_counter + 1
    END WHILE

    CALL bubble_sort(first_subset)

    PROCEDURE merge(list_a, list_b, position_a, position_b)
        IF position_a >= LENGTH OF list_a THEN
            IF position_b >= LENGTH OF list_b THEN
                RETURN
            ELSE
                APPEND list_b[position_b] TO accumulator
                CALL merge(list_a, list_b, position_a, position_b + 1)
            END IF
        ELSE IF position_b >= LENGTH OF list_b THEN
            APPEND list_a[position_a] TO accumulator
            CALL merge(list_a, list_b, position_a + 1, position_b)
        ELSE
            APPEND list_a[position_a] TO accumulator
            APPEND list_b[position_b] TO accumulator
            CALL merge(list_a, list_b, position_a + 1, position_b + 1)
        END IF
    END PROCEDURE

    CALL merge(first_subset, second_subset, 0, 0)

    RETURN accumulator
END FUNCTION

PROCEDURE bubble_sort(arr)
    SET n TO LENGTH OF arr
    SET outer TO 0
    WHILE outer < n - 1 DO
        SET inner TO 0
        WHILE inner < n - outer - 1 DO
            IF arr[inner] > arr[inner + 1] THEN
                SET temp TO arr[inner]
                SET arr[inner] TO arr[inner + 1]
                SET arr[inner + 1] TO temp
            END IF
            SET inner TO inner + 1
        END WHILE
        SET outer TO outer + 1
    END WHILE
END PROCEDURE
```