{
  "prompt": "Rewrite the provided pseudocode into a version that preserves exact functional behavior, strictly maintaining original function and class names along with their complete hierarchy and structure, but differs as much as possible in all other respects.\n\nRequirements:\n\n1. **Function and class names must remain identical** with no modification in casing or spelling, and the class/object structure, inheritance, and nesting must exactly match the original.\n\n2. The output must consist solely of valid, self-contained pseudocode that would realistically represent the original logic in an alternative style; no explanations, comments, or extra text may be included.\n\n3. Maximize syntactic and structural divergence by applying extensive transformations, including but not limited to:\n\n   - Convert loops to recursion or recursion to loops, or replace with alternative iteration patterns (e.g., comprehensions, filter/map pipelines).\n   \n   - Replace conditional constructs with logically equivalent but structurally distinct forms (ternary expressions, guard clauses, switch/case variants, nested vs. flat conditions).\n   \n   - Rename all variable and parameter identifiers (except function/class identifiers) to unrelated semantically neutral alternatives, ensuring no conflicts and consistent usage.\n   \n   - Change data structures to analogous but different types (arrays \u2194 lists \u2194 sets, linked structures \u2194 indexed structures) when semantics allow.\n   \n   - Rearrange independent statements, merge or split statements logically, and vary statement ordering where semantic equivalence permits.\n   \n   - Employ logically equivalent but distinct arithmetic or logical expressions (e.g., `x + 1` \u2194 `1 + x`, `!(a AND b)` \u2194 `(!a) OR (!b)`).\n   \n   - Alter formatting extensively: indentation style, line breaks, grouping, spacing, and ordering to contrast with the source.\n   \n   - For recursive methods, if original recursion risks exceeding typical stack limits, prefer iterative solutions or tail-recursive reformulations to avoid overflow while preserving correctness.\n\n   - Remove any unreachable or redundant code only if it does not alter observable behavior.\n\n4. Disallow introducing any constructs or dependencies outside the paradigm and basic idioms represented in the original pseudocode (e.g., no language-specific libraries or features not implied by the pseudocode source).\n\n5. All input-output behavior, side effects, state mutations, and termination properties must be strictly preserved in all cases, with no exceptions.\n\nProduce only the fully transformed pseudocode reflecting the above criteria, optimizing for maximal syntactic and structural novelty while flawlessly maintaining original semantics and correctness.",
  "response": "Rewrite the provided pseudocode into a version that preserves exact functional behavior, strictly maintaining original function and class names along with their complete hierarchy and structure, but differs as much as possible in all other respects.\n\nRequirements:\n\n1. **Function and class names must remain identical** with no modification in casing or spelling, and the class/object structure, inheritance, and nesting must exactly match the original.\n\n2. The output must consist solely of valid, self-contained pseudocode that would realistically represent the original logic in an alternative style; no explanations, comments, or extra text may be included.\n\n3. Maximize syntactic and structural divergence by applying extensive transformations, including but not limited to:\n\n   - Convert loops to recursion or recursion to loops, or replace with alternative iteration patterns (e.g., comprehensions, filter/map pipelines).\n   \n   - Replace conditional constructs with logically equivalent but structurally distinct forms (ternary expressions, guard clauses, switch/case variants, nested vs. flat conditions).\n   \n   - Rename all variable and parameter identifiers (except function/class identifiers) to unrelated semantically neutral alternatives, ensuring no conflicts and consistent usage.\n   \n   - Change data structures to analogous but different types (arrays \u2194 lists \u2194 sets, linked structures \u2194 indexed structures) when semantics allow.\n   \n   - Rearrange independent statements, merge or split statements logically, and vary statement ordering where semantic equivalence permits.\n   \n   - Employ logically equivalent but distinct arithmetic or logical expressions (e.g., `x + 1` \u2194 `1 + x`, `!(a AND b)` \u2194 `(!a) OR (!b)`).\n   \n   - Alter formatting extensively: indentation style, line breaks, grouping, spacing, and ordering to contrast with the source.\n   \n   - For recursive methods, if original recursion risks exceeding typical stack limits, prefer iterative solutions or tail-recursive reformulations to avoid overflow while preserving correctness.\n\n   - Remove any unreachable or redundant code only if it does not alter observable behavior.\n\n4. Disallow introducing any constructs or dependencies outside the paradigm and basic idioms represented in the original pseudocode (e.g., no language-specific libraries or features not implied by the pseudocode source).\n\n5. All input-output behavior, side effects, state mutations, and termination properties must be strictly preserved in all cases, with no exceptions.\n\nProduce only the fully transformed pseudocode reflecting the above criteria, optimizing for maximal syntactic and structural novelty while flawlessly maintaining original semantics and correctness.",
  "score": 0.784794060844284,
  "feedback": "The following are 20 lines of original pseudocode of a random subset of the problems along with their modified pseudocodes.\n\nPseudocode for Problem 1:\n```\nFUNCTION decimal_to_binary(delta)\n  SET bits TO \"\"\n  WHILE delta > 0\n    SET bit TO delta MOD 2\n    SET bits TO (bit AS STRING) + bits\n    SET delta TO delta DIV 2\n  END WHILE\n  RETURN \"db\" + bits + \"db\"\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 1:\n```\nFUNCTION decimal_to_binary(decimal_number)\n    RETURN CONCATENATE \"db\", SUBSTRING OF BINARY REPRESENTATION OF decimal_number FROM INDEX 2 TO END, AND \"db\"\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 1:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpjjircyvr/solution_0.py\", line 11, in <module>\\n    check(decimal_to_binary)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpjjircyvr/solution_0.py\", line 10, in check\\n    assert candidate(0) == \"db0db\"\\nAssertionError\\n']\n\nPseudocode for Problem 2:\n```\nFUNCTION get_positive(sequence_of_values)\n    DECLARE positive_collection AS SET\n    ASSIGN positive_collection TO EMPTY SET\n    FOR EACH item IN sequence_of_values DO\n        IF 0 < item THEN\n            ADD item TO positive_collection\n        END IF\n    END FOR\n    RETURN CONVERT positive_collection TO LIST\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 2:\n```\nFUNCTION get_positive(list_of_numbers)\n    RETURN list_of_elements FROM list_of_numbers WHERE element IS GREATER THAN 0\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 2:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp78wojrm8/solution_1.py\", line 12, in <module>\\n    check(get_positive)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp78wojrm8/solution_1.py\", line 11, in check\\n    assert candidate([5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]) == [5, 3, 2, 3, 3, 9, 123, 1]\\nAssertionError\\n']\n\nPseudocode for Problem 3:\n```\nFUNCTION all_prefixes(alpha)\n    DEFINE collector AS empty sequence\n    DEFINE collector = fold_left(range(1, length(alpha) + 1), collector, (accum, pos) => accum union {substring(alpha, 0, pos)})\n    RETURN collector\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 3:\n```\nFUNCTION all_prefixes(input_string)\n    SET result_list TO empty list\n    FOR each index FROM 0 TO LENGTH OF input_string MINUS 1\n        APPEND SUBSTRING OF input_string FROM START TO index PLUS 1 TO result_list\n    RETURN result_list\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 3:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpyi0zxn83/solution_0.py\", line 11, in <module>\\n    check(all_prefixes)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpyi0zxn83/solution_0.py\", line 10, in check\\n    assert candidate(\\'\\') == []\\nAssertionError\\n']\n\nPseudocode for Problem 4:\n```\nFUNCTION car_race_collision(quantity_cars)\n    VARIABLE product_result := 1\n    FOR index FROM 1 TO quantity_cars DO\n        product_result := product_result * quantity_cars\n    END FOR\n    RETURN product_result\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 4:\n```\nFUNCTION car_race_collision(integer_number_of_cars)\n    RETURN integer_number_of_cars RAISED TO THE POWER OF 2\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 4:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpjjcmzhk4/solution_1.py\", line 9, in <module>\\n    check(car_race_collision)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpjjcmzhk4/solution_1.py\", line 8, in check\\n    assert candidate(3) == 9\\nAssertionError\\n']\n\nPseudocode for Problem 5:\n```\nFUNCTION get_closest_vowel(term)\n    DEFINE chars = { \"A\", \"E\", \"I\", \"O\", \"U\", \"a\", \"e\", \"i\", \"o\", \"u\" }\n    IF 2 >= LENGTH(term)\n        RETURN \"\"\n    END IF\n\n    DEFINE PROCEDURE scan(i)\n        IF i < 2 THEN\n            RETURN \"\"\n        ELSE IF term[i] IN chars THEN\n            IF (term[i+1] NOT IN chars) AND (term[i-1] NOT IN chars) THEN\n                RETURN term[i]\n            ELSE\n                RETURN scan(i - 1)\n            END IF\n        ELSE\n            RETURN scan(i - 1)\n        END IF\n    END PROCEDURE\n\nModified Pseudocode for Problem 5:\n```\nFUNCTION get_closest_vowel(word)\n    IF LENGTH OF word IS LESS THAN 3\n        RETURN empty string\n    END IF\n\n    SET vowels TO SET OF {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"O\", \"U\", \"I\"}\n\n    FOR index FROM LENGTH OF word MINUS 2 DOWNTO 1 STEP -1\n        IF word AT position index IS IN vowels\n            IF word AT position index PLUS 1 IS NOT IN vowels AND word AT position index MINUS 1 IS NOT IN vowels\n                RETURN word AT position index\n            END IF\n        END IF\n    END FOR\n\n    RETURN empty string\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 5:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp2km0m_oy/solution_1.py\", line 21, in <module>\\n    check(get_closest_vowel)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp2km0m_oy/solution_1.py\", line 20, in check\\n    assert candidate(\"full\") == \"u\"\\nAssertionError\\n']\n\nPseudocode for Problem 6:\n```\nFUNCTION numerical_letter_grade(weights)\n  INITIALIZE marks TO new empty set\n  SET index TO 0\n  WHILE index < LENGTH(weights)\n    DEFINE score AS weights[index]\n    ASSIGN letter =\n      SWITCH TRUE\n        CASE score == 4.0: \"A+\"\n        CASE score > 3.7: \"A\"\n        CASE score > 3.3: \"A-\"\n        CASE score > 3.0: \"B+\"\n        CASE score > 2.7: \"B\"\n        CASE score > 2.3: \"B-\"\n        CASE score > 2.0: \"C+\"\n        CASE score > 1.7: \"C\"\n        CASE score > 1.3: \"C-\"\n        CASE score > 1.0: \"D+\"\n        CASE score > 0.7: \"D\"\n        CASE score > 0.0: \"D-\"\n\nModified Pseudocode for Problem 6:\n```\nFUNCTION numerical_letter_grade(list_of_grades)\n    SET letter_grade_list TO empty list\n    FOR each grade_point_average IN list_of_grades\n        IF grade_point_average EQUALS 4.0\n            APPEND \"A+\" TO letter_grade_list\n        ELSE IF grade_point_average GREATER THAN 3.7\n            APPEND \"A\" TO letter_grade_list\n        ELSE IF grade_point_average GREATER THAN 3.3\n            APPEND \"A-\" TO letter_grade_list\n        ELSE IF grade_point_average GREATER THAN 3.0\n            APPEND \"B+\" TO letter_grade_list\n        ELSE IF grade_point_average GREATER THAN 2.7\n            APPEND \"B\" TO letter_grade_list\n        ELSE IF grade_point_average GREATER THAN 2.3\n            APPEND \"B-\" TO letter_grade_list\n        ELSE IF grade_point_average GREATER THAN 2.0\n            APPEND \"C+\" TO letter_grade_list\n        ELSE IF grade_point_average GREATER THAN 1.7\n            APPEND \"C\" TO letter_grade_list\n\nError(s) from the decoded code for Problem 6:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp2wklqyza/solution_0.py\", line 40, in <module>\\n    check(numerical_letter_grade)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp2wklqyza/solution_0.py\", line 39, in check\\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == [\\'A+\\', \\'B\\', \\'C-\\', \\'C\\', \\'A-\\']\\nAssertionError\\n']\n\nPseudocode for Problem 7:\n```\nFUNCTION solve(num)\n    LET acc = 0\n    LET chars = CharArrayFromString(StringFromNumber(num))\n    LET index = 0\n\n    WHILE index < Length(chars)\n        LET ch = chars[index]\n        LET acc = acc + ToNumber(ch)\n        LET index = index + 1\n    END WHILE\n\n    LET binStr = ConvertToBinary(acc)\n    LET result = Substring(binStr, 3, Length(binStr))\n    \n    RETURN result\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 7:\n```\nFUNCTION solve(integer_N)\n    SET sum_of_digits TO 0\n    FOR each character_digit IN STRING REPRESENTATION OF integer_N\n        INCREMENT sum_of_digits BY INTEGER VALUE OF character_digit\n    SET binary_representation TO BINARY STRING OF sum_of_digits EXCLUDING THE FIRST TWO CHARACTERS\n    RETURN binary_representation\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 7:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmprld5ta7i/solution_0.py\", line 19, in <module>\\n    check(solve)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmprld5ta7i/solution_0.py\", line 18, in check\\n    assert candidate(150) == \"110\", \"Error\"\\nAssertionError: Error\\n']\n\nPseudocode for Problem 8:\n```\nFUNCTION is_happy(data_flag)\n    IF NOT (3 <= LENGTH(data_flag))\n        RETURN False\n    SET cursor TO 1\n    WHILE cursor <= LENGTH(data_flag) - 2\n        SET chA TO data_flag[cursor]\n        SET chB TO data_flag[cursor + 1]\n        SET chC TO data_flag[cursor + 2]\n        IF (chA = chB) OR (chB = chC) OR (chA = chC)\n            RETURN False\n        SET cursor TO cursor + 1\n    END WHILE\n    RETURN True\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 8:\n```\nFUNCTION is_happy(string_input)\n    IF LENGTH OF string_input IS LESS THAN 3\n        RETURN False\n    FOR index FROM 0 TO LENGTH OF string_input MINUS 3 INCLUSIVE\n        IF character AT string_input[index] EQUALS character AT string_input[index + 1]\n           OR character AT string_input[index + 1] EQUALS character AT string_input[index + 2]\n           OR character AT string_input[index] EQUALS character AT string_input[index + 2]\n            RETURN False\n    RETURN True\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 8:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpcpqz1d6o/solution_2.py\", line 18, in <module>\\n    check(is_happy)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpcpqz1d6o/solution_2.py\", line 17, in check\\n    assert candidate(\"abcd\") == True , \"abcd\"\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpcpqz1d6o/solution_2.py\", line 11, in is_happy\\n    chC = data_flag[cursor + 2]\\nIndexError: string index out of range\\n']\nScore of Passing Rate - BLEU Score for ALL the problems: 0.784794060844284"
}