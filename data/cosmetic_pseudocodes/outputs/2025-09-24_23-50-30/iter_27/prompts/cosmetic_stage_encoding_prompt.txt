Rewrite the given pseudocode into a semantically equivalent version that preserves **exactly the same external behavior, side-effects, input-output contracts, termination conditions, function names, class names, and their complete nesting/class/object/inheritance hierarchy exactly as in the original** (including letter casing and spelling). Do **NOT** change any function or class identifiers or their positions in the structure.

Your output must consist **only** of **valid, self-contained pseudocode**, with no explanations, comments, or anything other than the rewritten pseudocode.

**Mandatory transformation requirements** (maximize syntactic, lexical, and structural divergence while strictly preserving semantics):

1. **Rename all non-class-function identifiers** (variables, parameters, constants, temporaries) to fresh, unrelated, semantically neutral names; maintain consistency and scope correctness; avoid collisions with function/class names or reserved terms.

2. **Control flow re-expressions**:
   - Replace `for` loops with equivalent `while` loops, recursion, tail recursion, comprehensions, map/filter pipelines, or other logically identical flow structures and vice versa.
   - Transform `if-else` → `switch/case` statements or vice versa; use nested conditionals, ternary-style guarded expressions, De Morgan’s law and equivalent boolean rearrangements.
   - Restructure condition expressions to logically equivalent forms, including rearrangements, simplifications, expansions, or alternatives that preserve exact truth tables.

3. **Data structure substitutions**:
   - Convert between sets, lists, arrays, linked lists, dictionaries, or other equivalent structures where semantics allow, preserving data semantics and operations exactly.
   - Represent collections or sequences with alternative but behaviorally identical data formats if feasible.

4. **Code restructuring**:
   - Split, merge, reorder independent statements or blocks in ways that do not affect the semantics.
   - Factor out or inline expressions and statements equivalently.
   - Convert tail-recursive functions to iterative ones to avoid excessive recursion, or vice versa, preserving correctness and termination.
   - Remove unreachable or redundant code fragments only if they do not affect the observable behavior.

5. **Expression rewrites**:
   - Apply algebraic, arithmetic, and logical identities (e.g., commutativity, associativity, distributivity, De Morgan’s, double negation) to rewrite expressions.
   - Transform constants folding/unfolding or equivalent constant replacements.
   - Change order of operations with parentheses as needed to differ syntactically but maintain semantic equality.

6. **Formatting and syntax variations**:
   - Vary indentation styles, line breaks, statement grouping, and whitespace aggressively.
   - Use synonymous keywords or language constructs allowed within the same pseudocode paradigm but adopt diverse idiomatic expressions.

**Prohibitions**:

- Do not introduce or remove any functions, classes, or hierarchy levels.
- Do not change spelling or casing of function or class identifiers, nor their structural positions.
- Do not add external library imports or new language features beyond what original pseudocode implies.
- Do not include any explanations, text, comments, or annotations—not even as pseudocode comments.

The final result should be a maximally transformed, orthogonal pseudocode version of the input that passes all semantic equivalence and correctness tests while appearing substantially different in form and style.