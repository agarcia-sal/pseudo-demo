Rewrite the input pseudocode to generate a new, fully functionally equivalent version that strictly meets all these conditions:

- Preserve every aspect of functionality **exactly**, including all behaviors, side effects, input-output relationships, termination guarantees, and correctness — no change permitted.

- Retain **all original function and class names exactly as they appear**, including casing, spelling, and nesting within classes or objects, preserving inheritance hierarchies and structural organization precisely.

- Replace **all other identifiers** — such as local variables, parameters, constants, temporaries — with new, unrelated, semantically neutral names that are unique in their scope and used consistently throughout.

- Produce output containing **only valid, complete pseudocode** representing the same program; do **not** add comments, explanations, or any extraneous text.

- Maximize *syntactic, structural, and stylistic divergence* from the input by applying a rich combination of diverse transformations, such as (but not limited to):

  - Transform iterative loops into recursive, tail-recursive, or iterator-based constructions and vice versa, while preserving performance and avoiding recursion depth issues.

  - Restructure control flow massively, e.g., replace if-else chains with switch/case, pattern matching, nested guards, logic expression rewrites using De Morgan’s laws or boolean algebra, ternary operations, or equivalent alternative conditions.

  - Change data structure representations to equivalent formats when valid (for example, interchange lists, arrays, sets, or maps), without changing observable behavior.

  - Reorder, fuse, or split blocks and statements arbitrarily whenever their rearrangement does not alter semantics.

  - Rewrite expressions into logically equivalent but syntactically distinct forms—change arithmetic order, factor differently, adjust boolean negations or conditionals, and perform alternate constant folding.

  - Vary formatting drastically — indentation, line breaks, spacing, and statement ordering—to increase surface-level novelty.

  - Convert recursive functions subject to deep recursion into iterative or stack-safe tail-recursive equivalents to prevent stack overflow, preserving semantics exactly.

  - Where possible, apply advanced transformations that respect variable scopes and lifetimes to maximize novelty without sacrificing correctness.

  - Remove code only if it is statically unreachable or provably redundant and doing so has no impact on external behavior.

- Do **not** add, remove, or modify any functionality, algorithmic complexity, or introduce any new language features beyond those present in the original pseudocode.

Your output must be **only the transformed pseudocode** strictly adhering to these constraints, ensuring maximal divergence from the input while perfectly preserving semantics, naming of functions/classes, and correctness guarantees.