```
FUNCTION unique_digits(sequence_of_pos_ints)
    FUNCTION all_digits_odd(number)
        FUNCTION check_digits(num, flag)
            IF num == 0 THEN
                RETURN flag
            ENDIF
            LET remainder BE num MOD 10
            RETURN check_digits(num DIV 10, flag AND (remainder MOD 2 != 0))
        ENDFUNCTION
        RETURN check_digits(number, TRUE)
    ENDFUNCTION

    LET collected_odd_digit_items BE []
    PROCEDURE iterate_items(index)
        IF index >= LENGTH(sequence_of_pos_ints) THEN
            RETURN
        ENDIF
        LET current_item BE sequence_of_pos_ints[index]
        IF all_digits_odd(current_item) THEN
            collected_odd_digit_items := collected_odd_digit_items + [current_item]
        ENDIF
        iterate_items(index + 1)
    ENDPROCEDURE

    iterate_items(0)

    FUNCTION merge_sort(arr)
        LET n BE LENGTH(arr)
        IF n <= 1 THEN RETURN arr ENDIF
        LET midpoint BE n DIV 2
        LET left_part BE merge_sort(arr[0:midpoint])
        LET right_part BE merge_sort(arr[midpoint:n])
        RETURN merge(left_part, right_part)
    ENDFUNCTION

    FUNCTION merge(left_arr, right_arr)
        LET acc_be_sorted BE []
        LET i BE 0
        LET j BE 0
        WHILE i < LENGTH(left_arr) AND j < LENGTH(right_arr)
            IF left_arr[i] <= right_arr[j] THEN
                acc_be_sorted := acc_be_sorted + [left_arr[i]]
                i := i + 1
            ELSE
                acc_be_sorted := acc_be_sorted + [right_arr[j]]
                j := j + 1
            ENDIF
        ENDWHILE
        RETURN acc_be_sorted + left_arr[i:] + right_arr[j:]
    ENDFUNCTION

    RETURN merge_sort(collected_odd_digit_items)
END FUNCTION
```