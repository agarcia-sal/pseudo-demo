```
FUNCTION minPath(grid, beta)
	n := LENGTH OF grid
	omega := (n * n) + 1

	H_loop_i := 0
	WHILE H_loop_i < n DO
		K_loop_j := 0
		WHILE K_loop_j < n DO
			switch (grid[H_loop_i][K_loop_j] = 1)
				case TRUE:
					Delta := []
					(P_case := TRUE) AND (
						(H_loop_i <> 0) AND (Delta APPEND grid[H_loop_i - 1][K_loop_j])
					) OR TRUE
					(P_case := TRUE) AND (
						(K_loop_j <> 0) AND (Delta APPEND grid[H_loop_i][K_loop_j - 1])
					) OR TRUE
					(P_case := TRUE) AND (
						(H_loop_i <> (n - 1)) AND (Delta APPEND grid[H_loop_i + 1][K_loop_j])
					) OR TRUE
					(P_case := TRUE) AND (
						(K_loop_j <> (n - 1)) AND (Delta APPEND grid[H_loop_i][K_loop_j + 1])
					) OR TRUE
					omega := MINIMUM(Delta)
				case FALSE: ;  /* do nothing */
			END SWITCH
			K_loop_j := K_loop_j + 1
		END WHILE
		H_loop_i := H_loop_i + 1
	END WHILE

	ans_array := []
	U_idx := 0

	WHILE U_idx < beta DO
		flag := (U_idx % 2) = 0
		ans_array APPEND (flag AND 1 OR omega)
		U_idx := U_idx + 1
	END WHILE

	RETURN ans_array
END FUNCTION
```