```
FUNCTION pluck(array_of_nodes)
    DEFINE FUNCTION find_minimum(elems, idx_accum, smallest_val, smallest_idx)
        IF idx_accum EQUALS LENGTH OF elems THEN
            RETURN (smallest_val, smallest_idx)
        ELSE
            DEFINE current_elem AS elems[idx_accum]
            IF current_elem LESS THAN smallest_val THEN
                RETURN find_minimum(elems, idx_accum + 1, current_elem, idx_accum)
            ELSE
                RETURN find_minimum(elems, idx_accum + 1, smallest_val, smallest_idx)
            END IF
        END IF
    END FUNCTION

    DEFINE FUNCTION filter_evens(collection, pos, result_acc)
        IF pos EQUALS LENGTH OF collection THEN
            RETURN result_acc
        ELSE
            DEFINE candidate AS collection[pos]
            IF (candidate MOD 2) EQUALS 0 THEN
                RETURN filter_evens(collection, pos + 1, result_acc + [candidate])
            ELSE
                RETURN filter_evens(collection, pos + 1, result_acc)
            END IF
        END IF
    END FUNCTION

    DEFINE FUNCTION locate_index(container, item, pointer)
        IF pointer EQUALS LENGTH OF container THEN
            RETURN -1
        ELSEIF container[pointer] EQUALS item THEN
            RETURN pointer
        ELSE
            RETURN locate_index(container, item, pointer + 1)
        END IF
    END FUNCTION

    IF NOT (LENGTH(array_of_nodes) GREATER THAN 0) THEN
        RETURN []
    END IF

    DEFINE evens AS filter_evens(array_of_nodes, 0, [])

    IF NOT (LENGTH(evens) GREATER THAN 0) THEN
        RETURN []
    END IF

    DEFINE (min_even, _) AS find_minimum(evens, 0, evens[0], 0)
    DEFINE index_min_even AS locate_index(array_of_nodes, min_even, 0)

    RETURN [min_even, index_min_even]
END FUNCTION
```