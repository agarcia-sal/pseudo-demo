```
FUNCTION max_fill(grid, capacity)
    IMPORT math
    PROCEDURE accumulate_rows(inputGrid, idx, acc, outList)
        IF idx >= LENGTH(inputGrid) THEN
            RETURN outList
        ELSE
            LET current_row = inputGrid[idx]
            LET total = 0
            PROCEDURE sum_elements(elements, pos, result)
                IF pos >= LENGTH(elements) THEN
                    RETURN result
                ELSE
                    RETURN sum_elements(elements, pos + 1, result + elements[pos])
            END PROCEDURE
            LET rowSum = sum_elements(current_row, 0, 0)
            RETURN accumulate_rows(inputGrid, idx + 1, acc, outList + [rowSum])
        END IF
    END PROCEDURE

    PROCEDURE ceiling_sum(values, pos, totalAcc)
        IF pos >= LENGTH(values) THEN
            RETURN totalAcc
        ELSE
            LET val = values[pos]
            LET divided = val / capacity
            LET ceilVal = (INTEGER(divided) + 1) * (divided <> INTEGER(divided)) + INTEGER(divided) * (divided = INTEGER(divided))
            RETURN ceiling_sum(values, pos + 1, totalAcc + ceilVal)
        END IF
    END PROCEDURE

    LET row_totals = accumulate_rows(grid, 0, 0, [])
    RETURN ceiling_sum(row_totals, 0, 0)
END FUNCTION
```