CLASS Solution  
    FUNCTION maxMoves(kx, ky, positions)  
        DEFINE knight_dirs AS [(2,1),(2,-1),(-2,1),(-2,-1),(1,2),(1,-2),(-1,2),(-1,-2)]  
        DECLARE pawns_set AS EMPTY SET  
        SET idx TO 0  
        WHILE idx LESS THAN LENGTH(positions) DO  
            INSERT (positions[idx][0], positions[idx][1]) INTO pawns_set  
            SET idx TO idx + 1  
        END WHILE  
        SET total_pawns TO SIZE(pawns_set)  
        
        FUNCTION dp(kx, ky, mask, is_alice)  
            IF mask EQUALS 0 THEN  
                RETURN 0  
            ELSE  
                PASS  
            END IF  
            
            IF is_alice EQUALS True THEN  
                DECLARE best_value AS 0  
            ELSE  
                DECLARE best_value AS +âˆž  
            END IF  
            
            SET i TO 0  
            REPEAT  
                IF i GREATER OR EQUAL total_pawns THEN  
                    BREAK  
                END IF  
                SET bit_check TO (1 << i)  
                IF (mask & bit_check) NOT EQUAL 0 THEN  
                    SET target_x TO positions[i][0]  
                    SET target_y TO positions[i][1]  
                    
                    DECLARE bfs_queue AS LIST WITH SINGLE ELEMENT (kx, ky, 0)  
                    DECLARE visited_positions AS SET WITH (kx, ky)  
                    DECLARE reached AS False  
                    
                    LOOP WHILE LENGTH(bfs_queue) GREATER THAN 0  
                        SET (curr_x, curr_y, dist) TO bfs_queue[0]  
                        REMOVE bfs_queue[0]  
                        
                        IF curr_x EQUALS target_x AND curr_y EQUALS target_y THEN  
                            SET reached TO True  
                            BREAK  
                        END IF  
                        
                        FOR EACH (dx, dy) IN knight_dirs DO  
                            SET next_x TO curr_x + dx  
                            SET next_y TO curr_y + dy  
                            IF 0 <= next_x AND next_x < 50 AND 0 <= next_y AND next_y < 50 THEN  
                                IF NOT ((next_x, next_y) IN visited_positions) THEN  
                                    INSERT (next_x, next_y) INTO visited_positions  
                                    APPEND (next_x, next_y, dist + 1) TO bfs_queue  
                                END IF  
                            END IF  
                        END FOR  
                    END LOOP  
                    
                    IF reached EQUALS True THEN  
                        SET updated_mask TO mask ^ bit_check  
                        SET alt_value TO dist + dp(target_x, target_y, updated_mask, NOT is_alice)  
                        IF is_alice EQUALS True THEN  
                            IF best_value < alt_value THEN  
                                SET best_value TO alt_value  
                            END IF  
                        ELSE  
                            IF best_value > alt_value THEN  
                                SET best_value TO alt_value  
                            END IF  
                        END IF  
                    END IF  
                END IF  
                SET i TO i + 1  
            UNTIL FALSE  
            
            RETURN best_value  
        END FUNCTION  
        
        SET initial_mask TO (1 << total_pawns) - 1  
        RETURN dp(kx, ky, initial_mask, True)  
    END FUNCTION  
END CLASS