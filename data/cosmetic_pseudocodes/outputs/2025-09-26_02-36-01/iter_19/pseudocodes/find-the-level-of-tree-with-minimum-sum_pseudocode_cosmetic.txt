CLASS TreeNode  
    FUNCTION __init__(self COMMA delta EQUALS zero COMMA alpha EQUALS None COMMA beta EQUALS None)  
        SET self.val TO delta  
        SET self.left TO alpha  
        SET self.right TO beta  
    END FUNCTION  
END CLASS  

FUNCTION tree_node(omega)  
    IF omega EQUALS empty THEN  
        RETURN None  
    ELSE  
        SET chi TO one  
        SET sigma TO new deque  
        SET psi TO new TreeNode with value equal to element at position one of omega  
        APPEND psi TO sigma  
        LABEL start_loop:  
        WHILE LENGTH of sigma GREATER THAN zero  
            SET epsilon TO element removed from the left side of sigma  
            IF chi LESS THAN LENGTH of omega THEN  
                IF NOT (omega[chi] EQUALS None) THEN  
                    SET epsilon.left TO new TreeNode with value equal to omega[chi]  
                    APPEND epsilon.left TO sigma  
                END IF  
                SET chi TO chi + one  
            END IF  
            IF chi LESS THAN LENGTH of omega THEN  
                IF NOT (omega[chi] EQUALS None) THEN  
                    SET epsilon.right TO new TreeNode with value equal to omega[chi]  
                    APPEND epsilon.right TO sigma  
                END IF  
                SET chi TO chi + one  
            END IF  
        END WHILE  
        RETURN psi  
    END IF  
END FUNCTION  

FUNCTION is_same_tree(alpha COMMA beta)  
    SET result_flag TO False  
    IF (alpha EQUALS None) AND (beta EQUALS None) THEN  
        SET result_flag TO True  
    ELSE  
        IF (alpha EQUALS None) OR (beta EQUALS None) THEN  
            SET result_flag TO False  
        ELSE  
            IF NOT (alpha.val EQUALS beta.val) THEN  
                SET result_flag TO False  
            ELSE  
                SET result_flag TO (is_same_tree(alpha.left COMMA beta.left) AND is_same_tree(alpha.right COMMA beta.right))  
            END IF  
        END IF  
    END IF  
    RETURN result_flag  
END FUNCTION  

CLASS Solution  
    FUNCTION minimumLevel(self COMMA root)  
        IF root EQUALS None THEN  
            RETURN zero  
        ELSE  
            SET queue_store TO new deque initialized with root  
            SET minimum_level TO one  
            SET minimum_sum TO positive infinity  
            SET current_layer TO one  
            LABEL check_loop:  
            WHILE LENGTH of queue_store GREATER THAN zero  
                SET aggregate_sum TO zero  
                FOR index_var FROM one TO LENGTH of queue_store  
                    SET current_node TO element removed from the left side of queue_store  
                    SET aggregate_sum TO aggregate_sum + current_node.val  
                    IF current_node.left NOT EQUALS None THEN  
                        APPEND current_node.left TO queue_store  
                    END IF  
                    IF current_node.right NOT EQUALS None THEN  
                        APPEND current_node.right TO queue_store  
                    END IF  
                END FOR  
                IF aggregate_sum LESS THAN minimum_sum THEN  
                    SET minimum_sum TO aggregate_sum  
                    SET minimum_level TO current_layer  
                END IF  
                SET current_layer TO current_layer + one  
            END WHILE  
            RETURN minimum_level  
        END IF  
    END FUNCTION  
END CLASS