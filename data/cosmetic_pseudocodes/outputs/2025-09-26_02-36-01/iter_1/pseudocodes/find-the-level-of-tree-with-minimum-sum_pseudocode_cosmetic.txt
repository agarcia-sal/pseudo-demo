CLASS TreeNode  
    FUNCTION __init__(self COMMA val EQUALS 0 COMMA left EQUALS None COMMA right EQUALS None)  
        self.val = val  
        self.left = left  
        self.right = right  
    END FUNCTION  
END CLASS  

FUNCTION tree_node(values)  
    IF values IS empty THEN  
        RETURN None  
    END IF  
    root = TreeNode(values[0])  
    queue = new deque containing root  
    index = 1  
    WHILE queue NOT empty DO  
        current = dequeue from left of queue  
        IF index < length of values AND values[index] IS NOT None THEN  
            current.left = TreeNode(values[index])  
            enqueue current.left to queue  
        END IF  
        index = index + 1  
        IF index < length of values AND values[index] IS NOT None THEN  
            current.right = TreeNode(values[index])  
            enqueue current.right to queue  
        END IF  
        index = index + 1  
    END WHILE  
    RETURN root  
END FUNCTION  

FUNCTION is_same_tree(p COMMA q)  
    IF p IS None AND q IS None THEN  
        RETURN True  
    END IF  
    IF p IS None OR q IS None THEN  
        RETURN False  
    END IF  
    IF p.val != q.val THEN  
        RETURN False  
    END IF  
    left_check = is_same_tree(p.left COMMA q.left)  
    right_check = is_same_tree(p.right COMMA q.right)  
    RETURN left_check AND right_check  
END FUNCTION  

CLASS Solution  
    FUNCTION minimumLevel(self COMMA root)  
        IF root IS None THEN  
            RETURN 0  
        END IF  
        queue = deque initialized with root  
        minimal_level = 1  
        minimal_sum = infinity  
        current_level = 1  
        WHILE queue NOT empty DO  
            current_sum = 0  
            level_size = length of queue  
            FOR counter FROM 1 TO level_size DO  
                node = dequeue from left of queue  
                current_sum = current_sum + node.val  
                IF node.left IS NOT None THEN  
                    enqueue node.left to queue  
                END IF  
                IF node.right IS NOT None THEN  
                    enqueue node.right to queue  
                END IF  
            END FOR  
            IF current_sum < minimal_sum THEN  
                minimal_sum = current_sum  
                minimal_level = current_level  
            END IF  
            current_level = current_level + 1  
        END WHILE  
        RETURN minimal_level  
    END FUNCTION  
END CLASS