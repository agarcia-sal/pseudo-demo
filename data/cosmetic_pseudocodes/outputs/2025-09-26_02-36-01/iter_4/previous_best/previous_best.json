{
  "prompt": "Given an input pseudocode, produce a rewritten version of the pseudocode that meets all these criteria:\n\n- Fully preserves the original functionality exactly.\n- Maintains all original class names, function names, method signatures, and their class/object hierarchy without any change.\n- Changes all other aspects as thoroughly as possible to maximize syntactic and structural difference:\n  - Rewrite control flows with alternate constructs if possible (e.g., replace FOR loops with WHILE loops or vice versa, unfold or fold compound statements).\n  - Use different but semantically equivalent variable names (avoid original variable names except for the required class and function names).\n  - Reorder statements where order is not semantically significant.\n  - Replace arithmetic, conditional expressions, and data structure accesses with alternative formulations or synonyms (e.g., spelled-out math operations, alternate indexing styles, logical inversions).\n  - Use varied formatting, avoid replicating the original variable declaration style (e.g., use different assignment keywords, different ways to express increments or loops).\n  - Express constants, literals, and data structures differently but equivalently.\n  - Introduce helper intermediate variables or break down complex expressions into multiple steps differently.\n- Avoid adding any explanation, comments, or output other than the newly rewritten pseudocode.\n- Output only the rewritten pseudocode and nothing else.\n\nThis prompt must apply universally, to any pseudocode input, irrespective of problem domain or content. Your rewritten pseudocode must appear as an independently authored alternative version, maximizing difference while guaranteeing full semantic equivalence and preserving original class and function names precisely as in the input.",
  "response": "Given an input pseudocode, produce a rewritten version of the pseudocode that meets all these criteria:\n\n- Fully preserves the original functionality exactly.\n- Maintains all original class names, function names, method signatures, and their class/object hierarchy without any change.\n- Changes all other aspects as thoroughly as possible to maximize syntactic and structural difference:\n  - Rewrite control flows with alternate constructs if possible (e.g., replace FOR loops with WHILE loops or vice versa, unfold or fold compound statements).\n  - Use different but semantically equivalent variable names (avoid original variable names except for the required class and function names).\n  - Reorder statements where order is not semantically significant.\n  - Replace arithmetic, conditional expressions, and data structure accesses with alternative formulations or synonyms (e.g., spelled-out math operations, alternate indexing styles, logical inversions).\n  - Use varied formatting, avoid replicating the original variable declaration style (e.g., use different assignment keywords, different ways to express increments or loops).\n  - Express constants, literals, and data structures differently but equivalently.\n  - Introduce helper intermediate variables or break down complex expressions into multiple steps differently.\n- Avoid adding any explanation, comments, or output other than the newly rewritten pseudocode.\n- Output only the rewritten pseudocode and nothing else.\n\nThis prompt must apply universally, to any pseudocode input, irrespective of problem domain or content. Your rewritten pseudocode must appear as an independently authored alternative version, maximizing difference while guaranteeing full semantic equivalence and preserving original class and function names precisely as in the input.",
  "score": -0.10095863001512134,
  "feedback": "The following are 20 lines of original pseudocode of a random subset of the problems along with their modified pseudocodes.\n\nPseudocode for Problem 1:\nCLASS Solution\n    FUNCTION maxPointsInsideSquare(points s)\n        LET total_points BE LENGTH s\n        LET highest_count BE 0\n        LET index_i BE 0\n        WHILE index_i < total_points DO\n            LET coordinate_x BE s[index_i][0]\n            LET coordinate_y BE s[index_i][1]\n            \n            LET absolute_x BE coordinate_x\n            IF absolute_x < 0 THEN\n                absolute_x = 0 - absolute_x\n            END IF\n\n            LET absolute_y BE coordinate_y\n            IF absolute_y < 0 THEN\n                absolute_y = 0 - absolute_y\n            END IF\n\n            LET square_edge BE absolute_x\n\nModified Pseudocode for Problem 1:\nCLASS Solution  \n    FUNCTION maxPointsInsideSquare(points s)  \n        SET n TO the LENGTH OF points  \n        SET max_points TO zero  \n        FOR i FROM zero TO n MINUS one  \n            SET x1 TO element at position zero of element at position i of points  \n            SET y1 TO element at position one of element at position i of points  \n            SET side_length TO the GREATER OF the ABSOLUTE VALUE OF x1 AND the ABSOLUTE VALUE OF y1  \n            SET tag_count TO an empty dictionary  \n            SET valid_square TO true  \n            FOR j FROM zero TO n MINUS one  \n                SET x2 TO element at position zero of element at position j of points  \n                SET y2 TO element at position one of element at position j of points  \n                IF the ABSOLUTE VALUE OF x2 IS LESS THAN OR EQUAL TO side_length AND the ABSOLUTE VALUE OF y2 IS LESS THAN OR EQUAL TO side_length THEN  \n                    SET tag TO element at position j of s  \n                    IF tag EXISTS IN tag_count THEN  \n                        SET valid_square TO false  \n                        BREAK  \n                    ELSE  \n                        SET element with key tag IN tag_count TO true  \n\nPseudocode for Problem 2:\nCLASS Solution  \n    FUNCTION maxScore(grid)  \n        LET height BE LENGTH(grid)  \n        LET width BE LENGTH(grid[0])  \n        LET dp TABLE BE a list of height ELEMENTS each INITIALIZED TO a list of width ELEMENTS all set to +\u221e  \n        dp[0][0] \u2190 grid[0][0]  \n        LET best_score BE -\u221e  \n        \n        LET col_idx BE 1  \n        WHILE col_idx < width  \n            dp[0][col_idx] \u2190 MIN(dp[0][col_idx - 1], grid[0][col_idx])  \n            col_idx \u2190 col_idx + 1  \n        END WHILE  \n        \n        LET row_idx BE 1  \n        WHILE row_idx < height  \n            dp[row_idx][0] \u2190 MIN(dp[row_idx - 1][0], grid[row_idx][0])  \n            row_idx \u2190 row_idx + 1  \n        END WHILE  \n        \n\nModified Pseudocode for Problem 2:\nCLASS Solution  \n    FUNCTION maxScore(grid)  \n        SET m TO the LENGTH OF grid  \n        SET n TO the LENGTH OF element at position zero of grid  \n        SET dp TO a list containing m elements each of which is a list containing n elements each set TO positive infinity  \n        SET element at position zero of element at position zero of dp TO element at position zero of element at position zero of grid  \n        SET max_score TO negative infinity  \n        \n        FOR j FROM one TO n MINUS one  \n            SET element at position j of element at position zero of dp TO the lesser value BETWEEN element at position j MINUS one of element at position zero of dp AND element at position j of element at position zero of grid  \n        END FOR  \n        \n        FOR i FROM one TO m MINUS one  \n            SET element at position i of element at position zero of dp TO the lesser value BETWEEN element at position i MINUS one of element at position zero of dp AND element at position i of element at position zero of grid  \n        END FOR  \n        \n        FOR i FROM one TO m MINUS one  \n            FOR j FROM one TO n MINUS one  \n                SET element at position j of element at position i of dp TO the lesser value BETWEEN element at position j of element at position i MINUS one of dp AND element at position j MINUS one of element at position i of dp  \n                SET score TO element at position j of element at position i of grid MINUS element at position j of element at position i of dp  \n\nPseudocode for Problem 3:\nCLASS Solution\n    FUNCTION minLength(s STRING, numOps INTEGER) RETURNS INTEGER\n        FUNCTION check(m INTEGER) RETURNS BOOLEAN\n            DECLARE groupCount INTEGER = 0\n            DECLARE runLength INTEGER = 0\n            DECLARE pos INTEGER = 0\n            DECLARE totalLength INTEGER = LENGTH(s)\n            WHILE pos < totalLength\n                INCREMENT runLength BY 1\n                IF pos = totalLength - 1 OR s[pos] != s[pos + 1]\n                    DECLARE groupsInRun INTEGER = runLength DIV m + 1\n                    groupCount = groupCount + groupsInRun\n                    IF groupCount > numOps\n                        RETURN FALSE\n                    END IF\n                    runLength = 0\n                END IF\n                pos = pos + 1\n            END WHILE\n            RETURN groupCount <= numOps\n\nModified Pseudocode for Problem 3:\nCLASS Solution  \n    FUNCTION minLength(s parameter representing a string, numOps parameter representing an integer) RETURNS integer  \n        FUNCTION check(m parameter representing an integer) RETURNS boolean  \n            SET cnt TO zero  \n            SET k TO zero  \n            FOR each index i AND character c IN s with their positions  \n                INCREMENT k BY one  \n                IF index i EQUALS the length of s MINUS one OR character c NOT EQUALS the element at position index i PLUS one of s  \n                    INCREMENT cnt BY k DIVIDED BY the value of m PLUS one  \n                    IF cnt GREATER THAN numOps  \n                        RETURN false  \n                    END IF  \n                    SET k TO zero  \n                END IF  \n            END FOR  \n            RETURN cnt LESS THAN OR EQUAL TO numOps  \n        END FUNCTION  \n\n        SET n TO the length of s  \n        SET left TO one  \n\nPseudocode for Problem 4:\nCLASS Solution\n    FUNCTION minimumAddedInteger(nums1 RETURNS List OF integer, nums2 RETURNS List OF integer) RETURNS integer\n        CALL nums1.sort()\n        CALL nums2.sort()\n\n        SET outer_index TO 0\n        WHILE outer_index < LENGTH(nums1) - 1\n            SET inner_index TO outer_index + 1\n            WHILE inner_index < LENGTH(nums1) - 1\n                DECLARE filtered_list AS List OF integer ASSIGN []\n                \n                SET pre_segment_end TO outer_index - 1\n                FOR pos FROM 0 TO pre_segment_end\n                    filtered_list += [nums1[pos]]\n                END FOR\n                \n                SET mid_segment_start TO outer_index + 1\n                SET mid_segment_end TO inner_index - 1\n                FOR pos FROM mid_segment_start TO mid_segment_end\n                    filtered_list += [nums1[pos]]\n\nModified Pseudocode for Problem 4:\nCLASS Solution  \n    FUNCTION minimumAddedInteger(nums1 RETURNS List OF integer, nums2 RETURNS List OF integer) RETURNS integer  \n        CALL sort ON nums1  \n        CALL sort ON nums2  \n        \n        FOR i FROM zero TO the LENGTH OF nums1 MINUS one  \n            FOR j FROM i PLUS one TO the LENGTH OF nums1 MINUS one  \n                SET new_nums1 TO an empty list  \n                FOR index FROM zero TO i MINUS one  \n                    APPEND element at position index of nums1 TO new_nums1  \n                END FOR  \n                FOR index FROM i PLUS one TO j MINUS one  \n                    APPEND element at position index of nums1 TO new_nums1  \n                END FOR  \n                FOR index FROM j PLUS one TO the LENGTH OF nums1 MINUS one  \n                    APPEND element at position index of nums1 TO new_nums1  \n                END FOR  \n                \n                SET x TO element at position zero of nums2 MINUS element at position zero of new_nums1  \n                \n\nPseudocode for Problem 5:\nCLASS Solution\n    FUNCTION maximumEnergy(energy, k)\n        LET length BE LENGTH(energy)\n        LET dp ARRAY BE FILLED WITH 0 VALUES OF SIZE length\n        LET last_index BE length - 1\n        dp[last_index] <-- energy[last_index]\n        LET best_energy BE dp[last_index]\n        LET indices_queue BE a deque INITIALIZED WITH [last_index]\n        \n        LET current_pos BE last_index - 1\n        WHILE current_pos >= 0\n            LET front_index BE indices_queue[0]\n            IF (front_index - current_pos) >= k THEN\n                REMOVE FIRST ELEMENT of indices_queue\n            END IF\n            \n            LET next_dp_value BE energy[current_pos] + dp[indices_queue[0]]\n            dp[current_pos] <-- next_dp_value\n            \n            IF best_energy < next_dp_value THEN\n\nModified Pseudocode for Problem 5:\nCLASS Solution  \n    FUNCTION maximumEnergy(energy, k)  \n        SET n TO the LENGTH OF energy  \n        SET dp TO a list of zeros with the LENGTH n  \n        SET the element at the last position of dp TO the element at the last position of energy  \n        SET max_energy TO the element at the last position of dp  \n        ASSIGN reference TO a deque containing the element of n MINUS one as single element  \n        \n        FOR i FROM n MINUS two DOWN TO zero  \n            IF the element at position zero of the deque MINUS i GREATER THAN OR EQUAL TO k  \n                REMOVE the element at position zero FROM the deque  \n            END IF  \n            \n            SET the element at position i of dp TO the element at position i of energy PLUS the element at position of the element at position zero of the deque of dp  \n            \n            IF max_energy LESS THAN the element at position i of dp  \n                SET max_energy TO the element at position i of dp  \n            END IF  \n            \n            WHILE the deque IS NOT empty AND the element at position i of dp GREATER THAN OR EQUAL TO the element at the element at the last position of the deque of dp  \n\nPseudocode for Problem 6:\nCLASS Solution\n    FUNCTION subsequencePairCount(numbers)\n        ASSIGN MODULUS TO 10^9 + 7\n        LET highest TO numbers[0]\n        LET index TO 1\n        WHILE index < LENGTH(numbers)\n            IF numbers[index] > highest THEN\n                SET highest TO numbers[index]\n            END IF\n            INCREMENT index BY 1\n        END WHILE\n        \n        LET dp_table TO []\n        LET row_count TO highest + 1\n        LET col_count TO highest + 1\n        FOR i FROM 0 TO row_count - 1\n            LET row TO []\n            FOR j FROM 0 TO col_count - 1\n                APPEND 0 TO row\n            END FOR\n\nModified Pseudocode for Problem 6:\nCLASS Solution  \n    FUNCTION subsequencePairCount(nums)  \n        SET MOD TO one billion and seven  \n        SET maxNum TO the maximum element of nums  \n        SET dp TO two dimensional list of zeros with dimensions maxNum plus one by maxNum plus one  \n        SET element at position zero and zero of dp TO one  \n\n        FOR each num IN nums  \n            SET newDp TO two dimensional list of zeros with dimensions maxNum plus one by maxNum plus one  \n            FOR x FROM zero TO maxNum inclusive  \n                FOR y FROM zero TO maxNum inclusive  \n                    INCREMENT element at position x and y of newDp BY element at position x and y of dp  \n                    SET element at position x and y of newDp TO the remainder of element at position x and y of newDp DIVIDED BY MOD  \n                    SET newX TO greatest common divisor of x and num  \n                    INCREMENT element at position newX and y of newDp BY element at position x and y of dp  \n                    SET element at position newX and y of newDp TO the remainder of element at position newX and y of newDp DIVIDED BY MOD  \n                    SET newY TO greatest common divisor of y and num  \n                    INCREMENT element at position x and newY of newDp BY element at position x and y of dp  \n                    SET element at position x and newY of newDp TO the remainder of element at position x and newY of newDp DIVIDED BY MOD  \n                END FOR  \n\nPseudocode for Problem 7:\nCLASS Solution  \n    FUNCTION maxScore(points, m)  \n        FUNCTION isPossible(target, movesAllowed)  \n            SET totalMoves TO 0  \n            SET lastRequired TO 0  \n            SET idx TO 0  \n            WHILE idx < LENGTH(points) DO  \n                SET currPoint TO points[idx]  \n                SET needed TO CEIL(target PLUS currPoint MINUS 1, currPoint)  \n                IF (needed MINUS lastRequired) < 0 THEN  \n                    SET needed TO 0  \n                ELSE  \n                    SET needed TO needed MINUS lastRequired  \n                END IF  \n                IF needed > 0 THEN  \n                    SET totalMoves TO totalMoves PLUS (needed TIMES 2 MINUS 1)  \n                    SET lastRequired TO needed MINUS 1  \n                ELSE IF idx PLUS 1 < LENGTH(points) THEN  \n                    SET totalMoves TO totalMoves PLUS 1  \n                    SET lastRequired TO 0  \n\nModified Pseudocode for Problem 7:\nCLASS Solution  \n    FUNCTION maxScore(points, m)  \n        FUNCTION isPossible(minVal, m)  \n            SET moves TO zero  \n            SET prevMoves TO zero  \n            FOR each index i AND element point IN points  \n                SET required TO the smallest integer greater than or equal to minVal PLUS point MINUS one DIVIDED BY point  \n                IF required MINUS prevMoves IS LESS THAN zero THEN  \n                    SET required TO zero  \n                ELSE  \n                    SET required TO required MINUS prevMoves  \n                END IF  \n                IF required IS GREATER THAN zero THEN  \n                    INCREMENT moves BY two TIMES required MINUS one  \n                    SET prevMoves TO required MINUS one  \n                ELSE IF i PLUS one IS LESS THAN the LENGTH OF points THEN  \n                    INCREMENT moves BY one  \n                    SET prevMoves TO zero  \n                END IF  \n                IF moves IS GREATER THAN m THEN  \n\nPseudocode for Problem 8:\nCLASS TreeNode  \n    FUNCTION __init__(self COMMA val EQUALS 0 COMMA left EQUALS None COMMA right EQUALS None)  \n        ASSIGN self.val = val  \n        ASSIGN self.left = left  \n        ASSIGN self.right = right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(vals)  \n    IF vals == [] THEN  \n        RETURN None  \n    END IF  \n    LET root_node BE TreeNode(vals[0])  \n    LET index BE 1  \n    LET to_visit BE new deque  \n    to_visit.append(root_node)  \n    WHILE LEN(to_visit) > 0  \n        LET current_node BE to_visit.popleft()  \n        IF index < LEN(vals) THEN  \n            IF vals[index] IS NOT None THEN  \n\nModified Pseudocode for Problem 8:\nCLASS TreeNode  \n    FUNCTION __init__(self COMMA val EQUALS zero COMMA left EQUALS None COMMA right EQUALS None)  \n        SET self.val TO val  \n        SET self.left TO left  \n        SET self.right TO right  \n    END FUNCTION  \nEND CLASS  \n\nFUNCTION tree_node(values)  \n    IF values EQUALS empty THEN  \n        RETURN None  \n    END IF  \n    SET root TO new TreeNode with value equal to element at position one of values  \n    SET i TO one  \n    SET queue TO new deque  \n    APPEND root TO queue  \n    WHILE queue is not empty  \n        SET node TO element removed from the left side of queue  \n        IF i LESS THAN the length of values AND element at position i of values is not None THEN  \n            SET node.left TO new TreeNode with value equal to element at position i of values  \nScore of -1*(BLEU Score) for ALL the problems: -0.10095863001512134"
}