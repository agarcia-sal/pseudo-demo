CLASS Solution  
    FUNCTION longestSpecialPath(edges, nums)  
        SET adjacency TO array of length length(nums) each initialized to empty list  
        
        FOR each element (a, b, c) IN edges DO  
            LET adjA BE adjacency at index a  
            LET adjB BE adjacency at index b  
            APPEND pair (b, c) TO adjA  
            APPEND pair (a, c) TO adjB  
        END FOR  
        
        FUNCTION dfs(curr, prevNode, boundary, depth)  
            ACCESS maxLength FROM outer scope  
            ACCESS minNodes FROM outer scope  
            
            LET originalDepth BE lastSeenDepth value at key nums[curr], DEFAULT 0  
            SET lastSeenDepth[nums[curr]] TO depth  
            
            IF boundary < originalDepth THEN  
                SET boundary TO originalDepth  
            END IF  
            
            LET segmentLength BE prefix[-1] - prefix[boundary]  
            LET segmentNodes BE depth - boundary  
            
            IF segmentLength > maxLength OR (segmentLength = maxLength AND segmentNodes < minNodes) THEN  
                SET maxLength TO segmentLength  
                SET minNodes TO segmentNodes  
            END IF  
            
            FOR EACH (neighbor, weight) IN adjacency[curr] DO  
                IF neighbor = prevNode THEN  
                    CONTINUE  
                END IF  
                APPEND prefix[-1] + weight TO prefix  
                CALL dfs(neighbor, curr, boundary, depth + 1)  
                REMOVE last element FROM prefix  
            END FOR  
            
            SET lastSeenDepth[nums[curr]] TO originalDepth  
        END FUNCTION  
        
        SET maxLength TO 0  
        SET minNodes TO 1  
        SET prefix TO list containing single element 0  
        SET lastSeenDepth TO empty dictionary  
        CALL dfs(0, -1, 0, 1)  
        RETURN list containing maxLength and minNodes  
    END FUNCTION  
END CLASS