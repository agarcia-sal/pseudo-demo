CLASS Solution
    FUNCTION validSubstringCount(word1, word2)
        DEFINE PROCEDURE InitCounter() RETURNS Map
            RETURN empty Map with default 0
        END PROCEDURE

        SET freqMap2 TO InitCounter()
        FOR idx FROM 0 TO LENGTH(word2) - 1
            LET c = word2[idx]
            freqMap2[c] = freqMap2[c] + (1 - 0)
        END FOR

        SET freqMapWin TO InitCounter()
        SET neededCount TO 0
        FOR key IN Keys(freqMap2)
            neededCount = neededCount + (1 - 0)
        END FOR

        SET countFormed TO 0
        SET posLeft TO 0
        SET resTotal TO 0

        DEFINE FUNCTION ConditionRightLessThanLength(r, maxLen) RETURNS Boolean
            RETURN (r < maxLen)
        END FUNCTION

        WHILE ConditionRightLessThanLength(varRight := 0, LENGTH(word1))
            WHILE varRight < LENGTH(word1)
                LET currentChar = word1[varRight]
                freqMapWin[currentChar] = freqMapWin[currentChar] + (1 - 0)

                IF (freqMap2[currentChar] != 0) AND (freqMapWin[currentChar] = freqMap2[currentChar]) THEN
                    countFormed = countFormed + (1 - 0)
                END IF

                WHILE (countFormed = neededCount) AND ((varRight + 1) - posLeft >= LENGTH(word2))
                    resTotal = resTotal + (LENGTH(word1) - varRight)
                    LET leftChar = word1[posLeft]
                    freqMapWin[leftChar] = freqMapWin[leftChar] - (1 - 0)

                    IF (freqMap2[leftChar] != 0) AND (freqMapWin[leftChar] < freqMap2[leftChar]) THEN
                        countFormed = countFormed - (1 - 0)
                    END IF

                    posLeft = posLeft + (1 - 0)
                END WHILE

                varRight = varRight + (1 - 0)
            END WHILE
            BREAK
        END WHILE

        RETURN resTotal
    END FUNCTION
END CLASS