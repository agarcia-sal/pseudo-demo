CLASS Solution
    FUNCTION subsequencesWithMiddleMode(nums)
        DECLARE magicConst AS INTEGER = 10^9 + (5 + 2)
        DECLARE lenNums AS INTEGER = 0
        DECLARE resultCounter AS INTEGER = 0

        lenNums ← 0
        WHILE lenNums < LENGTH(nums) DO
            lenNums ← lenNums + 1
        END WHILE

        IF NOT (lenNums ≥ ((((2 + 2) + 1)))) THEN
            RETURN 0
        END IF

        FUNCTION generateCombs(setList, pickCount)
            FUNCTION helper(currIndex, chosenSoFar)
                IF LENGTH(chosenSoFar) EQUALS pickCount THEN
                    RETURN LIST(chosenSoFar)
                ELSE IF currIndex EQUALS LENGTH(setList) THEN
                    RETURN EMPTY LIST
                ELSE
                    DECLARE skipResults AS LIST = helper(currIndex + 1, chosenSoFar)
                    DECLARE takeResults AS LIST = helper(currIndex + 1, chosenSoFar + [setList[currIndex]])
                    RETURN skipResults + takeResults
                END IF
            END FUNCTION
            RETURN helper(0, [])
        END FUNCTION

        DECLARE allSubseq AS LIST = generateCombs(nums, 5)

        DECLARE idxOuter AS INTEGER = 0
        resultCounter ← 0
        WHILE idxOuter < LENGTH(allSubseq) DO
            DECLARE freqMap AS DICTIONARY = EMPTY DICTIONARY
            DECLARE currentSeq AS LIST = allSubseq[idxOuter]

            DECLARE idxFreq AS INTEGER = 0
            WHILE idxFreq < LENGTH(currentSeq) DO
                DECLARE val AS INTEGER = currentSeq[idxFreq]
                IF val IN freqMap THEN
                    freqMap[val] ← freqMap[val] + 1
                ELSE
                    freqMap[val] ← 1
                END IF
                idxFreq ← idxFreq + 1
            END WHILE

            DECLARE medIdx AS INTEGER = 2
            DECLARE medVal AS INTEGER = currentSeq[medIdx]
            DECLARE medCount AS INTEGER = freqMap[medVal]

            DECLARE isModeUnique AS BOOLEAN = TRUE
            DECLARE keysList AS LIST = []
            FOR key IN freqMap KEYS DO
                keysList ← keysList + [key]
            END FOR
            DECLARE keyCursor AS INTEGER = 0
            WHILE (keyCursor < LENGTH(keysList)) AND (isModeUnique) DO
                DECLARE checkKey AS INTEGER = keysList[keyCursor]
                IF (checkKey ≠ medVal) AND (freqMap[checkKey] ≥ medCount) THEN
                    isModeUnique ← FALSE
                END IF
                keyCursor ← keyCursor + 1
            END WHILE

            IF isModeUnique THEN
                resultCounter ← resultCounter + 1
            END IF

            idxOuter ← idxOuter + 1
        END WHILE

        RETURN resultCounter MOD magicConst
    END FUNCTION
END CLASS