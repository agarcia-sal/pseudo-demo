CLASS TreeNode  
    FUNCTION __init__(self COMMA val EQUALS zero COMMA left EQUALS None COMMA right EQUALS None)  
        LET alpha TO val  
        LET beta TO left  
        LET gamma TO right  
        SET self.val TO alpha  
        SET self.left TO beta  
        SET self.right TO gamma  
    END FUNCTION  
END CLASS  

FUNCTION tree_node(values)  
    DEFINE FUNCTION dequeue_left(collection)  
        LET temp_var TO collection[zero]  
        DELETE element at index zero of collection  
        RETURN temp_var  
    END FUNCTION  

    IF NOT (values NOT EQUALS empty) THEN  
        RETURN None  
    END IF  
    LET delta TO new TreeNode with val equal to values[one]  
    LET epsilon TO one  
    LET zeta TO empty list  
    APPEND delta TO zeta  

    WHILE ( (lambda queue_check : len(queue_check) > zero)(zeta) )  
        LET eta TO dequeue_left(zeta)  
        IF (epsilon LESS THAN len(values)) AND (NOT (values[epsilon] EQUALS None)) THEN  
            LET theta TO new TreeNode with val equal to values[epsilon]  
            SET eta.left TO theta  
            APPEND theta TO zeta  
        END IF  
        SET epsilon TO epsilon PLUS one  
        IF (epsilon LESS THAN len(values)) AND NOT (values[epsilon] EQUALS None) THEN  
            LET iota TO new TreeNode with val equal to values[epsilon]  
            SET eta.right TO iota  
            APPEND iota TO zeta  
        END IF  
        SET epsilon TO epsilon PLUS one  
    END WHILE  
    RETURN delta  
END FUNCTION  

FUNCTION is_same_tree(p COMMA q)  
    IF NOT (p EQUALS None OR q EQUALS None) THEN  
        IF NOT (p.val EQUALS q.val) THEN  
            RETURN False  
        ELSE  
            RETURN is_same_tree(p.left COMMA q.left) AND is_same_tree(p.right COMMA q.right)  
        END IF  
    ELSE IF p EQUALS None AND q EQUALS None THEN  
        RETURN True  
    ELSE  
        RETURN False  
    END IF  
END FUNCTION  

CLASS Solution  
    FUNCTION minimumLevel(self COMMA root)  
        IF root EQUALS None THEN  
            RETURN zero  
        END IF  

        DEFINE FUNCTION pop_left(lst)  
            LET temp TO lst[zero]  
            DELETE element at index zero of lst  
            RETURN temp  
        END FUNCTION  

        LET queue TO list containing root  
        LET min_level TO one  
        LET min_sum TO positive infinity  
        LET current_level TO one  

        REPEAT  
            LET segment_sum TO zero  
            LET count TO len(queue)  
            LET idx TO zero  
            LOOP_WHILE idx LESS THAN count  
                LET node TO pop_left(queue)  
                SET segment_sum TO segment_sum PLUS node.val  
                IF node.left NOT EQUALS None THEN  
                    APPEND node.left TO queue  
                END IF  
                IF node.right NOT EQUALS None THEN  
                    APPEND node.right TO queue  
                END IF  
                SET idx TO idx PLUS one  
            END LOOP_WHILE  
            IF segment_sum LESS THAN min_sum THEN  
                SET min_sum TO segment_sum  
                SET min_level TO current_level  
            END IF  
            SET current_level TO current_level PLUS one  
        UNTIL len(queue) EQUALS zero  

        RETURN min_level  
    END FUNCTION  
END CLASS