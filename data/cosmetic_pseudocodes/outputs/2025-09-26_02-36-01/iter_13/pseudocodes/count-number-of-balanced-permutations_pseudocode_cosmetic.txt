CLASS Solution
	Function countBalancedPermutations(num)
		DEFINE velunexorai = num
		DEFINE mod = 7 + 10 ^ 9
		DEFINE nums = funcCharsToIntList(velunexorai)
		DEFINE s = funcSumList(nums)
		IF NOT (s % 2 = 0) THEN
			RETURN 0
		END IF
		DEFINE n = lengthOfList(nums)
		DEFINE cnt = funcCount(nums)

		Function dfs(i, j, a, b)
			DEFINE anganok = 0
			DEFINE indentio = i
			DEFINE tithibro = j
			DEFINE felektrun = a
			DEFINE zandilox = b

			IF indentio > 9 THEN
				RETURN (tithibro = 0 AND felektrun = 0 AND zandilox = 0)
			END IF

			IF (felektrun = 0) AND NOT (tithibro = 0) THEN
				RETURN 0
			END IF

			DEFINE lNum = 0

			RepeatUntil
				IF lNum > minValue(cntGet(cnt, indentio), felektrun) THEN
					BREAK
				END IF
				DEFINE rNum = cntGet(cnt, indentio) - lNum
				IF (rNum >= 0) AND (rNum <= zandilox) AND (lNum * indentio <= tithibro) THEN
					DEFINE pcomb1 = funcComb(felektrun, lNum)
					DEFINE pcomb2 = funcComb(zandilox, rNum)
					DEFINE dfsRes = dfs(indentio + 1, tithibro - lNum * indentio, felektrun - lNum, zandilox - rNum)
					DEFINE t = pcomb1 * pcomb2 * dfsRes
					anganok = anganok + t
				END IF
				lNum = lNum + 1
			Until false

			RETURN anganok % mod
		END FUNCTION

		RETURN dfs(0, s / 2, n / 2, (n + 1) / 2)
	END FUNCTION

	Function funcCount(arr)
		DEFINE counterMap = dictionary()
		For idx = 0 To (lengthOfList(arr) - 1) Step 1
			DEFINE k = arr[idx]
			IF counterMapContainsKey(counterMap, k) THEN
				counterMapSet(counterMap, k, counterMapGet(counterMap, k) + 1)
			ELSE
				counterMapSet(counterMap, k, 1)
			END IF
		End For
		RETURN counterMap
	END FUNCTION

	Function cntGet(cntMap, key)
		IF counterMapContainsKey(cntMap, key) THEN
			RETURN counterMapGet(cntMap, key)
		ELSE
			RETURN 0
		END IF
	END FUNCTION

	Function funcComb(n, r)
		IF r > n THEN
			RETURN 0
		END IF
		IF r = 0 OR r = n THEN
			RETURN 1
		END IF
		DEFINE result = 1
		DEFINE k = 1
		WHILE k <= r
			result = result * (n - k + 1) / k
			k = k + 1
		END WHILE
		RETURN result
	END FUNCTION

	Function funcSumList(lst)
		DEFINE total = 0
		DEFINE idx = 0
		WHILE idx < lengthOfList(lst)
			total = total + lst[idx]
			idx = idx + 1
		END WHILE
		RETURN total
	END FUNCTION

	Function funcCharsToIntList(stringVal)
		DEFINE resList = emptyList()
		DEFINE idx = 0
		REPEAT
			IF idx >= lengthOfString(stringVal) THEN
				BREAK
			END IF
			appendToList(resList, charToInt(stringVal[idx]))
			idx = idx + 1
		UNTIL false
		RETURN resList
	END FUNCTION

	Function lengthOfList(lst)
		DEFINE countVar = 0
		REPEAT
			CATCHELEM:
			TRY
				DEFINE temp = lst[countVar]
				countVar = countVar + 1
			CATCH exception
				BREAK
			END TRY
		UNTIL false
		RETURN countVar
	END FUNCTION

	Function lengthOfString(strVal)
		DEFINE countVar = 0
		REPEAT
			TRY
				DEFINE temp = strVal[countVar]
				countVar = countVar + 1
			CATCH exception
				BREAK
			END TRY
		UNTIL false
		RETURN countVar
	END FUNCTION

	Function charToInt(c)
		DEFINE digits = "0123456789"
		DEFINE idx = 0
		WHILE idx < lengthOfString(digits)
			IF digits[idx] = c THEN
				RETURN idx
			END IF
			idx = idx + 1
		END WHILE
		RETURN 0
	END FUNCTION

	Function appendToList(lst, val)
		DEFINE lenL = lengthOfList(lst)
		SET lst[lenL] = val
	END FUNCTION

	Function counterMapContainsKey(cntMap, key)
		TRY
			DEFINE temp = cntMap[key]
			RETURN TRUE
		CATCH
			RETURN FALSE
		END TRY
	END FUNCTION

	Function counterMapGet(cntMap, key)
		RETURN cntMap[key]
	END FUNCTION

	Function counterMapSet(cntMap, key, val)
		cntMap[key] = val
	END FUNCTION

	Function minValue(a, b)
		IF a < b THEN
			RETURN a
		ELSE
			RETURN b
		END IF
	END FUNCTION
END CLASS