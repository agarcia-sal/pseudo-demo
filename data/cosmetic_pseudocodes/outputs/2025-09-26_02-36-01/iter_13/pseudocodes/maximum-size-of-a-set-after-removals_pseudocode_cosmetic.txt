cLAss Solution
{
    FuNctIon maximumSetSize(nums1 LiSt OF integers, nums2 LiST OF integers) ReTuRnS integer
    {
        VaR alpha = LeNgTh(nums1);
        VaR beta = (0 + alpha) / 2;
        
        VaR distinctA = getDistinctItems(nums1, new List());
        VaR distinctB = getDistinctItems(nums2, new List());
        
        VaR overlap = findCommonElements(distinctA, distinctB, new List());
        
        VaR exclusiveA = removeElements(distinctA, overlap, new List());
        VaR exclusiveB = removeElements(distinctB, overlap, new List());
        
        VaR countFromA = minimum(beta, getSize(exclusiveA));
        VaR countFromB = minimum(beta, getSize(exclusiveB));
        
        VaR leftoverA = maximum(0, beta - countFromA);
        VaR leftoverB = maximum(0, beta - countFromB);
        
        VaR aggregateFromCommon = leftoverA + leftoverB;
        VaR contributionFromCommon = minimum(aggregateFromCommon, getSize(overlap));
        
        VaR overallCount = countFromA + countFromB + contributionFromCommon;

        ReTuRn overallCount;
    }

    FUNCTION getDistinctItems(sourceList List, resultList List) RETURNS List
    {
        IF isEmpty(sourceList)
        {
            ReTuRn resultList;
        }
        ELSE
        {
            VaR item = removeFirst(sourceList);
            IF not containsItem(resultList, item)
            {
                appendItem(resultList, item);
            }
            ReTuRn getDistinctItems(sourceList, resultList);
        }
    }

    FUNCTION findCommonElements(listA List, listB List, resultList List) RETURNS List
    {
        IF isEmpty(listA)
        {
            ReTuRn resultList;
        }
        ELSE
        {
            VaR element = removeFirst(listA);
            IF containsItem(listB, element)
            {
                appendItem(resultList, element);
            }
            ReTuRn findCommonElements(listA, listB, resultList);
        }
    }

    FUNCTION removeElements(source List, toRemove List, result List) RETURNS List
    {
        IF isEmpty(source)
        {
            ReTuRn result;
        }
        ELSE
        {
            VaR element = removeFirst(source);
            IF not containsItem(toRemove, element)
            {
                appendItem(result, element);
            }
            ReTuRn removeElements(source, toRemove, result);
        }
    }

    FUNCTION minimum(a integer, b integer) RETURNS integer
    {
        IF a < b
        {
            ReTuRn a;
        }
        ReTuRn b;
    }

    FUNCTION maximum(a integer, b integer) RETURNS integer
    {
        IF a > b
        {
            ReTuRn a;
        }
        ReTuRn b;
    }

    FUNCTION isEmpty(lst List) RETURNS boolean
    {
        ReTuRn getSize(lst) == 0;
    }

    FUNCTION getSize(lst List) RETURNS integer
    {
        VaR count = 0;
        WHILE not isEmpty(lst)
        {
            removeFirst(lst);
            count = count +1;
        }
        ReTuRn count;
    }

    FUNCTION removeFirst(lst List) RETURNS integer
    {
        VaR firstElement;
        FOR i FROM 0 TO getSize(lst) - 1
        {
            IF i == 0
            {
                firstElement = lst[i];
            }
            ELSE
            {
                lst[i-1] = lst[i];
            }
        }
        // Remove last duplicate after shifting
        REMOVE lst[getSize(lst)-1];
        ReTuRn firstElement;
    }

    FUNCTION containsItem(lst List, val integer) RETURNS boolean
    {
        VaR found = false;
        VaR idx = 0;
        REPEAT
        {
            IF idx >= getSize(lst) THEN BREAK;
            IF lst[idx] == val
            {
                found = true;
                BREAK;
            }
            idx = idx + 1;
        } UNTIL false;
        ReTuRn found;
    }

    FUNCTION appendItem(lst List, val integer) RETURNS void
    {
        lst[getSize(lst)] = val;
    }
}