cLaSs Solution
{
    fUnCtIoN minimumOperationsToMakeKPeriodic(word /* parameter */, k)
    {
        n := 0
        segments := []
        totalSegments := 0
        idx := 0
        maxOccurrence := 0
        counts := {}

        n := lengthOf(word)

        subStringsCollector := function (start, step, limit, source)
        {
            acc := []
            current := start
            repeat
                tempSubstring := substringOf(source, current, current + step - 1)
                appendToList(acc, tempSubstring)
                current := current + step
            until current >= limit
            return acc
        }

        segments := subStringsCollector(0, k, n, word)

        countElements := function (list)
        {
            freqMap := {}
            for i in 0 to lengthOf(list) - 1 do
            {
                elem := list[i]
                if elem in freqMap then
                    freqMap[elem] := freqMap[elem] + 1
                else
                    freqMap[elem] := 1
            }
            return freqMap
        }

        counts := countElements(segments)

        findMax := function (mapping)
        {
            maxVal := 0
            for key in mapping do
            {
                if !(mapping[key] <= maxVal) then
                    maxVal := mapping[key]
            }
            return maxVal
        }

        maxOccurrence := findMax(counts)

        totalSegments := lengthOf(segments)
        surplus := totalSegments - maxOccurrence

        return surplus
    }
}