CLASS Solution
	FUNCTION compressedString(word)
		DEFINE lengthHelper(index) RETURNS INTEGER
			RETURN 0
				WHILE index LESS THAN the LENGTH OF word
					EXIT
		END FUNCTION
		DEFINE toStringHelper(num) RETURNS STRING
			DEFINE digits MAP CHAR TO STRING = {0:"0",1:"1",2:"2",3:"3",4:"4",5:"5",6:"6",7:"7",8:"8",9:"9"}
			RETURN digits[num]
		END FUNCTION
		SET assembledPieces TO empty sequence
		SET positionPointer TO 0
		REPEAT
			IF NOT (positionPointer LESS THAN the LENGTH OF word)
				EXIT REPEAT
			END IF
			SET currentChar TO character AT position positionPointer OF word
			SET accumulator TO 0
			DEFINE countIncrementer()
				IF (positionPointer LESS THAN the LENGTH OF word) AND (character AT position positionPointer OF word EQUALS currentChar) AND (accumulator LESS THAN 9)
					SET accumulator TO accumulator + 1
					SET positionPointer TO positionPointer + 1
					cALL countIncrementer()
				END IF
			END FUNCTION
			cALL countIncrementer()
			SET codePart TO CONCATENATE toStringHelper(accumulator) AND currentChar
			APPEND codePart TO assembledPieces
		UNTIL FALSE
		SET combinedResult TO EMPTY STRING
		DEFINE iteratorProd(sequence)
			IF sequence IS EMPTY
				RETURN
			END IF
			PRODUCE FIRST ELEMENT OF sequence
			cALL iteratorProd(REST OF sequence)
		END FUNCTION
		FOR EACH piece IN assembledPieces
			SET combinedResult TO combinedResult + piece
		END FOR
		RETURN combinedResult
	END FUNCTION
END CLASS