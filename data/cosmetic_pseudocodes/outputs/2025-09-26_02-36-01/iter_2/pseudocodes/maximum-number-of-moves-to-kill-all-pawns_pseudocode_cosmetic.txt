CLASS Solution
    FUNCTION maxMoves(kx, ky, positions)
        DECLARE knight_directions AS list OF pairs = [(1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2)]
        DECLARE pawn_set AS empty set
        
        DECLARE idx AS 0
        WHILE idx < LENGTH(positions)
            DECLARE pos_tuple AS (positions[idx][0], positions[idx][1])
            INSERT pos_tuple INTO pawn_set
            SET idx TO idx + 1
        END WHILE
        
        DECLARE pawn_count AS SIZE(pawn_set)
        
        FUNCTION dp(kx, ky, mask, is_alice)
            IF mask == 0 THEN
                RETURN 0
            END IF
            
            DECLARE result
            IF is_alice THEN
                SET result TO 0
            ELSE
                SET result TO +âˆž
            END IF
            
            DECLARE i AS 0
            WHILE i < pawn_count
                IF (mask & (1 << i)) != 0 THEN
                    DECLARE target_x AS positions[i][0]
                    DECLARE target_y AS positions[i][1]
                    
                    DECLARE states AS list CONTAINING (kx, ky, 0)
                    DECLARE explored AS empty set
                    ADD (kx, ky) TO explored
                    
                    DECLARE found_target AS False
                    
                    WHILE LENGTH(states) > 0
                        DECLARE current_state AS REMOVE_FRONT(states)
                        DECLARE cx, cy, step_count AS current_state[0], current_state[1], current_state[2]
                        
                        IF cx == target_x AND cy == target_y THEN
                            SET found_target TO True
                            BREAK
                        END IF
                        
                        FOR EACH (dx, dy) IN knight_directions DO
                            DECLARE next_x AS cx + dx
                            DECLARE next_y AS cy + dy
                            IF next_x >= 0 AND next_x < 50 AND next_y >= 0 AND next_y < 50 THEN
                                IF NOT ((next_x, next_y) IN explored) THEN
                                    ADD (next_x, next_y) TO explored
                                    APPEND (next_x, next_y, step_count+1) TO states
                                END IF
                            END IF
                        END FOR
                    END WHILE
                    
                    IF found_target THEN
                        DECLARE updated_mask AS mask ^ (1 << i)
                        DECLARE value AS step_count + dp(target_x, target_y, updated_mask, NOT is_alice)
                        
                        IF is_alice THEN
                            IF value > result THEN
                                SET result TO value
                            END IF
                        ELSE
                            IF value < result THEN
                                SET result TO value
                            END IF
                        END IF
                    END IF
                END IF
                SET i TO i + 1
            END WHILE
            
            RETURN result
        END FUNCTION
        
        DECLARE full_mask AS (1 << pawn_count) - 1
        RETURN dp(kx, ky, full_mask, True)
    END FUNCTION
END CLASS