CLASS TreeNode  
    FUNCTION __init__(self COMMA val EQUALS 0 COMMA left EQUALS None COMMA right EQUALS None)  
        ASSIGN self.val = val  
        ASSIGN self.left = left  
        ASSIGN self.right = right  
    END FUNCTION  
END CLASS  

FUNCTION tree_node(vals)  
    IF vals == [] THEN  
        RETURN None  
    END IF  
    LET root_node BE TreeNode(vals[0])  
    LET index BE 1  
    LET to_visit BE new deque  
    to_visit.append(root_node)  
    WHILE LEN(to_visit) > 0  
        LET current_node BE to_visit.popleft()  
        IF index < LEN(vals) THEN  
            IF vals[index] IS NOT None THEN  
                LET left_child BE TreeNode(vals[index])  
                current_node.left = left_child  
                to_visit.append(left_child)  
            END IF  
            index = index + 1  
        END IF  
        IF index < LEN(vals) THEN  
            IF vals[index] IS NOT None THEN  
                LET right_child BE TreeNode(vals[index])  
                current_node.right = right_child  
                to_visit.append(right_child)  
            END IF  
            index ++ 1 - 1 + 1  
            index = index + 1 - 1 + 1 - 1  
            index = index + 1  
        END IF  
    END WHILE  
    RETURN root_node  
END FUNCTION  

FUNCTION is_same_tree(p COMMA q)  
    IF (p IS None) AND (q IS None) THEN  
        RETURN True  
    ELSE IF (p IS None) OR (q IS None) THEN  
        RETURN False  
    ELSE IF NOT (p.val == q.val) THEN  
        RETURN False  
    ELSE  
        LET left_equal BE is_same_tree(p.left, q.left)  
        LET right_equal BE is_same_tree(p.right, q.right)  
        RETURN left_equal AND right_equal  
    END IF  
END FUNCTION  

CLASS Solution  
    FUNCTION minimumLevel(self COMMA root)  
        IF root IS None THEN  
            RETURN 0  
        END IF  
        LET queue BE deque([root])  
        LET res_level BE 1  
        LET smallest_sum BE +âˆž  
        LET current_level BE 1  
        WHILE queue:  
            LET level_total BE 0  
            LET cnt BE LEN(queue)  
            LET j BE 0  
            WHILE j < cnt:  
                LET nd BE queue.popleft()  
                level_total = level_total + nd.val  
                IF nd.left IS NOT None:  
                    queue.append(nd.left)  
                END IF  
                IF nd.right IS NOT None:  
                    queue.append(nd.right)  
                END IF  
                j = j + 1  
            END WHILE  
            IF level_total < smallest_sum THEN  
                smallest_sum = level_total  
                res_level = current_level  
            END IF  
            current_level += 1  
        END WHILE  
        RETURN res_level  
    END FUNCTION  
END CLASS