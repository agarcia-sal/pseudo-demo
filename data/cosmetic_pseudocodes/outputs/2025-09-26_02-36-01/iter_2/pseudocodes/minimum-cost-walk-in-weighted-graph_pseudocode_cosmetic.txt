CLASS UnionFind  
    FUNCTION __init__(self, size)  
        LET self.parent BE a sequence generated by enumerating numbers starting at 0 up to size minus 1  
        LET self.rank BE a list filled with the integer 1 repeated size times  
    END FUNCTION  

    FUNCTION find(self, x)  
        WHILE self.parent[x] IS NOT x DO  
            LET self.parent[x] BE self.find(self.parent[x])  
            SET x TO self.parent[x]  
        END WHILE  
        RETURN x  
    END FUNCTION  

    FUNCTION union(self, a, b)  
        LET rootA BE self.find(a)  
        LET rootB BE self.find(b)  
        IF rootA IS DIFFERENT FROM rootB THEN  
            IF self.rank[rootA] > self.rank[rootB] THEN  
                SET self.parent[rootB] TO rootA  
            ELSE IF self.rank[rootA] < self.rank[rootB] THEN  
                SET self.parent[rootA] TO rootB  
            ELSE  
                SET self.parent[rootB] TO rootA  
                LET self.rank[rootA] BE self.rank[rootA] plus 1  
            END IF  
        END IF  
    END FUNCTION  
END CLASS  

CLASS Solution  
    FUNCTION minimumCost(self, n, edges, query)  
        LET uf BE a new UnionFind instance initialized with n  
        LET max_mask BE (1 left-shift 32) minus 1  
        LET comp_mask BE a list containing max_mask repeated n times  
        
        LET idx BE 0  
        WHILE idx < LENGTH(edges) DO  
            LET (node1, node2, weight) BE edges[idx]  
            CALL uf.union(node1, node2)  
            LET leader BE uf.find(node1)  
            SET comp_mask[leader] TO comp_mask[leader] BITWISE AND weight  
            INCREMENT idx BY 1  
        END WHILE  
        
        LET comp_cost_map BE empty dictionary  
        LET i BE 0  
        WHILE i < n DO  
            LET group_leader BE uf.find(i)  
            IF group_leader NOT IN comp_cost_map THEN  
                SET comp_cost_map[group_leader] TO comp_mask[group_leader]  
            END IF  
            INCREMENT i BY 1  
        END WHILE  
        
        LET response_list BE empty list  
        FOR EACH (start_node, end_node) IN query DO  
            IF start_node IS end_node THEN  
                ADD 0 TO response_list  
            ELSE IF uf.find(start_node) IS uf.find(end_node) THEN  
                ADD comp_cost_map[uf.find(start_node)] TO response_list  
            ELSE  
                ADD -1 TO response_list  
            END IF  
        END FOR  
        
        RETURN response_list  
    END FUNCTION  
END CLASS