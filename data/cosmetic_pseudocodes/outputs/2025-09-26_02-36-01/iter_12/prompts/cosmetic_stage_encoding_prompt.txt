Given any input pseudocode, produce a fully transformed variant that meets all these strict criteria:

- Preserve absolute functional equivalence: the rewritten pseudocode must implement identical logic, produce identical outputs, and maintain all side effects exactly as in the original, with no change in semantics.

- Retain all class names, method/function names, full signatures (names, parameter names, order, and types if specified), inheritance hierarchies, and declared object layouts exactly as in the original input. Under no circumstances rename, reorder, restructure, or remove these interface elements or their organization.

- Aggressively rewrite all other code elements—local variables, parameters (except their names in interfaces), temporary variables, control flow constructs, expressions, literals, data traversal patterns, helper functions, and formatting—maximizing syntactic, lexical, and structural disparity. Apply layered and orthogonal transformations including, but not limited to:

  • Replace every loop type with semantically equivalent alternate structures (e.g., for ↔ while ↔ repeat-until ↔ recursion ↔ tail recursion), ensuring behaviorally identical iterations.

  • Introduce fresh, semantically consistent, and entirely unrelated variable names globally for all non-interface identifiers, eliminating any lexical link to original local or temporary identifiers.

  • Restructure statements extensively by decomposing complex statements into simpler ones or merging simple statements, splitting or collapsing conditionals, reordering independent operations safely, and varying data traversal directions or orders without altering observable effects.

  • Transform expressions deeply by applying algebraic and logical equivalences — deploy arithmetic identities, De Morgan’s laws, rewrite conditionals in logically equivalent alternative forms, convert direct constants into computed expressions or symbolic constants, expand or contract compound assignments, create or remove intermediate variables, and reformulate any literals or constants.

  • Alter control flow radically via inlining, outlining helper routines, rearranging early returns versus deferred return variables, flattening or deepening nesting levels of loops and conditionals, and swapping control constructs while preserving exact semantics.

  • Convert direct standard library/built-in calls into custom, local helper subroutines that replicate their behaviors, or replace custom helper subroutine calls back with built-in or library calls wherever semantics allow, maximizing stylistic variation.

  • Vary all formatting aspects vigorously: keyword casing, indentation styles and widths, line breaks, blank lines, spacing, symbol placement, block delimiters, and reordering code or declarations non-impactfully.

- Do not add, remove, or optimize away any algorithmic steps, data structures, or conceptual components. Maintain the original algorithmic complexity and structure in terms of fundamental computation and data usage.

- Do not rename or restructure any external APIs, interfaces, or public contracts defined by the code.

- Output only the fully rewritten pseudocode, as a standalone coherent piece of code, reflecting a distinctly independent coding style with minimal lexical or structural resemblance to the original except for preserved class/method/interface names.

- This instruction applies universally to any pseudocode input regardless of domain or complexity.

- Crucially, your output response must contain *only* the transformed pseudocode text. No explanations, comments, annotations, or additional content of any kind.

Emphasize exhaustive orthogonal rewriting over all code aspects—identifiers, control flows, expressions, helper routines, constants, and formatting—yielding maximal syntactic and structural divergence while rigorously preserving semantic correctness and untouched program interfaces.

Output exactly the transformed pseudocode.