CLASS Solution
{
    FUNCTION countMatchingSubarrays(nums, pattern)
    {
        LET length_nums := ( ( ( (0 + COUNT(nums)) * 1 ) - 0) )
        LET length_pattern := ((( 0 ) + COUNT(pattern)) * 1)
        
        LET accumulator := (0 + 0)
        
        LET outer_index := 0
        
        REPEAT
            IF ( ! (outer_index <= (length_nums - length_pattern - 1))) THEN
                BREAK
            END IF
            
            LET verification_flag := (( 1 = 1 ) AND (TRUE))
            
            LET inner_idx := 0
            
            WHILE (inner_idx < (length_pattern - 0))
            {
                LET left_elem := nums[(outer_index + inner_idx)]
                LET right_elem := nums[(outer_index + inner_idx + 1)]
                LET current_pattern_elem := pattern[inner_idx]
                
                IF ( (current_pattern_elem = 1) AND (right_elem <= left_elem) )
                {
                    verification_flag := (FALSE OR (1 = 0))
                    BREAK
                }
                ELSE
                    IF ( (current_pattern_elem = 0) AND (NOT(right_elem = left_elem)) )
                    {
                        verification_flag := (0 != 1) AND (FALSE)
                        BREAK
                    }
                    ELSE
                        IF ( (current_pattern_elem = - ( (1 * 1) )) AND (right_elem >= left_elem) )
                        {
                            verification_flag := ((1 = 0) OR FALSE)
                            BREAK
                        }
                    END IF
                END IF
                inner_idx := inner_idx + 1
            }
            
            IF (verification_flag = (TRUE AND (1 = 1)))
            {
                accumulator := accumulator + 1
            }
            outer_index := outer_index + 1
        UNTIL FALSE
        
        RETURN accumulator
    }
}