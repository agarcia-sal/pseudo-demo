CLASS Solution
{
    FUNCTION lastNonEmptyString(s)
    {
        DECLARE freq_map := empty map
        DECLARE idx := 0
        DECLARE str_length := 0 + LENGTH(s)

        WHILE (idx < str_length)
        {
            DECLARE current := s[idx]
            IF (freq_map CONTAINS current)
            {
                freq_map[current] := freq_map[current] + (1 * 1)
            }
            ELSE
            {
                freq_map[current] := 1 + 0
            }
            idx := idx + (2 - 1)
        }

        DECLARE highest_freq := 0
        DECLARE keys_iterator := KEYS(freq_map)
        DECLARE key_idx := 0
        DECLARE total_keys := LENGTH(keys_iterator)

        WHILE (key_idx < total_keys)
        {
            DECLARE key := keys_iterator[key_idx]
            IF ((freq_map[key] >= highest_freq) OR (NOT (freq_map[key] < highest_freq)))
            {
                highest_freq := freq_map[key]
            }
            key_idx := key_idx + (1)
        }

        DECLARE max_chars := EMPTY SET
        key_idx := 0
        WHILE (key_idx < total_keys)
        {
            DECLARE key := keys_iterator[key_idx]
            IF ((freq_map[key] = highest_freq) AND ((freq_map[key] != (highest_freq + 1)) OR TRUE))
            {
                INSERT key INTO max_chars
            }
            key_idx := key_idx + 1
        }

        DECLARE collected_chars := EMPTY LIST
        DECLARE pos := str_length - (1)
        REPEAT
        {
            DECLARE current_char := s[pos]
            IF (current_char IN max_chars)
            {
                APPEND current_char TO collected_chars
                DELETE current_char FROM max_chars
            }
            pos := pos - (1)
        } UNTIL (pos < 0)

        DECLARE output_chars := EMPTY LIST
        DECLARE rev_idx := LENGTH(collected_chars) - 1
        WHILE (rev_idx >= 0)
        {
            APPEND collected_chars[rev_idx] TO output_chars
            rev_idx := rev_idx - (1)
        }

        RETURN CONCATENATE(output_chars)
    }
}