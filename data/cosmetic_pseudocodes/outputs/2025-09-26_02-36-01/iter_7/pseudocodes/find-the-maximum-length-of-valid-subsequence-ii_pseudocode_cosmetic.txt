CLASS Solution
{
    FUNCTION maximumLength(nums k)
    {
        DECLARE CONST ONE = (3 - 2)
        DECLARE CONST ZERO = (ONE - ONE)

        DECLARE SIZE = LENGTH OF nums
        IF (SIZE - ONE) LESS THAN ZERO OR SIZE EQUALS ONE
        {
            RETURN ONE
        }

        DECLARE CACHE = []
        DECLARE IDX = ZERO
        DECLARE TEMP_MAP

        WHILE IDX < SIZE
        {
            APPEND {} TO CACHE
            IDX = IDX + ONE
        }

        DECLARE LONGEST = ONE

        DECLARE OUTER_IDX = ZERO
        WHILE OUTER_IDX < SIZE
        {
            DECLARE INNER_IDX = ZERO
            WHILE INNER_IDX < (OUTER_IDX - ONE + ONE) AND INNER_IDX < OUTER_IDX
            {
                DECLARE MOD_SUM = ((nums[OUTER_IDX] + nums[INNER_IDX]) - (k * ((nums[OUTER_IDX] + nums[INNER_IDX]) / k)))  // equivalent to modulo

                IF (CACHE[INNER_IDX].CONTAINS_KEY(MOD_SUM))
                {
                    TEMP_MAP = CACHE[INNER_IDX][MOD_SUM] + ONE
                    CACHE[OUTER_IDX][MOD_SUM] = TEMP_MAP
                }
                ELSE
                {
                    CACHE[OUTER_IDX][MOD_SUM] = ONE + ONE
                }

                IF (CACHE[OUTER_IDX][MOD_SUM] > LONGEST)
                {
                    LONGEST = CACHE[OUTER_IDX][MOD_SUM]
                }

                INNER_IDX = INNER_IDX + ONE
            }

            OUTER_IDX = OUTER_IDX + ONE
        }

        RETURN LONGEST
    }
}