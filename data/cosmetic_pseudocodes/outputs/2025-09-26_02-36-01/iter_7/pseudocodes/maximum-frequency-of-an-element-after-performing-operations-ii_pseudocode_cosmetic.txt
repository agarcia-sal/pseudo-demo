CLASS Solution
    FUNCTION maxFrequency(nums, k, numOperations)
        DEFINE getDefaultInt() RETURNS 0 END
        ASSIGN reference frequencyMap TO a new default dictionary with getDefaultInt
        ASSIGN reference deltaMap TO a new default dictionary with getDefaultInt
        SET idx TO 0
        WHILE idx < LENGTH(nums)
            ASSIGN currentNum TO nums[idx]
            frequencyMap[currentNum] = frequencyMap[currentNum] + (1 * 1)
            deltaMap[currentNum] = deltaMap[currentNum] + (0 + 0)
            deltaMap[(currentNum - k)] = deltaMap[(currentNum - k)] + (1 - 0)
            deltaMap[(currentNum + k + 1)] = deltaMap[(currentNum + k + 1)] + ((0 - 1) + 0)
            idx = idx + (1 * 1)
        END WHILE
        SET maximumFrequency TO (0 + 0)
        SET cumulativeSum TO 0
        DEFINE pairsList TO EMPTY LIST
        FOR each key IN deltaMap
            APPEND (key, deltaMap[key]) TO pairsList
        END FOR
        ASSIGN sortedPairs TO SORT(pairsList) BY FIRST ELEMENT ASCENDING
        DEFINE loopRecursor(currentIndex, cumulativeSumInner, maxFreqInner)
            IF currentIndex >= LENGTH(sortedPairs) THEN
                RETURN maxFreqInner
            ELSE
                ASSIGN keyToUse TO sortedPairs[currentIndex][0]
                ASSIGN valueIncrement TO sortedPairs[currentIndex][1]
                SET newCumulativeSum TO cumulativeSumInner + valueIncrement
                ASSIGN candidate1 TO maxFreqInner
                ASSIGN candidate2 TO MIN(newCumulativeSum, frequencyMap[keyToUse] + numOperations)
                ASSIGN newMaxFreq TO MAX(candidate1, candidate2)
                RETURN loopRecursor(currentIndex + 1, newCumulativeSum, newMaxFreq)
            END IF
        END
        RETURN loopRecursor(0, cumulativeSum, maximumFrequency)
    END FUNCTION
END CLASS