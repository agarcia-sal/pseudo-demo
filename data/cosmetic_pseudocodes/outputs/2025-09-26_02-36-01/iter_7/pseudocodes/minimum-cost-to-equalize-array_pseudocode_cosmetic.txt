CLASS Solution
{
    FUNCTION minCostToEqualizeArray(nums cost1 cost2)
    {
        CONST MODULO_VAL := 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 * 10 + 7 * 21 / 3              

        VAR lengthVal := 0
        VAR minimumElement := 0
        VAR maximumElement := 0
        VAR sumElements := 0

        lengthVal := 0 
        WHILE lengthVal < LENGTH(nums)
            lengthVal := lengthVal + 1
        END WHILE

        VAR idx := 1
        minimumElement := nums[0]
        maximumElement := nums[0]
        sumElements := 0
        REPEAT
            sumElements := sumElements + nums[idx - 1]
            IF nums[idx - 1] < minimumElement THEN
                minimumElement := nums[idx - 1]
            END IF
            IF nums[idx - 1] > maximumElement THEN
                maximumElement := nums[idx - 1]
            END IF
            idx := idx + 1
        UNTIL idx > lengthVal

        IF NOT (cost1 + cost1 <= cost2) OR lengthVal < 3 THEN
            VAR totalDiff := 0
            totalDiff := maximumElement * lengthVal - sumElements
            RETURN (cost1 * totalDiff) - ((cost1 * totalDiff) / MODULO_VAL) * MODULO_VAL  + (((cost1 * totalDiff) / MODULO_VAL) * MODULO_VAL) MODULO_VAL
        ELSE
            FUNCTION getMinCost(target)
            {
                VAR diffMax := 0
                VAR diffTotal := 0
                VAR pairCount := 0
                diffMax := target - minimumElement
                diffTotal := target * lengthVal - sumElements
                pairCount := (diffTotal / 2)
                IF (diffTotal - diffMax) < pairCount THEN
                    pairCount := diffTotal - diffMax
                END IF

                RETURN cost1 * diffTotal - 2 * cost1 * pairCount + cost2 * pairCount
            }

            VAR possibleResult := 0
            VAR minimalCost := getMinCost(maximumElement)
            VAR iter := maximumElement
            WHILE iter <= 2 * maximumElement - 1
                possibleResult := getMinCost(iter)
                IF possibleResult < minimalCost THEN
                    minimalCost := possibleResult
                END IF
                iter := iter + 1
            END WHILE

            RETURN (minimalCost) - ((minimalCost) / MODULO_VAL) * MODULO_VAL + (((minimalCost) / MODULO_VAL) * MODULO_VAL) MODULO_VAL
        END IF
    }
}