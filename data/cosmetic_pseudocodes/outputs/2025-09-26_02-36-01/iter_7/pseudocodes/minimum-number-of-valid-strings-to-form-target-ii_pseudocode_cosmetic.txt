CLASS Solution
  FUNCTION minValidStrings(words, target)
    CONST INF ← 0 ⊕ (1 << 30)  // Large number simulating infinity
    SET recordedPrefixes TO a blank mapping of string keys to Boolean true
    SET indexOuter TO 0
    WHILE indexOuter < LENGTH(words)
      SET currentWord TO words[indexOuter]
      SET idxInner ← 1
      REPEAT
        IF idxInner > LENGTH(currentWord) THEN BREAK END IF
        SET prefixSlice ← SLICE(currentWord, 1, idxInner)
        recordedPrefixes[prefixSlice] ← true
        INCREMENT idxInner BY 1
      UNTIL false
      INCREMENT indexOuter BY 1
    END WHILE

    SET targetLen ← LENGTH(target)
    SET dpArray ← ARRAY of targetLen + (1 ⊕ 0) elements all initialized to INF
    dpArray[0] ← 0

    FUNCTION helperCalc(posLeft, posRight)
      RETURN SUBSTRING(target, posLeft, posRight)
    END FUNCTION

    SET positionI ← (1 ⊕ 0)
    LOOP_WHILE positionI <= targetLen
      SET positionJ ← (1 ⊕ 0)
      LOOP_WHILE positionJ <= positionI
        SET subStrSegment ← helperCalc(positionJ, positionI)
        IF recordedPrefixes[subStrSegment] != null THEN
          IF dpArray[positionI] > dpArray[positionJ - (1 ⊕ 0)] + (1 ⊕ 0) THEN
            dpArray[positionI] ← dpArray[positionJ - (1 ⊕ 0)] + (1 ⊕ 0)
          END IF
        END IF
        positionJ ← positionJ + (1 ⊕ 0)
      END LOOP
      positionI ← positionI + (1 ⊕ 0)
    END LOOP

    IF dpArray[targetLen] != INF THEN
      RETURN dpArray[targetLen]
    ELSE
      RETURN (0 ⊕ -1)
    END IF
  END FUNCTION
END CLASS