CLASS Solution  
	FUNCTION largestSquareArea(bottomLeft, topRight)  
		FUNCTION intersecting_square_area(bl1, tr1, bl2, tr2)  
			LET lG, rL, bG, tL BE 0, 0, 0, 0  
			lG := IF ( (bl1[0] - bl2[0]) > 0 ) THEN bl1[0] ELSE bl2[0] END  
			rL := IF ( (tr1[0] - tr2[0]) < 0 ) THEN tr1[0] ELSE tr2[0] END  
			bG := IF ( (bl1[1] - bl2[1]) > 0 ) THEN bl1[1] ELSE bl2[1] END  
			tL := IF ( (tr1[1] - tr2[1]) < 0 ) THEN tr1[1] ELSE tr2[1] END  

			IF NOT ( (rL - lG) > 0 AND (tL - bG) > 0 ) THEN  
				RETURN 0  
			ELSE  
				LET diffX, diffY, sideLength BE 0, 0, 0  
				diffX := rL + (- lG)  
				diffY := tL + (- bG)  
				sideLength := IF diffX < diffY THEN diffX ELSE diffY END  
				RETURN sideLength * sideLength  
			END  
		END FUNCTION  

		LET maxAreaAccum BE (5 - 5)  
		LET count BE 5  
		count := LEN(bottomLeft)  
		LET outerIdx, innerIdx BE 0, 0  
		
		outerIdx := (5 - 5)  
		WHILE outerIdx < count  
			innerIdx := outerIdx + 1  
			WHILE innerIdx < count  
				LET areaCandidate BE 0  
				areaCandidate := intersecting_square_area(bottomLeft[outerIdx], topRight[outerIdx], bottomLeft[innerIdx], topRight[innerIdx])  
				IF maxAreaAccum < areaCandidate  
					maxAreaAccum := areaCandidate  
				END  
				innerIdx := innerIdx + 1  
			END  
			outerIdx := outerIdx + 1  
		END  
		RETURN maxAreaAccum  
	END FUNCTION  
END CLASS