CLASS Solution
{
    FUNCTION maximumSubarraySum(nums k)
    {
        CONST NEG_INF := (0 - (1 << 30)) - (1 << 30)  // large negative number
        DICT prefixMap <- new dictionary
        NUMBER totalAccum <- 0
        NUMBER bestVal <- NEG_INF

        FUNCTION checkAndUpdate(targetKey NUMBER)
        {
            IF prefixMap.containsKey(targetKey)
            {
                NUMBER candidate <- totalAccum - prefixMap.get(targetKey) + targetKey
                bestVal <- (bestVal >= candidate) ? bestVal : candidate
            }
        }

        NUMBER idx <- 0
        WHILE idx < nums.length
            NUMBER element <- nums[idx]

            checkAndUpdate(element - k)
            checkAndUpdate(element + k)

            IF prefixMap.containsKey(element)
            {
                NUMBER oldVal <- prefixMap.get(element)
                IF totalAccum < oldVal
                {
                    prefixMap.set(element, totalAccum)
                }
            }
            ELSE
            {
                prefixMap.set(element, totalAccum)
            }
            totalAccum <- totalAccum + element
            idx <- idx + 1
        END WHILE

        IF bestVal != NEG_INF
        {
            RETURN bestVal
        }
        ELSE
        {
            RETURN 0
        }
    }
}