CLASS Solution
    FUNCTION maxTotalReward(rewardValues)
        SET uvp TO an EMPTY LIST
        FOR i FROM 0 TO LENGTH(rewardValues) - 1
            APPEND rewardValues[i] TO uvp
        END FOR

        CALL sortList(uvp)

        SET ytg TO 1
        SET idx TO 0

        REPEAT
            IF idx >= LENGTH(uvp) THEN
                BREAK
            END IF

            SET zwm TO 1
            SET zzx TO uvp[idx]

            SET ppi TO (ytg BITWISE_AND ((1 LEFT_SHIFT zzx) - 1)) LEFT_SHIFT zzx
            SET ytg TO ytg BITWISE_OR ppi

            SET idx TO idx + 1
        UNTIL FALSE

        SET result TO (bitLengthOf(ytg) - 1)
        RETURN result
    END FUNCTION

    FUNCTION sortList(lst)
        IF LENGTH(lst) <= 1 THEN
            RETURN
        END IF

        CALL quickSort(lst, 0, LENGTH(lst) - 1)
    END FUNCTION

    FUNCTION quickSort(arr, left, right)
        IF left >= right THEN
            RETURN
        END IF

        SET pivotIndex TO partition(arr, left, right)
        CALL quickSort(arr, left, pivotIndex - 1)
        CALL quickSort(arr, pivotIndex + 1, right)
    END FUNCTION

    FUNCTION partition(arr, low, high)
        SET pivotValue TO arr[high]
        SET i TO low - 1
        SET j TO low

        REPEAT
            IF j >= high THEN
                BREAK
            END IF

            IF arr[j] <= pivotValue THEN
                SET i TO i + 1
                CALL swap(arr, i, j)
            END IF

            SET j TO j + 1
        UNTIL FALSE

        CALL swap(arr, i + 1, high)
        RETURN i + 1
    END FUNCTION

    FUNCTION swap(arr, a, b)
        SET tmp TO arr[a]
        SET arr[a] TO arr[b]
        SET arr[b] TO tmp
    END FUNCTION

    FUNCTION bitLengthOf(num)
        SET cnt TO 0
        SET n TO num

        WHILE n > 0 DO
            SET n TO n DIV 2
            SET cnt TO cnt + 1
        END WHILE

        RETURN cnt
    END FUNCTION
END CLASS