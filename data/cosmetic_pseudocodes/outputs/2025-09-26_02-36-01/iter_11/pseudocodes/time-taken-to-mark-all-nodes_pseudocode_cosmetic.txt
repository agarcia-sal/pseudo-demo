CLASS Solution
    FUNCTION timeTaken(edges)
        LET size = (SIZE edges) + 1
        LET adjacencyMap = buildGraph(edges)

        FUNCTION bfs(origin)
            LET processingQueue = new Deque()
            ENQUEUE processingQueue (origin, 0)
            LET visitFlags = ARRAY OF size elements INITIALIZED TO false
            ASSIGN visitFlags[origin] = true
            LET ceilingTime = 0

            WHILE processingQueue HAS ELEMENTS DO
                LET (node, clk) = DEQUEUE_Front processingQueue

                IF ceilingTime < clk THEN
                    ASSIGN ceilingTime = clk
                END IF

                FOR EACH neighborNode IN adjacencyMap[node] DO
                    IF (visitFlags[neighborNode] = false) THEN
                        ASSIGN visitFlags[neighborNode] = true
                        IF (neighborNode MOD 2 = 0) THEN
                            ENQUEUE processingQueue (neighborNode, clk + 2)
                        ELSE
                            ENQUEUE processingQueue (neighborNode, clk + 1)
                        END IF
                    END IF
                END FOR
            END WHILE

            RETURN ceilingTime
        END FUNCTION

        FUNCTION buildGraph(edgeList)
            LET mapObj = ARRAY OF size ELEMENTS CONTAINING EMPTY LISTS
            FUNCTION auxFillGraph(idx)
                IF idx >= SIZE edgeList THEN RETURN mapObj END IF
                LET u = edgeList[idx][0]
                LET v = edgeList[idx][1]
                APPEND v TO mapObj[u]
                APPEND u TO mapObj[v]
                RETURN auxFillGraph(idx + 1)
            END FUNCTION
            RETURN auxFillGraph(0)
        END FUNCTION

        LET resultTimes = ARRAY(size) FILLED WITH 0
        LET counter = 0
        REPEAT
            ASSIGN resultTimes[counter] = bfs(counter)
            ASSIGN counter = counter + 1
        UNTIL counter = size

        RETURN resultTimes
    END FUNCTION
END CLASS