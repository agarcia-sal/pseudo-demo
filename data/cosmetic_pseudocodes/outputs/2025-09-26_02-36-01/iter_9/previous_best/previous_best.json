{
  "prompt": "Given any input pseudocode, generate a thoroughly transformed version that satisfies all of the following conditions:\n\n- Preserve exact original semantics: the output pseudocode must produce the same outputs, have identical side effects, and uphold every logical behavior of the input.\n\n- Keep all class names, method/function names, signatures (names, parameter types/names/order, and return types if specified), class inheritance, and declared object layouts unchanged, precisely as in the original input. Do not rename or restructure these interface elements or alter their hierarchical organization in any way.\n\n- For all other code components (local/temporary variables, parameter variables, control flow, expressions, literals, data traversal, helper functions, and formatting), apply maximal and layered rewriting to maximize syntactic and structural divergence, including but not limited to:\n\n  \u2022 Replace all loop constructs with logically equivalent alternate types (for \u2194 while \u2194 repeat-until \u2194 recursion \u2194 tail-recursion) ensuring the same iteration behavior.\n\n  \u2022 Globally replace every local, temporary, and parameter variable identifier with freshly generated, unrelated, semantically consistent names with no overlap or semantic hints from any original local or temporary identifier.\n\n  \u2022 Decompose or combine statements, split or merge conditionals, reorder safe independent operations, change the order or style of data traversal when output order or side effects are invariant.\n\n  \u2022 Re-express all expressions deeply by applying arithmetic/logical identities, use De Morgan\u2019s laws to reframe conditionals, expand or contract compound assignments, substitute equivalent expressions, create or remove intermediate temps, and rewrite constant literals as expressions or defined constants.\n\n  \u2022 Transform control flow by inlining or extracting subexpressions or helper routines, rearranging early return positions versus deferred return variables, and reshaping nesting levels of conditionals and loops.\n\n  \u2022 Convert direct built-in or standard library calls into custom local helper procedures implementing identical logic, or replace custom helper calls with built-in equivalents, wherever functional equivalence is preserved.\n\n  \u2022 Vary all formatting details thoroughly: alter indentation schemes, line breaks, whitespace usage, block delimiters, keyword casing, and code ordering stylistically.\n\n- Do not add, remove, optimize away, or abstract any algorithmic steps, data structure usages, or conceptual components. The full original logic and steps must remain intact.\n\n- Do not rename, reshape, or alter external APIs, interfaces, or any identifier explicitly defining the program\u2019s exposed contract.\n\n- The output must consist solely of the fully rewritten pseudocode, formatted as a complete, standalone piece of code, exhibiting a wholly independent implementation style with minimal lexical or structural resemblance to the input apart from the intentionally preserved names noted above.\n\n- This transformation prompt applies universally to any pseudocode input irrespective of domain or problem context.\n\n- Your response must be strictly the transformed pseudocode text only; omit explanations, comments, annotations, or any other supplementary content.\n\nEmphasize comprehensive orthogonal rewriting across identifiers, control flow, expressions, data traversals, helper routines, constants, and formatting to maximize surface and structural divergence while preserving all required interface elements verbatim and exact program semantics.\n\nOutput only the transformed pseudocode.",
  "response": "Given any input pseudocode, generate a thoroughly transformed version that satisfies all of the following conditions:\n\n- Preserve exact original semantics: the output pseudocode must produce the same outputs, have identical side effects, and uphold every logical behavior of the input.\n\n- Keep all class names, method/function names, signatures (names, parameter types/names/order, and return types if specified), class inheritance, and declared object layouts unchanged, precisely as in the original input. Do not rename or restructure these interface elements or alter their hierarchical organization in any way.\n\n- For all other code components (local/temporary variables, parameter variables, control flow, expressions, literals, data traversal, helper functions, and formatting), apply maximal and layered rewriting to maximize syntactic and structural divergence, including but not limited to:\n\n  \u2022 Replace all loop constructs with logically equivalent alternate types (for \u2194 while \u2194 repeat-until \u2194 recursion \u2194 tail-recursion) ensuring the same iteration behavior.\n\n  \u2022 Globally replace every local, temporary, and parameter variable identifier with freshly generated, unrelated, semantically consistent names with no overlap or semantic hints from any original local or temporary identifier.\n\n  \u2022 Decompose or combine statements, split or merge conditionals, reorder safe independent operations, change the order or style of data traversal when output order or side effects are invariant.\n\n  \u2022 Re-express all expressions deeply by applying arithmetic/logical identities, use De Morgan\u2019s laws to reframe conditionals, expand or contract compound assignments, substitute equivalent expressions, create or remove intermediate temps, and rewrite constant literals as expressions or defined constants.\n\n  \u2022 Transform control flow by inlining or extracting subexpressions or helper routines, rearranging early return positions versus deferred return variables, and reshaping nesting levels of conditionals and loops.\n\n  \u2022 Convert direct built-in or standard library calls into custom local helper procedures implementing identical logic, or replace custom helper calls with built-in equivalents, wherever functional equivalence is preserved.\n\n  \u2022 Vary all formatting details thoroughly: alter indentation schemes, line breaks, whitespace usage, block delimiters, keyword casing, and code ordering stylistically.\n\n- Do not add, remove, optimize away, or abstract any algorithmic steps, data structure usages, or conceptual components. The full original logic and steps must remain intact.\n\n- Do not rename, reshape, or alter external APIs, interfaces, or any identifier explicitly defining the program\u2019s exposed contract.\n\n- The output must consist solely of the fully rewritten pseudocode, formatted as a complete, standalone piece of code, exhibiting a wholly independent implementation style with minimal lexical or structural resemblance to the input apart from the intentionally preserved names noted above.\n\n- This transformation prompt applies universally to any pseudocode input irrespective of domain or problem context.\n\n- Your response must be strictly the transformed pseudocode text only; omit explanations, comments, annotations, or any other supplementary content.\n\nEmphasize comprehensive orthogonal rewriting across identifiers, control flow, expressions, data traversals, helper routines, constants, and formatting to maximize surface and structural divergence while preserving all required interface elements verbatim and exact program semantics.\n\nOutput only the transformed pseudocode.",
  "score": -0.06149909205293042,
  "feedback": "The following are 20 lines of original pseudocode of a random subset of the problems along with their modified pseudocodes.\n\nPseudocode for Problem 1:\nCLASS Solution\n    FUNCTION minEnd(n z)\n        \n        FUNCTION canConstruct(limit)\n            FUNCTION bitwiseAnd(a, b)\n                RETURN a & b\n            END FUNCTION\n\n            SET temp := z\n            SET tally := 1\n\n            REPEAT\n                IF NOT (temp < limit) THEN\n                    BREAK\n                END IF\n\n                SET temp := temp + 1\n\n                IF bitwiseAnd(temp, z) = z THEN\n                    SET tally := tally + 1\n\nModified Pseudocode for Problem 1:\nCLASS Solution  \n    FUNCTION minEnd(n x)  \n        FUNCTION canConstruct(max_val)  \n            SET current TO x  \n            SET count TO one  \n            WHILE current LESS THAN max_val  \n                SET current TO current PLUS one  \n                IF the binary AND of current AND x EQUALS x  \n                    INCREMENT count BY one  \n                    IF count EQUALS n  \n                        RETURN True  \n                    END IF  \n                END IF  \n            END WHILE  \n            RETURN count EQUALS n  \n        END FUNCTION  \n        \n        SET left TO x  \n        SET right TO the product of two AND ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten MULTIPLIED BY ten  \n        WHILE left LESS THAN right  \n\nPseudocode for Problem 2:\nCLASS Solution  \n    FUNCTION findWinningPlayer(alphaBeta, omega)  \n        FUNCTION popFront(lineup)  \n            SET head TO lineup[0]  \n            SET lineup TO lineup[1 TO LENGTH OF lineup MINUS 1]  \n            RETURN head, lineup  \n        END FUNCTION\n\n        SET totalPlayers TO LENGTH OF alphaBeta  \n        SET rotation TO []\n        SET indexCounter TO 0  \n        WHILE indexCounter LESS THAN totalPlayers  \n            APPEND indexCounter TO rotation  \n            SET indexCounter TO indexCounter PLUS 1  \n        END WHILE\n\n        SET consecutiveWins TO 0  \n        SET champ, rotation TO popFront(rotation)  \n\n        FUNCTION isSmaller(a, b)  \n\nModified Pseudocode for Problem 2:\nCLASS Solution  \n    FUNCTION findWinningPlayer(skills, k)  \n        SET n TO the LENGTH OF skills  \n        SET queue TO a LIST of numbers FROM zero TO n MINUS one  \n        SET wins TO zero  \n        SET current_winner TO the element at position zero of queue REMOVED from queue  \n        WHILE wins LESS THAN k AND the LENGTH OF queue GREATER THAN zero  \n            SET next_player TO the element at position zero of queue REMOVED from queue  \n            IF the element at position current_winner of skills GREATER THAN the element at position next_player of skills  \n                INCREMENT wins BY one  \n                APPEND next_player TO queue  \n            ELSE  \n                SET wins TO one  \n                APPEND current_winner TO queue  \n                SET current_winner TO next_player  \n            END IF  \n        END WHILE  \n        RETURN current_winner  \n    END FUNCTION  \nEND CLASS\n\nPseudocode for Problem 3:\nCLASS Solution\n    FUNCTION countOfPeaks(nums LIST OF INTEGER, queries LIST OF LIST OF INTEGER) RETURNS LIST OF INTEGER\n        FUNCTION check_peak(pos INTEGER) RETURNS BOOLEAN\n            SET left_neighbor TO nums AT (pos MINUS 1)\n            SET current_val TO nums AT pos\n            SET right_neighbor TO nums AT (pos PLUS 1)\n            IF (current_val GREATER THAN left_neighbor) AND (current_val GREATER THAN right_neighbor) THEN\n                RETURN true\n            ELSE\n                RETURN false\n            END IF\n        END FUNCTION\n\n        SET peak_positions TO empty list\n\n        PROCEDURE build_peaks()\n            SET idx TO 1\n            WHILE idx LESS THAN LENGTH OF nums MINUS 1 DO\n                IF check_peak(idx) THEN\n                    APPEND idx TO peak_positions\n\nModified Pseudocode for Problem 3:\nCLASS Solution  \n    FUNCTION countOfPeaks(nums LIST OF INTEGER, queries LIST OF LIST OF INTEGER) RETURNS LIST OF INTEGER  \n        FUNCTION is_peak(i INTEGER) RETURNS BOOLEAN  \n            RETURN element at position i MINUS one of nums LESS THAN element at position i of nums AND element at position i of nums GREATER THAN element at position i PLUS one of nums  \n        END FUNCTION  \n        \n        SET peaks TO empty list  \n        FOR i FROM one TO LENGTH OF nums MINUS two  \n            IF is_peak(i) EQUALS true  \n                APPEND i TO peaks  \n            END IF  \n        END FOR  \n        \n        SET result TO empty list  \n        FOR each query IN queries  \n            IF element at position zero of query EQUALS one  \n                SET li TO element at position one of query  \n                SET ri TO element at position two of query  \n                SET left_index TO the LEFT insertion position of li PLUS one in peaks  \n                SET right_index TO the RIGHT insertion position of ri MINUS one in peaks  \n\nPseudocode for Problem 4:\nCLASS Enemy\n    FUNCTION __init__(self, alpha, beta)\n        SET self.damage TO alpha\n        SET self.timeTakenDown TO beta\n    END FUNCTION\nEND CLASS\n\nCLASS Solution\n    FUNCTION minDamage(self, omega, theta, sigma)\n        PROCEDURE computeCeilDiv(x, y)\n            SET result TO (x + y - 1) DIV y\n            RETURN result\n        END PROCEDURE\n\n        PROCEDURE cmpRatio(left, right)\n            RETURN (left.damage * right.timeTakenDown) > (right.damage * left.timeTakenDown)\n        END PROCEDURE\n\n        SET totalSum TO 0\n        SET outputAccum TO 0\n\nModified Pseudocode for Problem 4:\nCLASS Enemy  \n    FUNCTION __init__(self, damage, timeTakenDown)  \n        SET self.damage TO damage  \n        SET self.timeTakenDown TO timeTakenDown  \n    END FUNCTION  \nEND CLASS  \n\nCLASS Solution  \n    FUNCTION minDamage(self, power, damage, health)  \n        SET ans TO zero  \n        SET sumDamage TO the total sum of all elements IN damage  \n        SET enemies TO an empty list  \n        FOR index FROM zero TO the LENGTH OF damage MINUS one  \n            SET current_damage TO element at position index of damage  \n            SET current_health TO element at position index of health  \n            SET time_taken TO the result of dividing current_health PLUS power MINUS one BY power using integer division  \n            CREATE a new Enemy object with damage current_damage AND timeTakenDown time_taken  \n            APPEND this Enemy object TO enemies  \n        END FOR  \n        SORT enemies IN descending order based on the result of dividing the damage attribute of each enemy BY the timeTakenDown attribute of each enemy  \n\nPseudocode for Problem 5:\nCLASS Solution  \n    FUNCTION maximumSubarrayXor(alist PARAMETER, bqueries PARAMETER)  \n        SET m TO LENGTH OF alist  \n        SET dp1 TO A NEW LIST  \n        SET dp2 TO A NEW LIST  \n        SET p TO 0  \n        WHILE p < m  \n            SET row1 TO A NEW LIST  \n            SET row2 TO A NEW LIST  \n            SET q TO 0  \n            WHILE q < m  \n                APPEND 0 TO row1  \n                APPEND 0 TO row2  \n                SET q TO q + 1  \n            END WHILE  \n            APPEND row1 TO dp1  \n            APPEND row2 TO dp2  \n            SET p TO p + 1  \n        END WHILE  \n        SET r TO m - 1  \n\nModified Pseudocode for Problem 5:\nCLASS Solution  \n    FUNCTION maximumSubarrayXor(nums PARAMETER, queries PARAMETER)  \n        SET n TO the LENGTH OF nums  \n        SET f TO a two dimensional list FILLED WITH zero ELEMENTS of SIZE n BY n  \n        SET g TO a two dimensional list FILLED WITH zero ELEMENTS of SIZE n BY n  \n        FOR i FROM n MINUS one TO zero DECREASING BY one  \n            SET element at position i and position i of f TO element at position i of nums  \n            SET element at position i and position i of g TO element at position i of nums  \n            FOR j FROM i PLUS one TO n MINUS one INCREASING BY one  \n                SET element at position i and position j of f TO element at position i and position j MINUS one of f XOR element at position i PLUS one and position j of f  \n                SET element at position i and position j of g TO the MAXIMUM OF element at position i and position j of f AND element at position i and position j MINUS one of g AND element at position i PLUS one and position j of g  \n            END FOR  \n        END FOR  \n        RETURN a list COMPRISING element at position l and position r of g FOR each pair l and r IN queries  \n    END FUNCTION  \nEND CLASS\n\nPseudocode for Problem 6:\nCLASS Solution\n    FUNCTION minRectanglesToCoverPoints(qXyPa, qUt)\n        PROCEDURE orderAscending(ref eFsNn)\n            FOR mXf FROM 1 TO LENGTH(eFsNn) - 1\n                SET jMkZ TO mXf\n                WHILE jMkZ > 0 AND eFsNn[jMkZ][1] < eFsNn[jMkZ - 1][1]\n                    SET tempZiU TO eFsNn[jMkZ]\n                    SET eFsNn[jMkZ] TO eFsNn[jMkZ - 1]\n                    SET eFsNn[jMkZ - 1] TO tempZiU\n                    DECREMENT jMkZ BY 1\n                END WHILE\n            END FOR\n        END PROCEDURE\n\n        PROCEDURE incrementByOne(ref jqF)\n            SET jqF TO jqF + (2 - 1)\n        END PROCEDURE\n\n        PROCEDURE isGreaterThan(aQdW, bNso)\n            RETURN (aQdW - bNso) > 0\n\nModified Pseudocode for Problem 6:\nCLASS Solution  \n    FUNCTION minRectanglesToCoverPoints(points, w)  \n        SORT points IN ascending order BASED ON the first element of each point  \n        SET rectangles TO zero  \n        SET current_x TO negative one  \n        FOR each point x and y IN points  \n            IF x IS GREATER THAN current_x THEN  \n                SET current_x TO x PLUS w  \n                INCREMENT rectangles BY one  \n            END IF  \n        END FOR  \n        RETURN rectangles  \n    END FUNCTION  \nEND CLASS\n\nPseudocode for Problem 7:\nCLASS Solution\n    FUNCTION countOfPairs(n parameter, x parameter, y parameter) RETURNS list of integer\n        SET outputList TO an array containing n zeros indexed from 0 to n - 1\n\n        FUNCTION traverseGraph(origin parameter)\n            PROCEDURE addToQueueIfValid(idx parameter, queueRef, visitedRef, distRef)\n                IF  (idx >= 1) AND (idx <= n) AND (visitedRef[idx] = False)\n                    THEN\n                        visitedRef[idx] \u2190 True\n                        distRef[idx] \u2190 distRef[originPtr] + 1\n                        queueRef.append(idx)\n                END IF\n            END PROCEDURE\n\n            SET visitedNodes TO array of (n + 1) False values\n            SET nodeDistance TO array of (n + 1) zeros\n            SET originPtr TO origin\n            SET frontier TO deque with originPtr element added\n\n            WHILE NOT frontier.isEmpty()\n\nModified Pseudocode for Problem 7:\nCLASS Solution  \n    FUNCTION countOfPairs(n parameter, x parameter, y parameter) RETURNS list of integer  \n        SET result TO a list of zeros with the length equal to n  \n\n        FUNCTION bfs(start parameter)  \n            SET visited TO a list of boolean values False with the length equal to n PLUS one  \n            SET distance TO a list of zeros with the length equal to n PLUS one  \n            SET queue TO a double ended queue containing the start parameter only  \n            SET the element at position start parameter of visited TO True  \n            \n            WHILE the queue is not empty  \n                SET current TO the element removed from the front of queue  \n                \n                FOR each neighbor IN the list containing current MINUS one and current PLUS one  \n                    IF the neighbor is greater than or equal to one AND less than or equal to n AND the element at position neighbor of visited EQUALS False  \n                        SET the element at position neighbor of visited TO True  \n                        SET the element at position neighbor of distance TO the element at position current of distance PLUS one  \n                        APPEND neighbor TO the end of queue  \n                    END IF  \n                END FOR  \n\nPseudocode for Problem 8:\nCLASS Solution\n    FUNCTION maximumPrimeDifference(inputList)\n        FUNCTION isPrime(member)\n            SET primeCandidates TO [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n            SET found TO FALSE\n            SET position TO 0\n            WHILE position < LENGTH(primeCandidates) AND (NOT found)\n                IF primeCandidates[position] = member THEN\n                    SET found TO TRUE\n                END IF\n                SET position TO position + 1\n            END WHILE\n            RETURN found\n        END FUNCTION\n\n        SET idxFirstPrime TO -1\n        SET idxLastPrime TO -1\n\n        SET idxCursor TO 0\n        WHILE idxCursor < LENGTH(inputList)\n\nModified Pseudocode for Problem 8:\nCLASS Solution  \n    FUNCTION maximumPrimeDifference(nums)  \n        SET primes TO the set containing the following prime numbers two three five seven eleven thirteen seventeen nineteen twenty three twenty nine thirty one thirty seven forty one forty three forty seven fifty three fifty nine sixty one sixty seven seventy one seventy three seventy nine eighty three eighty nine ninety seven  \n        SET first_prime_index TO negative one  \n        SET last_prime_index TO negative one  \n        FOR each index i AND each number num IN the enumeration of nums  \n            IF num IS an element of primes  \n                IF first_prime_index EQUALS negative one  \n                    SET first_prime_index TO i  \n                END IF  \n                SET last_prime_index TO i  \n            END IF  \n        END FOR  \n        RETURN last_prime_index MINUS first_prime_index  \n    END FUNCTION  \nEND CLASS\nScore of -1*(BLEU Score) for ALL the problems: -0.06149909205293042"
}