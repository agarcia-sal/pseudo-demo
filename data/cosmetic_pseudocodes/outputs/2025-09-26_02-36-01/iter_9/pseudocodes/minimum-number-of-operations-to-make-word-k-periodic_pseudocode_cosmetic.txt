CLASS Solution
    FUNCTION minimumOperationsToMakeKPeriodic(word parameter k)
        FUNCTION countFrequencies(listInput)
            DECLARE freqMap AS EMPTY MAP
            DECLARE posIndex AS INTEGER ← 0
            WHILE posIndex < LENGTH_OF(listInput)
                DECLARE currentElem ← listInput[posIndex]
                IF NOT EXISTS freqMap[currentElem] THEN
                    freqMap[currentElem] ← 1
                ELSE
                    freqMap[currentElem] ← freqMap[currentElem] + 1
                END IF
                posIndex ← posIndex + 1
            END WHILE
            RETURN freqMap
        END FUNCTION

        FUNCTION findMaximumValue(mapInput)
            DECLARE maxVal AS INTEGER ← 0
            FOR key IN KEYS_OF(mapInput)
                IF mapInput[key] > maxVal THEN
                    maxVal ← mapInput[key]
                END IF
            END FOR
            RETURN maxVal
        END FUNCTION

        DECLARE lengthWord AS INTEGER ← LENGTH_OF(word)
        DECLARE collectedSegments AS LIST ← EMPTY LIST
        DECLARE stepIter AS INTEGER ← 0

        REPEAT
            IF stepIter >= lengthWord THEN
                BREAK
            END IF
            DECLARE segmentSubstr AS word[stepIter TO (stepIter + k - 1)]
            collectedSegments ← collectedSegments + [segmentSubstr]
            stepIter ← stepIter + k
        UNTIL FALSE

        DECLARE frequencyCount AS MAP ← countFrequencies(collectedSegments)
        DECLARE highestFrequency AS INTEGER ← findMaximumValue(frequencyCount)
        DECLARE finalAnswer AS INTEGER ← (LENGTH_OF(collectedSegments) - highestFrequency)
        RETURN finalAnswer
    END FUNCTION
END CLASS