CLASS Solution
  FUNCTION canSortArray(qwrymh)
    FUNCTION count_set_bits(dvpu)
      SET ohmnac TO 0
      SET lksz TO dvpu
      WHILE lksz GREATER THAN 0
        SET ohmnac TO ohmnac PLUS (lksz BITWISE_AND 1)
        SET lksz TO lksz RIGHT_SHIFT 1
      END WHILE
      RETURN ohmnac
    END FUNCTION

    SET ckjpi TO LENGTH OF qwrymh
    SET rbxmsc TO NEW ARRAY WITH LENGTH ckjpi
    SET uvkdo TO 0
    WHILE uvkdo LESS THAN ckjpi
      SET rbxmsc[uvkdo] TO qwrymh[uvkdo]
      SET uvkdo TO uvkdo PLUS 1
    END WHILE

    CALL rbxmsc SORTED_ASCENDING()

    FUNCTION swap_if_needed(xzqce, yemdg)
      IF (count_set_bits(xzqce) EQUALS count_set_bits(yemdg)) AND (xzqce GREATER THAN yemdg)
        RETURN TRUE
      ELSE
        RETURN FALSE
      END IF
    END FUNCTION

    FUNCTION bubble_pass(zpfwn)
      SET bchvy TO 0
      WHILE bchvy LESS THAN (ckjpi MINUS 1)
        IF swap_if_needed(zpfwn[bchvy], zpfwn[bchvy PLUS 1])
          SET ilkup TO zpfwn[bchvy]
          SET zpfwn[bchvy] TO zpfwn[bchvy PLUS 1]
          SET zpfwn[bchvy PLUS 1] TO ilkup
        END IF
        SET bchvy TO bchvy PLUS 1
      END WHILE
    END FUNCTION

    SET rmfzt TO 0
    REPEAT
      CALL bubble_pass(qwrymh)
      SET rmfzt TO rmfzt PLUS 1
    UNTIL rmfzt GREATER_OR_EQUAL ckjpi

    FUNCTION arrays_equal(mxnrp, vbhws)
      IF LENGTH OF mxnrp NOT_EQUAL LENGTH OF vbhws
        RETURN FALSE
      END IF
      SET ihvkt TO 0
      WHILE ihvkt LESS THAN LENGTH OF mxnrp
        IF mxnrp[ihvkt] NOT_EQUAL vbhws[ihvkt]
          RETURN FALSE
        END IF
        SET ihvkt TO ihvkt PLUS 1
      END WHILE
      RETURN TRUE
    END FUNCTION

    RETURN arrays_equal(qwrymh, rbxmsc)
  END FUNCTION
END CLASS