CLASS Solution
	FUNCTION maxPathLength(cords, p)
		DEFINE FUNCTION _appendLeft(coords, boundX, boundY)
			LET acc = []
			LET idx = 0
			WHILE idx < LENGTH(coords)
				LET a = coords[idx][0]
				LET b = coords[idx][1]
				IF a < boundX
					IF b < boundY
						acc = acc + [ [a, b] ]
					END IF
				END IF
				SET idx TO idx + 1
			END WHILE
			RETURN acc
		END FUNCTION

		DEFINE FUNCTION _appendRight(coords, boundX, boundY)
			LET outList = []
			LET cursor = 0
			REPEAT
				LET c = coords[cursor][0]
				LET d = coords[cursor][1]
				IF NOT (c <= boundX OR d <= boundY)
					outList = outList + [ [c, d] ]
				END IF
				LET cursor = cursor + 1
			UNTIL cursor >= LENGTH(coords)
			RETURN outList
		END FUNCTION

		LET refX = coordinates[p][0]
		LET refY = coordinates[p][1]

		LET leftSet = _appendLeft(coordinates, refX, refY)
		LET rightSet = _appendRight(coordinates, refX, refY)

		RETURN 1 + self._lengthOfLIS(leftSet) + self._lengthOfLIS(rightSet)
	END FUNCTION


	FUNCTION _lengthOfLIS(coordsList)
		DEFINE FUNCTION _bisectLeft(arr, val)
			LET low = 0
			LET high = LENGTH(arr)
			WHILE low < high
				LET mid = (low + high) // 2
				IF arr[mid] < val
					LET low = mid + 1
				ELSE
					LET high = mid
				END IF
			END WHILE
			RETURN low
		END FUNCTION

		LET sortedList = []
		LET i = 0
		WHILE i < LENGTH(coordsList)
			sortedList = sortedList + [coordsList[i]]
			SET i TO i + 1
		END WHILE

		LET m = LENGTH(sortedList)

		IF m > 1
			FOR j FROM 0 TO m-2
				FOR l FROM j+1 TO m-1
					LET cond1 = sortedList[j][0] > sortedList[l][0]
					LET cond2 = (sortedList[j][0] = sortedList[l][0]) AND (sortedList[j][1] < sortedList[l][1])
					IF cond1 OR cond2
						LET tmp = sortedList[j]
						sortedList[j] = sortedList[l]
						sortedList[l] = tmp
					END IF
				END FOR
			END FOR
		END IF

		LET pile = []
		LET index = 0
		REPEAT
			IF index >= LENGTH(sortedList)
				EXIT REPEAT
			END IF
			LET valY = sortedList[index][1]
			IF LENGTH(pile) = 0
				pile = pile + [valY]
			ELSE
				LET last = pile[LENGTH(pile) - 1]
				IF valY > last
					pile = pile + [valY]
				ELSE
					LET pos = _bisectLeft(pile, valY)
					pile[pos] = valY
				END IF
			END IF
			LET index = index + 1
		UNTIL false

		RETURN LENGTH(pile)
	END FUNCTION
END CLASS