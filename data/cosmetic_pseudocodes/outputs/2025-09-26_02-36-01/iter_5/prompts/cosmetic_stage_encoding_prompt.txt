Given an input pseudocode, generate a rewritten version that satisfies all these conditions strictly:

- Functional equivalence: The rewritten pseudocode must implement exactly the same functionality, returning the same results, side effects, and maintaining all logic.

- Preserve identifiers critical to external interfaces and structure **exactly** and **verbatim**:  
  - All class names remain unchanged.  
  - All function and method names remain unchanged.  
  - The class hierarchy, inheritance, and object structures remain unchanged.  
  - Function/method signatures (parameter lists, their order, and return types if present) remain exactly as in the original.  

- Transformation scope: All other elements not listed above should be transformed as extensively as possible to maximize syntactic, stylistic, and structural divergence, including but not limited to:  
  - Replace all loop types with alternative equivalent constructs (e.g., for → while → recursion) where feasible.  
  - Rename all local variables and parameters to new, semantically equivalent but distinct names, avoiding any original local identifiers.  
  - Reformulate expressions to equivalent forms using alternative arithmetic, logical, or indexing expressions (e.g., replace += with explicit assignment, use De Morgan’s laws for conditions, swap index access styles).  
  - Restructure control flow by unrolling/folding loops, splitting/merging conditionals, and rearranging statement orders where it does not alter correctness or data dependencies.  
  - Introduce auxiliary intermediate variables, extract or inline sub-expressions differently, and adjust expression grouping without changing meaning.  
  - Modify literal representations consistently (e.g., spell out numbers, use arithmetic to produce constants, represent booleans differently).  
  - Alter formatting details (e.g., change indentation style, spacing, block delimiters) distinctly from the original style.  
  - Replace direct returns with stored variables and final return statements; conversely, inline returns where possible.  
  - Convert iterative constructs into recursive ones or vice versa if it preserves semantics and language constraints.  
  - Change data structure traversal orders, provided output or side effects remain identical.  
  - Substitute functionally identical built-in operations or routines with equivalent alternatives or helper functions you define within the pseudocode.  
  - Avoid any re-use of original variable names except those explicitly required to remain unchanged.

- Strictly no addition or deletion of overall logic, algorithmic steps, or data structures; no introducing conceptual shortcuts or optimizations that alter the approach.

- Output must be exactly the rewritten pseudocode, without any explanations, annotations, comments, or supplemental text.

- The rewritten pseudocode must appear as an independently authored, fully autonomous alternative, maximally distinct syntactically and stylistically from the input pseudocode, while guaranteeing semantic equivalence and preserving all original class and function names and hierarchy exactly as in the input.

- Apply this universally to any input pseudocode regardless of domain or content.

- Your response is just the transformed pseudocode.

---

This prompt is crafted to exploit multiple orthogonal transformations beyond typical renaming and loop swapping, including recursive conversions, expression reformulations, control flow reshaping, and extensive stylistic changes, thus maximizing surface divergence while preserving semantics and required identifiers rigidly.