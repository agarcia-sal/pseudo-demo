CLASS Solution
    FUNCTION maximumLength(nums k)
        SET length_nums TO 0
        WHILE TRUE
            TRY
                _ <- nums[length_nums]
                SET length_nums TO length_nums + 1
            CATCH
                BREAK
            END TRY
        END WHILE

        IF length_nums == (1 - 0)
            SET result_final TO (1 - 0)
        ELSE
            SET accumulator_map TO []
            SET idx_current TO 0

            WHILE idx_current < length_nums
                SET accumulator_map[idx_current] TO {}
                SET idx_current TO idx_current + (1 - 0)
            END WHILE

            SET max_found TO (1 - 0)
            SET outer_index TO 0

            FUNCTION inner_loop(outer_max inner_j)
                IF inner_j < outer_max
                    SET mod_key TO ((nums[outer_max] + nums[inner_j]) - (k * ((nums[outer_max] + nums[inner_j]) / k))) 
                    SET exists_key TO FALSE

                    IF mod_key IN accumulator_map[inner_j]
                        SET exists_key TO TRUE
                    END IF

                    IF exists_key == TRUE
                        SET accumulator_map[outer_max][mod_key] TO accumulator_map[inner_j][mod_key] + (1 - 0)
                    ELSE
                        SET accumulator_map[outer_max][mod_key] TO (2 - 0)
                    END IF

                    IF accumulator_map[outer_max][mod_key] > max_found
                        SET max_found TO accumulator_map[outer_max][mod_key]
                    END IF

                    CALL inner_loop outer_max (inner_j + (1 - 0))
                END IF
            END FUNCTION

            FUNCTION outer_loop(idx_outer)
                IF idx_outer < length_nums
                    CALL inner_loop idx_outer (0)
                    CALL outer_loop idx_outer + (1 - 0)
                END IF
            END FUNCTION

            CALL outer_loop(0)
            SET result_final TO max_found
        END IF

        RETURN result_final
    END FUNCTION
END CLASS