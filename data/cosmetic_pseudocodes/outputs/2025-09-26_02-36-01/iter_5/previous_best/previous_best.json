{
  "prompt": "Given an input pseudocode, generate a rewritten version that satisfies all these conditions strictly:\n\n- Functional equivalence: The rewritten pseudocode must implement exactly the same functionality, returning the same results, side effects, and maintaining all logic.\n\n- Preserve identifiers critical to external interfaces and structure **exactly** and **verbatim**:  \n  - All class names remain unchanged.  \n  - All function and method names remain unchanged.  \n  - The class hierarchy, inheritance, and object structures remain unchanged.  \n  - Function/method signatures (parameter lists, their order, and return types if present) remain exactly as in the original.  \n\n- Transformation scope: All other elements not listed above should be transformed as extensively as possible to maximize syntactic, stylistic, and structural divergence, including but not limited to:  \n  - Replace all loop types with alternative equivalent constructs (e.g., for \u2192 while \u2192 recursion) where feasible.  \n  - Rename all local variables and parameters to new, semantically equivalent but distinct names, avoiding any original local identifiers.  \n  - Reformulate expressions to equivalent forms using alternative arithmetic, logical, or indexing expressions (e.g., replace += with explicit assignment, use De Morgan\u2019s laws for conditions, swap index access styles).  \n  - Restructure control flow by unrolling/folding loops, splitting/merging conditionals, and rearranging statement orders where it does not alter correctness or data dependencies.  \n  - Introduce auxiliary intermediate variables, extract or inline sub-expressions differently, and adjust expression grouping without changing meaning.  \n  - Modify literal representations consistently (e.g., spell out numbers, use arithmetic to produce constants, represent booleans differently).  \n  - Alter formatting details (e.g., change indentation style, spacing, block delimiters) distinctly from the original style.  \n  - Replace direct returns with stored variables and final return statements; conversely, inline returns where possible.  \n  - Convert iterative constructs into recursive ones or vice versa if it preserves semantics and language constraints.  \n  - Change data structure traversal orders, provided output or side effects remain identical.  \n  - Substitute functionally identical built-in operations or routines with equivalent alternatives or helper functions you define within the pseudocode.  \n  - Avoid any re-use of original variable names except those explicitly required to remain unchanged.\n\n- Strictly no addition or deletion of overall logic, algorithmic steps, or data structures; no introducing conceptual shortcuts or optimizations that alter the approach.\n\n- Output must be exactly the rewritten pseudocode, without any explanations, annotations, comments, or supplemental text.\n\n- The rewritten pseudocode must appear as an independently authored, fully autonomous alternative, maximally distinct syntactically and stylistically from the input pseudocode, while guaranteeing semantic equivalence and preserving all original class and function names and hierarchy exactly as in the input.\n\n- Apply this universally to any input pseudocode regardless of domain or content.\n\n- Your response is just the transformed pseudocode.\n\n---\n\nThis prompt is crafted to exploit multiple orthogonal transformations beyond typical renaming and loop swapping, including recursive conversions, expression reformulations, control flow reshaping, and extensive stylistic changes, thus maximizing surface divergence while preserving semantics and required identifiers rigidly.",
  "response": "Given an input pseudocode, generate a rewritten version that satisfies all these conditions strictly:\n\n- Functional equivalence: The rewritten pseudocode must implement exactly the same functionality, returning the same results, side effects, and maintaining all logic.\n\n- Preserve identifiers critical to external interfaces and structure **exactly** and **verbatim**:  \n  - All class names remain unchanged.  \n  - All function and method names remain unchanged.  \n  - The class hierarchy, inheritance, and object structures remain unchanged.  \n  - Function/method signatures (parameter lists, their order, and return types if present) remain exactly as in the original.  \n\n- Transformation scope: All other elements not listed above should be transformed as extensively as possible to maximize syntactic, stylistic, and structural divergence, including but not limited to:  \n  - Replace all loop types with alternative equivalent constructs (e.g., for \u2192 while \u2192 recursion) where feasible.  \n  - Rename all local variables and parameters to new, semantically equivalent but distinct names, avoiding any original local identifiers.  \n  - Reformulate expressions to equivalent forms using alternative arithmetic, logical, or indexing expressions (e.g., replace += with explicit assignment, use De Morgan\u2019s laws for conditions, swap index access styles).  \n  - Restructure control flow by unrolling/folding loops, splitting/merging conditionals, and rearranging statement orders where it does not alter correctness or data dependencies.  \n  - Introduce auxiliary intermediate variables, extract or inline sub-expressions differently, and adjust expression grouping without changing meaning.  \n  - Modify literal representations consistently (e.g., spell out numbers, use arithmetic to produce constants, represent booleans differently).  \n  - Alter formatting details (e.g., change indentation style, spacing, block delimiters) distinctly from the original style.  \n  - Replace direct returns with stored variables and final return statements; conversely, inline returns where possible.  \n  - Convert iterative constructs into recursive ones or vice versa if it preserves semantics and language constraints.  \n  - Change data structure traversal orders, provided output or side effects remain identical.  \n  - Substitute functionally identical built-in operations or routines with equivalent alternatives or helper functions you define within the pseudocode.  \n  - Avoid any re-use of original variable names except those explicitly required to remain unchanged.\n\n- Strictly no addition or deletion of overall logic, algorithmic steps, or data structures; no introducing conceptual shortcuts or optimizations that alter the approach.\n\n- Output must be exactly the rewritten pseudocode, without any explanations, annotations, comments, or supplemental text.\n\n- The rewritten pseudocode must appear as an independently authored, fully autonomous alternative, maximally distinct syntactically and stylistically from the input pseudocode, while guaranteeing semantic equivalence and preserving all original class and function names and hierarchy exactly as in the input.\n\n- Apply this universally to any input pseudocode regardless of domain or content.\n\n- Your response is just the transformed pseudocode.\n\n---\n\nThis prompt is crafted to exploit multiple orthogonal transformations beyond typical renaming and loop swapping, including recursive conversions, expression reformulations, control flow reshaping, and extensive stylistic changes, thus maximizing surface divergence while preserving semantics and required identifiers rigidly.",
  "score": -0.07931383145534733,
  "feedback": "The following are 20 lines of original pseudocode of a random subset of the problems along with their modified pseudocodes.\n\nPseudocode for Problem 1:\nCLASS Solution\n    FUNCTION numberOfWays(n integer parameter, x integer parameter, y integer parameter) RETURNS integer\n        SET constant_mod TO 1000000000 PLUS 7\n        DEFINE FUNCTION buildMatrix(rowCount integer, colCount integer) RETURNS list of lists\n            IF rowCount EQUALS 0 THEN RETURN []\n            ELSE\n                SET head TO list of zeros length colCount\n                SET tail TO buildMatrix(rowCount MINUS 1, colCount)\n                RETURN [head] CONCATENATE tail\n            END IF\n        END FUNCTION\n\n        SET table TO buildMatrix(n PLUS 1, x PLUS 1)\n        SET table AT zero AT zero TO 1\n\n        DEFINE FUNCTION outerLoop(current_row integer)\n            IF current_row GREATER THAN n THEN RETURN\n            ELSE\n                DEFINE FUNCTION innerLoop(current_col integer)\n                    IF current_col GREATER THAN x THEN RETURN\n\nModified Pseudocode for Problem 1:\nCLASS Solution  \n    FUNCTION numberOfWays(n integer parameter, x integer parameter, y integer parameter) RETURNS integer  \n        SET mod TO one billion PLUS seven  \n        SET f TO a list of lists of zeros with the outer list length equal to n PLUS one and each inner list length equal to x PLUS one  \n        SET the element at position zero of list at position zero of f TO one  \n        FOR i FROM one TO n INCLUSIVE  \n            FOR j FROM one TO x INCLUSIVE  \n                SET the element at position i of list at position j of f TO the remainder of the sum of the product of the element at position i MINUS one of list at position j of f MULTIPLIED BY j and the product of the element at position i MINUS one of list at position j MINUS one of f MULTIPLIED BY the difference of x MINUS the difference of j MINUS one when divided by mod  \n            END FOR  \n        END FOR  \n        SET ans TO zero  \n        SET p TO one  \n        FOR j FROM one TO x INCLUSIVE  \n            SET p TO the remainder of the product of p MULTIPLIED BY y when divided by mod  \n            SET ans TO the remainder of the sum of ans and the product of the element at position n of list at position j of f MULTIPLIED BY p when divided by mod  \n        END FOR  \n        RETURN ans  \n    END FUNCTION  \nEND CLASS\n\nPseudocode for Problem 2:\nCLASS Solution\n    FUNCTION maxTotalReward(rewardValues)\n        DEFINE FUNCTION accumulateFlags(index, flagAcc)\n            IF NOT (index < LENGTH(rewardValues))\n                RETURN flagAcc\n            ELSE\n                DEFINE currentVal AS rewardValues[index]\n                DEFINE bitmask AS ((ONE << currentVal) - ONE) << currentVal\n                RETURN accumulateFlags(index + ONE, flagAcc | (flagAcc & bitmask))\n            END IF\n        END FUNCTION\n\n        DEFINE sortedUniqueValues AS LIST(SORT(SET(rewardValues)))\n        DEFINE totalFlags AS accumulateFlags(ZERO, ONE)\n        DEFINE resultVal AS BIT_LENGTH(totalFlags) - ONE\n        RETURN resultVal\n    END FUNCTION\nEND CLASS\n\nModified Pseudocode for Problem 2:\nCLASS Solution  \n    FUNCTION maxTotalReward(rewardValues)  \n        SET nums TO the SORTED SET OF elements IN rewardValues  \n        SET f TO one  \n        FOR each v IN nums  \n            SET f TO f OR the BITWISE AND of f AND the DIFFERENCE of the VALUE one SHIFTED LEFT BY v and one, SHIFTED LEFT BY v  \n        END FOR  \n        RETURN the BIT LENGTH OF f MINUS one  \n    END FUNCTION  \nEND CLASS\n\nPseudocode for Problem 3:\nCLASS Solution  \n    FUNCTION numberOfStableArrays(aCount aCount, bCount bCount, maxRun maxRun) RETURNS integer  \n        LET modulus = (5 * 2) * (10 ^ 8) + 1  \n        \n        FUNCTION dp(remZero remZero, remOne remOne, lastDigit lastDigit, runLength runLength) RETURNS integer  \n            VAR resultHolder, callResult, updatedRunCount, nextResult, updatedZeroCount, updatedOneCount\n            \n            IF NOT (remZero OR remOne) THEN\n                LET resultHolder = 1  \n            ELSE IF remZero < 0 OR remOne < 0 THEN\n                LET resultHolder = 0\n            ELSE \n                LET resultHolder = 0\n                IF lastDigit = 0 THEN\n                    IF runLength < maxRun THEN\n                        LET updatedZeroCount = remZero - 1\n                        LET updatedOneCount = remOne\n                        LET updatedRunCount = runLength + (1 - 0)\n                        LET callResult = dp(updatedZeroCount, updatedOneCount, 0, updatedRunCount)\n                        LET resultHolder = resultHolder + callResult\n\nModified Pseudocode for Problem 3:\nCLASS Solution  \n    FUNCTION numberOfStableArrays(zero zero, one one, limit limit) RETURNS integer  \n        SET MOD TO ten raised to the power of nine PLUS one  \n  \n        FUNCTION dp(z z, o o, last last, consecutive consecutive) RETURNS integer  \n            IF z EQUALS zero AND o EQUALS zero THEN  \n                RETURN one  \n            END IF  \n            IF z LESS THAN zero OR o LESS THAN zero THEN  \n                RETURN zero  \n            END IF  \n  \n            SET total TO zero  \n            IF last EQUALS zero THEN  \n                IF consecutive LESS THAN limit THEN  \n                    INCREMENT total BY the result of dp with parameters z MINUS one o o zero zero consecutive PLUS one  \n                END IF  \n                INCREMENT total BY the result of dp with parameters z o MINUS one one one one  \n            ELSE  \n                IF z GREATER THAN zero THEN  \n\nPseudocode for Problem 4:\nCLASS Solution\n    FUNCTION minimumTime(count, connections, vanish_times)\n        DEFINE FUNCTION pop_min(heap_list)\n            DEFINE FUNCTION sift_down(h, start_pos, pos)\n                SET left_idx TO (pos * 2) + 1\n                IF left_idx >= len(h)\n                    RETURN\n                ENDIF\n                SET smallest_idx TO pos\n                SET right_idx TO left_idx + 1\n                IF right_idx < len(h) AND h[right_idx][0] < h[left_idx][0]\n                    SET smallest_idx TO right_idx\n                ELSE\n                    SET smallest_idx TO left_idx\n                ENDIF\n                IF h[smallest_idx][0] < h[pos][0]\n                    SWAP h[pos], h[smallest_idx]\n                    CALL sift_down(h, start_pos, smallest_idx)\n                ENDIF\n            END FUNCTION\n\nModified Pseudocode for Problem 4:\nCLASS Solution  \n    FUNCTION minimumTime(n, edges, disappear)  \n        SET graph TO an empty mapping with default value an empty list  \n        FOR each u v length IN edges  \n            APPEND tuple of neighbor v and length TO the list at key u in graph  \n            APPEND tuple of neighbor u and length TO the list at key v in graph  \n        END FOR  \n          \n        SET distances TO a list of length n with each element set to infinity  \n        SET element at position zero of distances TO zero  \n          \n        SET min_heap TO a list containing a tuple of zero and zero  \n          \n        WHILE the LENGTH OF min_heap holds greater than zero  \n            REMOVE the tuple with the smallest first element from min_heap and ASSIGN to current_distance and current_node  \n              \n            IF current_distance GREATER THAN OR EQUAL TO element at position current_node of disappear  \n                CONTINUE to next iteration of WHILE loop  \n            END IF  \n              \n\nPseudocode for Problem 5:\nCLASS Solution\n    FUNCTION maxUpgrades(count LIST OF INTEGER upgrade LIST OF INTEGER sell LIST OF INTEGER money LIST OF INTEGER) RETURNS LIST OF INTEGER\n        SET result TO EMPTY LIST\n        SET pos TO 0\n        WHILE pos < LENGTH(count) DO\n            SET current_count TO count[pos]\n            SET cost_upgrade TO upgrade[pos]\n            SET price_sell TO sell[pos]\n            SET funds TO money[pos]\n            SET best_upgrade_number TO 0\n\n            FUNCTION scan_sell(sell_iter INTEGER)\n                IF sell_iter > current_count THEN\n                    RETURN\n                END IF\n                SET leftover_servers TO current_count - sell_iter\n                SET cash_after_sale TO funds + (sell_iter * price_sell)\n                SET possible_upgrs TO cash_after_sale DIV cost_upgrade\n                IF possible_upgrs > leftover_servers THEN\n                    SET possible_upgrs TO leftover_servers\n\nModified Pseudocode for Problem 5:\nCLASS Solution  \n    FUNCTION maxUpgrades(count LIST OF INTEGER upgrade LIST OF INTEGER sell LIST OF INTEGER money LIST OF INTEGER) RETURNS LIST OF INTEGER  \n        SET answer TO empty list  \n        FOR index FROM zero TO the LENGTH OF count MINUS one  \n            SET num_servers TO element at position index of count  \n            SET upgrade_cost TO element at position index of upgrade  \n            SET sell_price TO element at position index of sell  \n            SET initial_money TO element at position index of money  \n            SET max_upgrades TO zero  \n            SET remaining_money TO initial_money  \n            FOR sell_count FROM zero TO num_servers  \n                SET remaining_servers TO num_servers MINUS sell_count  \n                SET money_from_selling TO sell_count MULTIPLIED BY sell_price  \n                SET total_money TO remaining_money PLUS money_from_selling  \n                SET possible_upgrades TO total_money DIVIDED BY upgrade_cost  \n                IF possible_upgrades GREATER THAN remaining_servers  \n                    SET possible_upgrades TO remaining_servers  \n                END IF  \n                IF possible_upgrades GREATER THAN max_upgrades  \n                    SET max_upgrades TO possible_upgrades  \n\nPseudocode for Problem 6:\nCLASS Solution\n    FUNCTION minimumOperationsToMakeKPeriodic(word argument_k)\n        DEFINE FUNCTION countOccurrences(list_ref, key_value)\n            IF list_ref IS EMPTY THEN\n                RETURN 0\n            ELSE\n                SET head_element TO list_ref[0]\n                SET tail_list TO list_ref[1 TO LENGTH OF list_ref]\n                IF head_element EQUALS key_value THEN\n                    RETURN 1 + countOccurrences(tail_list, key_value)\n                ELSE\n                    RETURN countOccurrences(tail_list, key_value)\n                END IF\n            END IF\n        END FUNCTION\n\n        SET length_word TO ( (1 + LENGTH OF word) - 1 )\n        SET collected_segments TO []\n        DEFINE FUNCTION collectSegments(current_pos, accum_segments)\n            IF current_pos > length_word THEN\n\nModified Pseudocode for Problem 6:\nCLASS Solution  \n    FUNCTION minimumOperationsToMakeKPeriodic(word parameter k)  \n        SET n TO the LENGTH OF word  \n        SET segments TO an EMPTY LIST  \n        FOR index FROM zero TO n MINUS one IN STEPS OF k  \n            APPEND the substring from position index TO position index PLUS k MINUS one of word TO segments  \n        END FOR  \n        SET segment_count TO the COUNT OF EACH UNIQUE ELEMENT IN segments  \n        SET max_count TO the HIGHEST OCCURRENCE COUNT AMONG THE UNIQUE ELEMENTS IN segment_count  \n        SET result TO the LENGTH OF segments MINUS max_count  \n        RETURN result  \n    END FUNCTION  \nEND CLASS\n\nPseudocode for Problem 7:\nCLASS Solution\n    FUNCTION isArraySpecial(nums, queries)\n        FUNCTION modTwo(value)\n            RETURN value - (value / 2) * 2\n        END FUNCTION\n\n        FUNCTION boolToInt(flag)\n            IF flag = TRUE RETURN 1 ELSE RETURN 0 END IF\n        END FUNCTION\n\n        SET parity_sequence TO empty list\n        PROCEDURE build_parity(index)\n            IF index >= LENGTH nums THEN RETURN END IF\n            APPEND modTwo(nums[index]) TO parity_sequence\n            CALL build_parity(index + 1)\n        END PROCEDURE\n        CALL build_parity(0)\n\n        SET prefix_special TO list of zeros with size LENGTH nums\n        FUNCTION fill_prefix(index)\n\nModified Pseudocode for Problem 7:\nCLASS Solution  \n    FUNCTION isArraySpecial(nums, queries)  \n        SET parity TO an empty list  \n        FOR each num IN nums  \n            APPEND the remainder of num DIVIDED BY two TO parity  \n        END FOR  \n        \n        SET prefix_special TO a list of zeros with LENGTH EQUAL TO the LENGTH OF nums  \n        FOR i FROM one TO the LENGTH OF nums MINUS one  \n            IF element at position i of parity NOT EQUALS element at position i MINUS one of parity  \n                SET element at position i of prefix_special TO element at position i MINUS one of prefix_special  \n            ELSE  \n                SET element at position i of prefix_special TO element at position i MINUS one of prefix_special PLUS one  \n            END IF  \n        END FOR  \n        \n        SET result TO an empty list  \n        FOR each start and end IN queries  \n            IF start EQUALS end  \n                APPEND True TO result  \n\nPseudocode for Problem 8:\nCLASS Solution  \n    FUNCTION maxNumber(num)  \n        SET result TO 0  \n        IF NOT (num NOT EQUAL TO 1) THEN  \n            SET result TO 0  \n        ELSE  \n            SET bit_marker TO 1  \n            CALL findBit(bit_marker, num)  \n            SET bit_marker TO bit_marker / 2  \n            SET interim TO bit_marker - 1  \n            SET result TO interim  \n        END IF  \n        RETURN result  \n    END FUNCTION  \n  \n    FUNCTION findBit(current, threshold)  \n        IF current <= threshold THEN  \n            SET updated TO current * 2  \n            CALL findBit(updated, threshold)  \n        END IF  \n\nModified Pseudocode for Problem 8:\nCLASS Solution  \n    FUNCTION maxNumber(n)  \n        IF n EQUALS one  \n            RETURN zero  \n        END IF  \n        SET highest_bit TO one  \n        WHILE highest_bit LESS THAN OR EQUAL TO n  \n            SET highest_bit TO highest_bit MULTIPLIED BY two  \n        END WHILE  \n        SET highest_bit TO highest_bit DIVIDED BY two  \n        SET x TO highest_bit MINUS one  \n        RETURN x  \n    END FUNCTION  \nEND CLASS\nScore of -1*(BLEU Score) for ALL the problems: -0.07931383145534733"
}