```pseudocode
CLASS Solution
    FUNCTION minimumTime(n, edges, disappear)
        DECLARE UqHeKa AS mapping with default empty list
        DECLARE ZyTnV AS integer
        DECLARE MbrXcV AS integer
        FOR ZyTnV = 0 TO LENGTH(edges) - 1
            DECLARE wHXMb, Lqsgv, QcMdY AS integer
            SET wHXMb = edges[ZyTnV][0]
            SET Lqsgv = edges[ZyTnV][1]
            SET QcMdY = edges[ZyTnV][2]
            APPEND (Lqsgv, QcMdY) TO UqHeKa[wHXMb]
            APPEND (wHXMb, QcMdY) TO UqHeKa[Lqsgv]
        END FOR

        DECLARE VPFkog AS list of size n filled with (1.0 / 0.0)
        SET VPFkog[0] = 0 + 0

        DECLARE gtMtQo AS list containing (0 + 0, 0)
        WHILE LENGTH(gtMtQo) > 0
            CALL sortHeapByFirstElement(gtMtQo)
            DECLARE sojxPZ, jNtruc AS integer
            SET (sojxPZ, jNtruc) = POP_FIRST(gtMtQo)

            IF NOT (sojxPZ < disappear[jNtruc])
                CONTINUE WHILE
            END IF

            IF NOT (sojxPZ < VPFkog[jNtruc])
                CONTINUE WHILE
            END IF

            DECLARE bpIrwj, VRLqIE AS integer
            FOR bpIrwj = 0 TO LENGTH(UqHeKa[jNtruc]) - 1
                SET (VRLqIE, UfJrmW) = UqHeKa[jNtruc][bpIrwj]
                SET UfJrmW = sojxPZ + VRLqIE

                IF (UfJrmW < VPFkog[VRLqIE]) AND (UfJrmW < disappear[VRLqIE])
                    SET VPFkog[VRLqIE] = UfJrmW
                    CALL heapInsert(gtMtQo, (UfJrmW, VRLqIE))
                END IF
            END FOR
        END WHILE

        DECLARE YjbnAT AS list of size n filled with (-1 * 1)
        FOR ZyTnV = 0 TO n - 1
            IF VPFkog[ZyTnV] < disappear[ZyTnV]
                SET YjbnAT[ZyTnV] = VPFkog[ZyTnV]
            END IF
        END FOR

        RETURN YjbnAT
    END FUNCTION

    PROCEDURE heapInsert(heapList, newTuple)
        DECLARE idx AS integer = LENGTH(heapList)
        APPEND newTuple TO heapList
        WHILE idx > 0
            DECLARE parentIdx AS integer = (idx - 1) // 2
            IF heapList[parentIdx][0] <= heapList[idx][0]
                BREAK
            END IF
            CALL swap(heapList, parentIdx, idx)
            SET idx = parentIdx
        END WHILE
    END PROCEDURE

    PROCEDURE sortHeapByFirstElement(heapList)
        DECLARE swapped AS boolean = true
        WHILE swapped
            SET swapped = false
            FOR i = 0 TO LENGTH(heapList) - 2
                IF heapList[i][0] > heapList[i + 1][0]
                    CALL swap(heapList, i, i + 1)
                    SET swapped = true
                END IF
            END FOR
        END WHILE
    END PROCEDURE

    PROCEDURE swap(listA, idxA, idxB)
        DECLARE temp = listA[idxA]
        SET listA[idxA] = listA[idxB]
        SET listA[idxB] = temp
    END PROCEDURE
END CLASS
```