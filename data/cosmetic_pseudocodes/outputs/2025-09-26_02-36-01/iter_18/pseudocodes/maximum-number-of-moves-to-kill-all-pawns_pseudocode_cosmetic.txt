```pseudocode
CLASS Solution
	Function maxMoves(x_1, y_1, pos_list)
		CONST knightDirs = [(2,1),(1,2),(-1,2),(-2,1),(-2,-1),(-1,-2),(1,-2),(2,-1)]
		VAR pawns_set <- empty set
		FOR elt IN pos_list
			INSERT tuple(elt[0], elt[1]) INTO pawns_set
		END FOR
		VAR total_pawns <- SIZE(pawns_set)

		Function recurse(a_x, a_y, stateMask, aliceTurn)
			IF stateMask = 0 THEN
				RETURN 0
			END IF
			VAR resultVal
			IF aliceTurn THEN
				resultVal <- 0
			ELSE
				resultVal <- +∞
			END IF

			VAR idx <- 0
			WHILE idx < total_pawns
				IF (stateMask BITWISE-AND (1 << idx)) ≠ 0 THEN
					VAR targetX <- pos_list[idx][0]
					VAR targetY <- pos_list[idx][1]

					VAR toVisitQueue <- [(a_x, a_y, 0)]
					VAR discovered <- empty set
					INSERT (a_x, a_y) INTO discovered
					VAR foundFlag <- False

					WHILE SIZE(toVisitQueue) > 0
						VAR curr := REMOVE-FIRST(toVisitQueue)
						VAR curX <- curr[0]
						VAR curY <- curr[1]
						VAR dist <- curr[2]

						IF (curX = targetX) AND (curY = targetY) THEN
							foundFlag <- True
							EXIT WHILE
						END IF

						FOR d IN knightDirs
							VAR nx <- curX + d[0]
							VAR ny <- curY + d[1]

							IF (nx ≥ 0) AND (nx < 50) AND (ny ≥ 0) AND (ny < 50) AND NOT ((nx, ny) IN discovered) THEN
								INSERT (nx, ny) INTO discovered
								APPEND (nx, ny, dist+1) TO toVisitQueue
							END IF
						END FOR
					END WHILE

					IF foundFlag THEN
						VAR nextMask <- stateMask XOR (1 << idx)
						VAR alternative <- dist + recurse(targetX, targetY, nextMask, NOT aliceTurn)

						IF aliceTurn THEN
							IF resultVal < alternative THEN
								resultVal <- alternative
							END IF
						ELSE
							IF resultVal > alternative THEN
								resultVal <- alternative
							END IF
						END IF
					END IF
				END IF
				idx <- idx + 1
			END WHILE

			RETURN resultVal
		END Function

		VAR fullMask <- (1 << total_pawns) - 1
		RETURN recurse(x_1, y_1, fullMask, True)
	END Function
END CLASS
```