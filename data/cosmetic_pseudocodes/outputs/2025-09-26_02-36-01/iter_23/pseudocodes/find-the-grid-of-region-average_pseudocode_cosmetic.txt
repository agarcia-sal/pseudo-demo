```  
CLASS Solution  
    FUNCTION resultGrid(image WITH TYPE List OF List OF integer threshold WITH TYPE integer) WITH RETURN TYPE List OF List OF integer  
        
        SET alpha TO LENGTH OF image  
        SET beta TO LENGTH OF element at zero index of image  
        SET omega TO a LIST of alpha ELEMENTS EACH being a LIST of beta ELEMENTS EACH initialized TO zero  
        SET psi TO a LIST of alpha ELEMENTS EACH being a LIST of beta ELEMENTS EACH initialized TO zero  
        
        FUNCTION is_valid_region(x WITH TYPE integer y WITH TYPE integer) WITH RETURN TYPE boolean
            
            PROCEDURE check_positions(a WITH TYPE integer b WITH TYPE integer c WITH TYPE integer)
                IF c EQUALS 4 THEN
                    RETURN
                END IF
                SET offsets TO LIST OF ( -1, 0 ), ( 1, 0 ), ( 0, -1 ), ( 0, 1 )
                SET nx TO a PLUS offsets at c position first element  
                SET ny TO b PLUS offsets at c position second element
                IF ( nx GREATER THAN OR EQUAL TO 0 ) AND ( nx LESS THAN x PLUS 3 ) AND ( ny GREATER THAN OR EQUAL TO 0 ) AND ( ny LESS THAN y PLUS 3 ) THEN
                    IF ABSOLUTE VALUE OF ( image at a position b MINUS image at nx position ny ) GREATER THAN threshold THEN
                        THROW "INVALID"
                    END IF
                END IF
                check_positions(a b c PLUS 1)
            END PROCEDURE
            
            PROCEDURE check_rows(curr_i WITH TYPE integer end_i WITH TYPE integer curr_j WITH TYPE integer end_j WITH TYPE integer)  
                IF curr_i EQUALS end_i THEN  
                    RETURN  
                END IF  
                PROCEDURE inner_loop(curr_j_pos WITH TYPE integer limit_j WITH TYPE integer)
                    IF curr_j_pos EQUALS limit_j THEN
                        RETURN
                    END IF
                    TRY  
                        check_positions(curr_i curr_j_pos 0)  
                    CATCH "INVALID"  
                        THROW "INVALID"  
                    END TRY  
                    inner_loop(curr_j_pos PLUS 1 limit_j)
                END PROCEDURE
                inner_loop(curr_j end_j)
                check_rows(curr_i PLUS 1 end_i curr_j end_j)  
            END PROCEDURE

            TRY  
                check_rows(x x PLUS 3 y y PLUS 3)  
            CATCH "INVALID"  
                RETURN False  
            END TRY  
            RETURN True  
        END FUNCTION  
        
        FUNCTION calculate_average(x WITH TYPE integer y WITH TYPE integer) WITH RETURN TYPE integer
            SET sigma TO 0

            FUNCTION accumulate_row(i WITH TYPE integer j WITH TYPE integer limit_j WITH TYPE integer) WITH RETURN TYPE integer
                IF j EQUALS limit_j THEN
                    RETURN 0
                END IF
                RETURN image at i position j PLUS accumulate_row(i j PLUS 1 limit_j)
            END FUNCTION

            FUNCTION accumulate_col(i WITH TYPE integer limit_i WITH TYPE integer current_i WITH TYPE integer) WITH RETURN TYPE integer
                IF current_i EQUALS limit_i THEN
                    RETURN 0
                END IF
                RETURN accumulate_row(current_i y y PLUS 3) PLUS accumulate_col(i limit_i current_i PLUS 1)
            END FUNCTION

            SET sigma TO accumulate_col(x x PLUS 3 x)
            SET epsilon TO sigma DIVIDED BY 9
            RETURN epsilon
        END FUNCTION
        
        FUNCTION outer_loop(i WITH TYPE integer j WITH TYPE integer)  
            IF i EQUALS alpha MINUS 2 THEN  
                RETURN  
            END IF  
            FUNCTION inner_loop_func(j_func WITH TYPE integer)  
                IF j_func EQUALS beta MINUS 2 THEN  
                    RETURN  
                END IF  
                IF is_valid_region(i j_func) EQUALS True THEN  
                    SET delta TO calculate_average(i j_func)  

                    FUNCTION assign_values(x_idx WITH TYPE integer y_idx WITH TYPE integer)
                        IF x_idx EQUALS i PLUS 3 THEN
                            RETURN
                        END IF
                        FUNCTION assign_inner(y_inner WITH TYPE integer)
                            IF y_inner EQUALS y_idx PLUS 3 THEN
                                RETURN
                            END IF
                            omega at x_idx position y_inner TO omega at x_idx position y_inner PLUS delta
                            psi at x_idx position y_inner TO psi at x_idx position y_inner PLUS 1
                            assign_inner(y_inner PLUS 1)
                        END FUNCTION
                        assign_inner(y_idx)
                        assign_values(x_idx PLUS 1 y_idx)
                    END FUNCTION
                    assign_values(i j_func)
                END IF  
                inner_loop_func(j_func PLUS 1)  
            END FUNCTION  
            inner_loop_func(j)  
            outer_loop(i PLUS 1 j)  
        END FUNCTION  
        
        outer_loop(0 0)
        
        FUNCTION finalize_rows(i WITH TYPE integer)  
            IF i EQUALS alpha THEN  
                RETURN  
            END IF  
            FUNCTION finalize_cols(j WITH TYPE integer)  
                IF j EQUALS beta THEN  
                    RETURN  
                END IF  
                IF psi at i position j GREATER THAN 0 THEN  
                    omega at i position j TO omega at i position j DIVIDED BY psi at i position j  
                ELSE  
                    omega at i position j TO image at i position j  
                END IF  
                finalize_cols(j PLUS 1)  
            END FUNCTION  
            finalize_cols(0)  
            finalize_rows(i PLUS 1)  
        END FUNCTION  
        
        finalize_rows(0)
        
        RETURN omega  
    END FUNCTION  
END CLASS  
```