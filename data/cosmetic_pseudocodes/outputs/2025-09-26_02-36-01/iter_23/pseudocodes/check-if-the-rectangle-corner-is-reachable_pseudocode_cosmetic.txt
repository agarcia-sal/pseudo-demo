```pseudocode
CLASS Solution
    FUNCTION canReachCorner(xCorner yCorner circles)
        FUNCTION check_inside_circle(a b c d e)
            SET temp1 TO (a - c) * (a - c)
            SET temp2 TO (b - d) * (b - d)
            SET limit TO e * e
            RETURN (temp1 + temp2) <= limit
        END FUNCTION

        FUNCTION touches_left_or_top_edge(cx cy r)
            SET cond1_part1 TO abs(cx) <= r
            SET cond1_part2 TO (0 <= cy) AND (cy <= yCorner)
            SET cond1 TO cond1_part1 AND cond1_part2

            SET cond2_part1 TO abs(cy - yCorner) <= r
            SET cond2_part2 TO (0 <= cx) AND (cx <= xCorner)
            SET cond2 TO cond2_part1 AND cond2_part2

            RETURN cond1 OR cond2
        END FUNCTION

        FUNCTION touches_right_or_bottom_edge(cx cy r)
            SET cond3_part1 TO abs(cx - xCorner) <= r
            SET cond3_part2 TO (0 <= cy) AND (cy <= yCorner)
            SET cond3 TO cond3_part1 AND cond3_part2

            SET cond4_part1 TO abs(cy) <= r
            SET cond4_part2 TO (0 <= cx) AND (cx <= xCorner)
            SET cond4 TO cond4_part1 AND cond4_part2

            RETURN cond3 OR cond4
        END FUNCTION

        FUNCTION recursive_search(k)
            SET posX TO circles[k][0]
            SET posY TO circles[k][1]
            SET radius TO circles[k][2]

            IF touches_right_or_bottom_edge(posX posY radius)
                RETURN True
            END IF

            SET vis[k] TO True

            PROCEDURE iterate_over_circles(m)
                IF m >= LENGTH(circles)
                    RETURN False
                END IF

                SET curX TO circles[m][0]
                SET curY TO circles[m][1]
                SET curR TO circles[m][2]

                IF vis[m] == True
                    GOTO skip_iteration
                END IF

                SET dx TO posX - curX
                SET dy TO posY - curY
                SET dist_sq TO (dx * dx) + (dy * dy)
                SET rad_sum TO radius + curR
                SET rad_sum_sq TO rad_sum * rad_sum

                IF dist_sq > rad_sum_sq
                    GOTO skip_iteration
                END IF

                SET weighted_x_sum TO (posX * curR) + (curX * radius)
                SET weighted_x_limit TO rad_sum * xCorner

                SET weighted_y_sum TO (posY * curR) + (curY * radius)
                SET weighted_y_limit TO rad_sum * yCorner

                IF (weighted_x_sum < weighted_x_limit) AND (weighted_y_sum < weighted_y_limit)
                    IF recursive_search(m)
                        RETURN True
                    END IF
                END IF

                :skip_iteration
                RETURN iterate_over_circles(m + 1)
            END PROCEDURE

            RETURN iterate_over_circles(0)
        END FUNCTION

        SET vis TO CREATE_LIST(FALSE, LENGTH(circles))

        PROCEDURE check_circles(index)
            IF index >= LENGTH(circles)
                RETURN True
            END IF

            SET cx TO circles[index][0]
            SET cy TO circles[index][1]
            SET cr TO circles[index][2]

            IF check_inside_circle(0 0 cx cy cr) OR check_inside_circle(xCorner yCorner cx cy cr)
                RETURN False
            END IF

            IF (vis[index] == False) AND touches_left_or_top_edge(cx cy cr)
                IF recursive_search(index) == True
                    RETURN False
                END IF
            END IF

            RETURN check_circles(index + 1)
        END PROCEDURE

        RETURN check_circles(0)
    END FUNCTION
END CLASS
```