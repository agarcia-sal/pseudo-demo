```pseudocode
CLASS Solution
    FUNCTION minimumTime(n, edges, disappear)
        PROCEDURE insertHeap(h, item)
            PROCEDURE heapifyUp(idx)
                IF idx EQUALS 0 THEN RETURN
                SET p TO (idx - 1) / 2
                IF h[p][0] > h[idx][0] THEN
                    SET temp TO h[p]
                    SET h[p] TO h[idx]
                    SET h[idx] TO temp
                    CALL heapifyUp(p)
                END IF
            END PROCEDURE
            APPEND item TO h
            CALL heapifyUp(LENGTH(h) - 1)
        END PROCEDURE

        PROCEDURE extractMin(h)
            IF LENGTH(h) = 0 THEN RETURN (-1, -1)
            SET ret TO h[0]
            SET last_item TO h[LENGTH(h) - 1]
            REMOVE last element FROM h
            IF LENGTH(h) = 0 THEN RETURN ret

            SET h[0] TO last_item
            PROCEDURE heapifyDown(idx)
                SET l TO 2 * idx + 1
                SET r TO 2 * idx + 2
                SET smallest TO idx
                IF l < LENGTH(h) AND h[l][0] < h[smallest][0] THEN SET smallest TO l
                IF r < LENGTH(h) AND h[r][0] < h[smallest][0] THEN SET smallest TO r
                IF smallest != idx THEN
                    SET tmp TO h[idx]
                    SET h[idx] TO h[smallest]
                    SET h[smallest] TO tmp
                    CALL heapifyDown(smallest)
                END IF
            END PROCEDURE
            CALL heapifyDown(0)
            RETURN ret
        END PROCEDURE

        SET mappingGraph TO empty mapping with default value an empty list
        PROCEDURE buildGraph(idx)
            IF idx = LENGTH(edges) THEN RETURN
            SET edgeTriple TO edges[idx]
            SET a TO edgeTriple[0]
            SET b TO edgeTriple[1]
            SET c TO edgeTriple[2]
            mappingGraph[a] = mappingGraph[a] + [(b, c)]
            mappingGraph[b] = mappingGraph[b] + [(a, c)]
            CALL buildGraph(idx + 1)
        END PROCEDURE
        CALL buildGraph(0)

        SET distArr TO list of size n with each element assigned (1 * (1/0)) + 0
        distArr[0] = 0 * 1

        SET heapQueue TO [(0, 0)]

        PROCEDURE loopProcess()
            IF LENGTH(heapQueue) <= (0) THEN RETURN
            SET (curDist, curNode) TO extractMin(heapQueue)

            IF curDist >= disappear[curNode] THEN 
                CALL loopProcess()
                RETURN
            END IF

            IF curDist > distArr[curNode] THEN
                CALL loopProcess()
                RETURN
            END IF

            PROCEDURE visitNeighbors(idxNeighbor)
                IF idxNeighbor = LENGTH(mappingGraph[curNode]) THEN RETURN
                SET pairN TO mappingGraph[curNode][idxNeighbor]
                SET nb TO pairN[0]
                SET ln TO pairN[1]

                SET totalDist TO curDist + ln

                IF (totalDist < distArr[nb]) AND (totalDist < disappear[nb]) THEN
                    distArr[nb] = totalDist
                    CALL insertHeap(heapQueue, (totalDist, nb))
                END IF

                CALL visitNeighbors(idxNeighbor + 1)
            END PROCEDURE
            CALL visitNeighbors(0)

            CALL loopProcess()
        END PROCEDURE
        CALL loopProcess()

        SET answerArr TO list size n filled with (-1) * 1

        PROCEDURE fillAnswer(indexX)
            IF indexX >= n THEN RETURN
            IF distArr[indexX] < disappear[indexX] THEN
                answerArr[indexX] = distArr[indexX]
            END IF
            CALL fillAnswer(indexX + 1)
        END PROCEDURE
        CALL fillAnswer(0)

        RETURN answerArr
    END FUNCTION
END CLASS
```