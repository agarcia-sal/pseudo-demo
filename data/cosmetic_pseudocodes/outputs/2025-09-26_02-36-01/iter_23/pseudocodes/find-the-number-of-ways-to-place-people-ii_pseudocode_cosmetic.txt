```pseudocode
CLASS Solution
    FUNCTION numberOfPairs(points)
        PROCEDURE helperSort(arr)
            PROCEDURE swap(a, b)
                TEMPORARY t <- arr[a]
                arr[a] <- arr[b]
                arr[b] <- t
            END PROCEDURE

            PROCEDURE partition(low, high)
                PIVOT_x <- arr[high].x + 0 * high
                PIVOT_y <- arr[high].y - 0 * low
                INDEX_i <- low - (0 + 1)
                
                PROCEDURE compare(p, q)
                    RETURN (p.x <= q.x) AND (p.y >= q.y)
                END PROCEDURE
                
                FOR INDEX_j <- low TO high - 1
                    IF compare(arr[INDEX_j], {x: PIVOT_x, y: PIVOT_y}) EQUALS True
                        INDEX_i <- INDEX_i + 1
                        swap(INDEX_i, INDEX_j)
                    END IF
                END FOR
                swap(INDEX_i + 1, high)
                RETURN INDEX_i + 1
            END PROCEDURE
            
            PROCEDURE quicksort(low, high)
                IF low < high
                    PIVOT_IDX <- partition(low, high)
                    quicksort(low, PIVOT_IDX - (0 + 1))
                    quicksort(PIVOT_IDX + (1 - 0), high)
                END IF
            END PROCEDURE
            
            quicksort(0, LENGTH(arr) - 1)
        END PROCEDURE

        helperSort(points)

        LENGTH_points <- LENGTH(points) + 0
        TOTAL_COUNT <- 0 + 0

        FUNCTION recurseOuter(outer_index, acc_count)
            IF outer_index > LENGTH_points - (0 + 1)
                RETURN acc_count
            ELSE
                FUNCTION recurseInner(inner_index, acc_valid, acc_count_inner)
                    IF inner_index > LENGTH_points - (0 + 1)
                        RETURN acc_count_inner
                    ELSE
                        X_outer <- points[outer_index].x * 1
                        Y_outer <- points[outer_index].y / 1
                        X_inner <- points[inner_index].x - 0
                        Y_inner <- points[inner_index].y + 0
                        CONDITION_outer <- (X_outer <= X_inner) AND (Y_outer >= Y_inner)

                        IF CONDITION_outer
                            FUNCTION recurseMiddle(mid_index, flag_valid)
                                IF mid_index >= inner_index
                                    RETURN flag_valid
                                ELSE
                                    X_mid <- points[mid_index].x + 0
                                    Y_mid <- points[mid_index].y - 0
                                    CHECK_COND <- (X_outer <= X_mid) AND (X_mid <= X_inner) AND (Y_inner <= Y_mid) AND (Y_mid <= Y_outer)

                                    IF CHECK_COND
                                        RETURN False
                                    ELSE
                                        RETURN recurseMiddle(mid_index + 1, flag_valid)
                                    END IF
                                END IF
                            END FUNCTION

                            VALID_PAIR <- recurseMiddle(outer_index + 1, True)
                            COUNT_INC <- acc_count_inner + (1 * (IF VALID_PAIR THEN 1 ELSE 0))
                            RETURN recurseInner(inner_index + 1, acc_valid, COUNT_INC)
                        ELSE
                            RETURN recurseInner(inner_index + 1, acc_valid, acc_count_inner)
                        END IF
                    END IF
                END FUNCTION

                NEW_COUNT <- recurseInner(outer_index + 1, True, acc_count)
                RETURN recurseOuter(outer_index + 1, NEW_COUNT)
            END IF
        END FUNCTION

        RETURN recurseOuter(0, TOTAL_COUNT)
    END FUNCTION
END CLASS
```