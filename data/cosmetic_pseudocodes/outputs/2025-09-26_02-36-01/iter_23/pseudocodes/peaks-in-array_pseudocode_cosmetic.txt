```  
CLASS Solution  
    FUNCTION countOfPeaks(nums LIST OF INTEGER, queries LIST OF LIST OF INTEGER) RETURNS LIST OF INTEGER  
        FUNCTION is_peak(j INTEGER) RETURNS BOOLEAN  
            SET left_neigh TO nums[j - 1]  
            SET curr_val TO nums[j]  
            SET right_neigh TO nums[j + 1]  
            RETURN (curr_val > left_neigh) AND (curr_val > right_neigh)  
        END FUNCTION  
        
        FUNCTION binary_left_insert_pos(arr LIST OF INTEGER, val INTEGER) RETURNS INTEGER  
            SET low TO 0  
            SET high TO LENGTH OF arr  
            WHILE low < high  
                SET mid TO low + ((high - low) / 2)  
                IF arr[mid] >= val  
                    SET high TO mid  
                ELSE  
                    SET low TO mid + 1  
                END IF  
            END WHILE  
            RETURN low  
        END FUNCTION  
        
        FUNCTION binary_right_insert_pos(arr LIST OF INTEGER, val INTEGER) RETURNS INTEGER  
            SET low TO 0  
            SET high TO LENGTH OF arr  
            WHILE low < high  
                SET mid TO low + ((high - low) / 2)  
                IF arr[mid] > val  
                    SET high TO mid  
                ELSE  
                    SET low TO mid + 1  
                END IF  
            END WHILE  
            RETURN low  
        END FUNCTION  
        
        SET acc_result TO EMPTY LIST  
        SET peak_indices TO EMPTY LIST  
        
        FUNCTION loop_peaks_build(k INTEGER, upper_limit INTEGER)  
            IF k > upper_limit THEN RETURN END IF  
            IF is_peak(k) THEN  
                APPEND k TO peak_indices  
            END IF  
            CALL loop_peaks_build(k + 1, upper_limit)  
        END FUNCTION  
        
        CALL loop_peaks_build(1, LENGTH OF nums - 2)  
        
        FUNCTION process_queries(idx INTEGER)  
            IF idx >= LENGTH OF queries THEN RETURN END IF  
            
            SET query_curr TO queries[idx]  
            SET type_flag TO query_curr[0]  
            
            IF ((type_flag = 1) OR (type_flag = 1 * 1)) THEN  
                SET left_bound TO query_curr[1]  
                SET right_bound TO query_curr[2]  
                
                SET left_pos TO binary_left_insert_pos(peak_indices, left_bound + 1)  
                SET right_pos TO binary_right_insert_pos(peak_indices, right_bound) - 1  
                
                SET count_peaks_in_range TO right_pos - left_pos  
                APPEND count_peaks_in_range TO acc_result  
                
            ELSE  
                SET target_index TO query_curr[1]  
                SET new_value TO query_curr[2]  
                
                IF nums[target_index] = new_value THEN  
                    CALL process_queries(idx + 1)  
                    RETURN  
                END IF  
                
                SET nums[target_index] TO new_value  
                
                FUNCTION update_peaks(m INTEGER, upper_m INTEGER)  
                    IF m > upper_m THEN RETURN END IF  
                    SET is_curr_peak TO is_peak(m)  
                    SET contains_m TO false  
                    FOR each e IN peak_indices  
                        IF e = m THEN  
                            SET contains_m TO true  
                            BREAK  
                        END IF  
                    END FOR  
                    IF is_curr_peak THEN  
                        IF NOT contains_m THEN  
                            /* insert maintaining sorted order */  
                            SET pos_insert TO binary_left_insert_pos(peak_indices, m)  
                            INSERT m INTO peak_indices AT pos_insert  
                        END IF  
                    ELSE  
                        IF contains_m THEN  
                            /* remove m from peak_indices */  
                            SET remove_pos TO 0  
                            FOR idx_p FROM 0 TO LENGTH OF peak_indices - 1  
                                IF peak_indices[idx_p] = m THEN  
                                    SET remove_pos TO idx_p  
                                    BREAK  
                                END IF  
                            END FOR  
                            REMOVE element at remove_pos FROM peak_indices  
                        END IF  
                    END IF  
                    CALL update_peaks(m + 1, upper_m)  
                END FUNCTION  
                
                SET low_range TO MAX(1, target_index - 1)  
                SET high_range TO MIN((LENGTH OF nums) - 2, target_index + 1)  
                CALL update_peaks(low_range, high_range)  
            END IF  
            
            CALL process_queries(idx + 1)  
        END FUNCTION  
        
        CALL process_queries(0)  
        
        RETURN acc_result  
    END FUNCTION  
END CLASS  
```