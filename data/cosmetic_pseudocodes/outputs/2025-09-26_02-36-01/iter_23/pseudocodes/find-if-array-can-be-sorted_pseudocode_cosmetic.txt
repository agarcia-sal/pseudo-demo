```  
CLASS Solution  
    FUNCTION canSortArray(nums)  
        FUNCTION count_set_bits(x)  
            SET acc TO 0  
            FUNCTION helper(val, res)  
                IF val EQUALS 0  
                    RETURN res  
                ELSE  
                    RETURN helper((val FLOOR-DIVIDED-BY 2), (res PLUS (val MOD 2)))  
                END IF  
            END FUNCTION  
            RETURN helper(x, acc)  
        END FUNCTION  

        SET length_var TO LENGTH OF nums  
        SET ordered_list TO EMPTY LIST  
        FOR idx FROM 0 TO (length_var MINUS 1)  
            ADD nums[idx] TO ordered_list  
        END FOR  

        FUNCTION sort_copy(lst)  
            FUNCTION insert_sorted(array, elem)  
                IF LENGTH OF array EQUALS 0 THEN  
                    RETURN [elem]  
                ELSE  
                    IF elem LESS-THAN OR EQUAL-TO array[0] THEN  
                        RETURN [elem] CONCAT array  
                    ELSE  
                        RETURN [array[0]] CONCAT insert_sorted(SUBLIST array FROM 1 TO END, elem)  
                    END IF  
                END IF  
            END FUNCTION  

            FUNCTION sort_recursive(array)  
                IF LENGTH OF array LESS-THAN OR EQUAL-TO 1 THEN  
                    RETURN array  
                ELSE  
                    SET head TO array[0]  
                    SET tail TO SUBLIST array FROM 1 TO END  
                    SET sorted_tail TO sort_recursive(tail)  
                    RETURN insert_sorted(sorted_tail, head)  
                END IF  
            END FUNCTION  

            RETURN sort_recursive(lst)  
        END FUNCTION  

        SET target TO sort_copy(ordered_list)  

        FUNCTION bubble_pass(a_list, u, v, swap_flag)  
            IF v GREATER-THAN (length_var MINUS 2) THEN  
                RETURN swap_flag  
            ELSE  
                SET curr_bits TO count_set_bits(a_list[v])  
                SET next_bits TO count_set_bits(a_list[v PLUS 1])  

                IF (curr_bits EQUALS next_bits) AND (a_list[v] GREATER-THAN a_list[v PLUS 1]) THEN  
                    SET tmp_val TO a_list[v]  
                    SET a_list[v] TO a_list[v PLUS 1]  
                    SET a_list[v PLUS 1] TO tmp_val  
                    RETURN bubble_pass(a_list, u, v PLUS 1, TRUE)  
                ELSE  
                    RETURN bubble_pass(a_list, u, v PLUS 1, swap_flag)  
                END IF  
            END IF  
        END FUNCTION  

        FUNCTION bubble_outer(a_list, counter)  
            IF counter GREATER-THAN (length_var MINUS 1) THEN  
                RETURN  
            ELSE  
                SET changes TO bubble_pass(a_list, counter, 0, FALSE)  
                IF changes EQUALS FALSE THEN  
                    RETURN  
                ELSE  
                    bubble_outer(a_list, counter PLUS 1)  
                END IF  
            END IF  
        END FUNCTION  

        bubble_outer(nums, 0)  

        SET equality_flag TO TRUE  
        FUNCTION compare_lists(lst1, lst2, pos)  
            IF pos GREATER-THAN OR EQUAL-TO length_var THEN  
                RETURN  
            ELSE  
                IF lst1[pos] NOT EQUAL TO lst2[pos] THEN  
                    SET equality_flag TO FALSE  
                    RETURN  
                ELSE  
                    compare_lists(lst1, lst2, pos PLUS 1)  
                END IF  
            END IF  
        END FUNCTION  

        compare_lists(nums, target, 0)  
        RETURN equality_flag  
    END FUNCTION  
END CLASS  
```