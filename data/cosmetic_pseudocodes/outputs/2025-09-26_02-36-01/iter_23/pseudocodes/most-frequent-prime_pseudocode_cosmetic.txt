```pseudocode
FUNCTION is_prime(n)
    SET r0 TO false
    IF (n <= 1) THEN
        SET r0 TO false
    ELSE
        IF (n <= 3) THEN
            SET r0 TO true
        ELSE
            IF ((n % 2 = 0) OR (n % 3 = 0)) THEN
                SET r0 TO false
            ELSE
                FUNCTION check_divisor(d, val)
                    IF ((val * val) > n) THEN
                        RETURN true
                    ELSE
                        IF (((n % val) = 0) OR ((n % (val + 2)) = 0)) THEN
                            RETURN false
                        ELSE
                            RETURN check_divisor(d, val + 6)
                        END IF
                    END IF
                END FUNCTION
                SET r0 TO check_divisor(6, 5)
            END IF
        END IF
    END IF
    RETURN r0
END FUNCTION

CLASS Solution
    FUNCTION mostFrequentPrime(mat)
        SET L1 TO LENGTH(mat)
        SET L2 TO LENGTH(mat[0])
        SET delta_list TO [( -1, 0 ), ( -1, 1 ), ( 0, 1 ), ( 1, 1 ), ( 1, 0 ), ( 1, -1 ), ( 0, -1 ), ( -1, -1 )]
        SET counts_map TO new empty map from element to integer

        FUNCTION recurse_traverse(X, Y, DX, DY, current_val)
            SET NXT_X TO (X + DX)
            SET NXT_Y TO (Y + DY)
            IF ((NXT_X >= 0) AND (NXT_X < L1) AND (NXT_Y >= 0) AND (NXT_Y < L2)) THEN
                SET composed_num TO (current_val * 10) + mat[NXT_X][NXT_Y]
                IF ((composed_num > 10) AND (is_prime(composed_num) = true)) THEN
                    IF (counts_map HAS KEY composed_num) THEN
                        SET counts_map[composed_num] TO counts_map[composed_num] + 1
                    ELSE
                        SET counts_map[composed_num] TO 1
                    END IF
                END IF
                CALL recurse_traverse(NXT_X, NXT_Y, DX, DY, composed_num)
            END IF
        END FUNCTION

        FUNCTION loop_rows(row_idx)
            IF (row_idx >= L1) THEN RETURN END IF
            FUNCTION loop_cols(col_idx)
                IF (col_idx >= L2) THEN RETURN END IF
                FUNCTION process_dirs(dir_idx)
                    IF (dir_idx >= LENGTH(delta_list)) THEN RETURN END IF
                    SET dx_val TO delta_list[dir_idx][0]
                    SET dy_val TO delta_list[dir_idx][1]
                    CALL recurse_traverse(row_idx, col_idx, dx_val, dy_val, mat[row_idx][col_idx])
                    CALL process_dirs(dir_idx + 1)
                END FUNCTION
                CALL process_dirs(0)
                CALL loop_cols(col_idx + 1)
            END FUNCTION
            CALL loop_cols(0)
            CALL loop_rows(row_idx + 1)
        END FUNCTION

        CALL loop_rows(0)

        IF (counts_map IS EMPTY) THEN
            RETURN -1
        END IF

        SET max_freq_prime TO null
        SET max_freq TO 0

        FUNCTION find_max_key(keys, idx)
            IF (idx >= LENGTH(keys)) THEN RETURN max_freq_prime END IF
            SET k TO keys[idx]
            SET v TO counts_map[k]
            IF (v > max_freq) THEN
                SET max_freq TO v
                SET max_freq_prime TO k
            END IF
            RETURN find_max_key(keys, idx + 1)
        END FUNCTION

        SET all_keys TO LIST OF KEYS OF counts_map
        CALL find_max_key(all_keys, 0)

        RETURN max_freq_prime
    END FUNCTION
END CLASS
```