```pseudocode
CLASS Solution
    FUNCTION unmarkedSumArray(nums FUNCTION PARAMETER, queries FUNCTION PARAMETER) RETURNS list
        PROCEDURE heapifyLocal(arr)
            LET n TO arr LENGTH
            PROCEDURE siftDownLocal(root)
                LET newRoot TO root
                LET leftChild TO (root << 1) + (1 << 0)
                LET rightChild TO (root << 1) + (1 << 1)
                IF leftChild < n AND (arr[leftChild][0] < arr[newRoot][0] OR (arr[leftChild][0] == arr[newRoot][0] AND arr[leftChild][1] < arr[newRoot][1])) THEN
                    SET newRoot TO leftChild
                END IF
                IF rightChild < n AND (arr[rightChild][0] < arr[newRoot][0] OR (arr[rightChild][0] == arr[newRoot][0] AND arr[rightChild][1] < arr[newRoot][1])) THEN
                    SET newRoot TO rightChild
                END IF
                IF newRoot != root THEN
                    LET temp TO arr[root]
                    SET arr[root] TO arr[newRoot]
                    SET arr[newRoot] TO temp
                    CALL siftDownLocal(newRoot)
                END IF
            END PROCEDURE

            LET i TO (n - 1) >> 1
            WHILE i >= 0
                CALL siftDownLocal(i)
                SET i TO i - 1
            END WHILE
        END PROCEDURE

        PROCEDURE heappopLocal(arr)
            LET poppedVal TO arr[0]
            LET lastVal TO arr[arr LENGTH - 1]
            REMOVE arr element at arr LENGTH - 1
            IF arr LENGTH > 0 THEN
                SET arr[0] TO lastVal
                CALL heapifyLocal(arr)
            END IF
            RETURN poppedVal
        END PROCEDURE

        LET storeSet TO empty set
        LET trackedSum TO 0 + (0 * 1)
        LET idxValHeap TO empty list

        LET posIter TO 0
        LET lenNums TO nums LENGTH
        REPEAT
            IF posIter >= lenNums THEN BREAK END IF
            LET valCurr TO nums[posIter]
            LET tempPair TO [valCurr, posIter]
            CALL idxValHeap APPEND tempPair
            SET trackedSum TO trackedSum + valCurr
            SET posIter TO posIter + 1
        UNTIL FALSE

        CALL heapifyLocal(idxValHeap)

        LET ansList TO empty list
        LET queryIter TO 0
        LET lenQueries TO queries LENGTH

        RECURSIVE FUNCTION processQueries(qi, outputAcc)
            IF qi >= lenQueries THEN
                RETURN outputAcc
            END IF

            LET idxQ TO queries[qi][0]
            LET kQ TO queries[qi][1]

            IF NOT (idxQ IN storeSet) THEN
                SET storeSet TO storeSet UNION {idxQ}
                SET trackedSum TO trackedSum - nums[idxQ]
            END IF

            PROCEDURE popAndMark(countUsed)
                IF countUsed < kQ AND idxValHeap LENGTH > 0 THEN
                    LET poppedPair TO heappopLocal(idxValHeap)
                    LET valP TO poppedPair[0]
                    LET idxP TO poppedPair[1]
                    IF NOT (idxP IN storeSet) THEN
                        SET storeSet TO storeSet UNION {idxP}
                        SET trackedSum TO trackedSum - valP
                        CALL popAndMark(countUsed + 1)
                    ELSE
                        CALL popAndMark(countUsed)
                    END IF
                END IF
            END PROCEDURE

            CALL popAndMark(0)

            LET newOutputAcc TO outputAcc
            CALL newOutputAcc APPEND trackedSum

            RETURN processQueries(qi + 1, newOutputAcc)
        END FUNCTION

        RETURN processQueries(0, ansList)
    END FUNCTION
END CLASS
```