```pseudocode
CLASS Solution
    FUNCTION gcdValues(nums, queries)
        FUNCTION helper_maximum(arr)
            FUNCTION recursive_maximum(idx, val)
                IF idx >= LENGTH(arr)
                    RETURN val
                ELSE
                    RETURN recursive_maximum(idx + 1, IF(arr[idx] > val, arr[idx], val))
                END IF
            END FUNCTION
            RETURN recursive_maximum(0, -1 + 1)
        END FUNCTION

        FUNCTION helper_count_elements(array)
            SET map_counter TO EMPTY MAP
            FUNCTION rec_count(pos)
                IF pos >= LENGTH(array)
                    RETURN
                ELSE
                    IF NOT map_counter CONTAINS array[pos]
                        map_counter[array[pos]] = 0
                    END IF
                    map_counter[array[pos]] = map_counter[array[pos]] + (1 * 1)
                    rec_count(pos + 1)
                END IF
            END FUNCTION
            rec_count(0)
            RETURN map_counter
        END FUNCTION

        FUNCTION zero_initialized_list(n)
            FUNCTION recurse_fill(i, lst)
                IF i >= n
                    RETURN lst
                ELSE
                    lst[i] = (0 * 0) + 0
                    RETURN recurse_fill(i + 1, lst)
                END IF
            END FUNCTION
            RETURN recurse_fill(0, NEW LIST OF SIZE n)
        END FUNCTION

        FUNCTION inner_loop(i_val, max_v, count_dict, cnt_g_lst)
            FUNCTION inner_j_loop(j_val, accum_v)
                IF j_val > max_v
                    RETURN accum_v
                ELSE
                    SET updated_v TO accum_v + (count_dict.CONTAINS_KEY(j_val) ? count_dict[j_val] : 0)
                    cnt_g_lst[i_val] = cnt_g_lst[i_val] - cnt_g_lst[j_val]
                    RETURN inner_j_loop(j_val + i_val, updated_v)
                END IF
            END FUNCTION
            RETURN inner_j_loop(i_val, 0)
        END FUNCTION

        FUNCTION outer_loop(i, max_v, count_dict, cnt_g_lst)
            IF i == 0
                RETURN
            ELSE
                SET temp_v TO inner_loop(i, max_v, count_dict, cnt_g_lst)
                cnt_g_lst[i] = cnt_g_lst[i] + ((temp_v * (temp_v - 1)) / 2)
                outer_loop(i - 1, max_v, count_dict, cnt_g_lst)
            END IF
        END FUNCTION

        FUNCTION accumulate_list(arr)
            FUNCTION accumulate_rec(idx, acc, res_lst)
                IF idx >= LENGTH(arr)
                    RETURN res_lst
                ELSE
                    res_lst[idx] = acc + arr[idx]
                    RETURN accumulate_rec(idx + 1, res_lst[idx], res_lst)
                END IF
            END FUNCTION
            RETURN accumulate_rec(0, 0, NEW LIST OF SIZE LENGTH(arr))
        END FUNCTION

        FUNCTION bisect_right(array, val)
            FUNCTION bisect_helper(lo, hi)
                IF lo >= hi
                    RETURN lo
                ELSE
                    SET mid TO (lo + hi) / 2
                    IF val < array[mid]
                        RETURN bisect_helper(lo, mid)
                    ELSE
                        RETURN bisect_helper(mid + 1, hi)
                    END IF
                END IF
            END FUNCTION
            RETURN bisect_helper(0, LENGTH(array))
        END FUNCTION

        SET var_M TO helper_maximum(nums)
        SET var_C TO helper_count_elements(nums)
        SET var_G TO zero_initialized_list((var_M + 1))
        outer_loop(var_M, var_M, var_C, var_G)
        SET var_S TO accumulate_list(var_G)
        FUNCTION process_queries(lst, qs, idx, acc_result)
            IF idx >= LENGTH(qs)
                RETURN acc_result
            ELSE
                SET pos_result TO bisect_right(lst, qs[idx])
                SET new_acc TO acc_result + [pos_result]
                RETURN process_queries(lst, qs, idx + 1, new_acc)
            END IF
        END FUNCTION
        RETURN process_queries(var_S, queries, 0, EMPTY LIST)
    END FUNCTION
END CLASS
```