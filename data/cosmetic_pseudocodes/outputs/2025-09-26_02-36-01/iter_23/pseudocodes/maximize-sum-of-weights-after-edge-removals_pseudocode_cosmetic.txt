```  
CLASS UnionFind  
    FUNCTION __init__(self, size)  
        FUNCTION build_parent_list(idx, limit, acc)  
            IF idx GREATER THAN limit  
                RETURN acc  
            ELSE  
                RETURN build_parent_list(idx + (1), limit, acc + [idx])  
            END IF  
        END FUNCTION  
        
        SET temp_parent TO build_parent_list(0, size - 1, [])  
        SET result_rank TO []  
        FUNCTION generate_zeros(count, acc2)  
            IF count EQUALS 0  
                RETURN acc2  
            ELSE  
                RETURN generate_zeros(count - 1, acc2 + [0])  
            END IF  
        END FUNCTION  
        SET temp_rank TO generate_zeros(size, [])  
        
        SET self.parent TO temp_parent  
        SET self.rank TO temp_rank  
    END FUNCTION  
  
    FUNCTION find(self, u)  
        FUNCTION find_recursive(x)  
            IF self.parent[x] NOT_EQUALS x  
                SET self.parent[x] TO find_recursive(self.parent[x])  
            END IF  
            RETURN self.parent[x]  
        END FUNCTION  
        RETURN find_recursive(u)  
    END FUNCTION  
  
    FUNCTION union(self, u, v)  
        SET a TO self.find(u)  
        SET b TO self.find(v)  
        
        IF a NOT_EQUALS b  
            IF self.rank[a] GREATER THAN self.rank[b]  
                SET self.parent[b] TO a  
            ELSE  
                IF (self.rank[a] LESS_THAN self.rank[b])  
                    SET self.parent[a] TO b  
                ELSE  
                    SET self.parent[b] TO a  
                    SET self.rank[a] TO self.rank[a] + (1)  
                END IF  
            END IF  
        END IF  
    END FUNCTION  
END CLASS  
  
CLASS Solution  
    FUNCTION maximizeSumOfWeights(self, edges, k)  
        SET length_n TO (len(edges) + (1))  
        
        FUNCTION zeros_list_generator(x, result_collection)  
            IF x EQUALS 0  
                RETURN result_collection  
            ELSE  
                RETURN zeros_list_generator(x - (1), result_collection + [0])  
            END IF  
        END FUNCTION  
        
        SET degrees_array TO zeros_list_generator(length_n, [])  
        
        SET uf_instance TO UnionFind(length_n)  
        
        FUNCTION descending_weight_key(edge_item)  
            RETURN (-1) * (edge_item[2])  
        END FUNCTION  
        SET temp_edges TO edges  
        SET sorted_edges TO []  
        FUNCTION insert_sort_desc(lst, acc_sorted)  
            IF lst EQUALS []  
                RETURN acc_sorted  
            ELSE  
                SET current_edge TO lst[0]  
                SET rest_edges TO lst[1:]  
                FUNCTION insert_into_sorted(x, xs)  
                    IF xs EQUALS []  
                        RETURN [x]  
                    ELSE  
                        IF x[2] GREATER_OR_EQUAL xs[0][2]  
                            RETURN [x] + xs  
                        ELSE  
                            RETURN [xs[0]] + insert_into_sorted(x, xs[1:])  
                        END IF  
                    END IF  
                END FUNCTION  
                SET new_sorted TO insert_into_sorted(current_edge, acc_sorted)  
                RETURN insert_sort_desc(rest_edges, new_sorted)  
            END IF  
        END FUNCTION  
        SET sorted_edges TO insert_sort_desc(temp_edges, [])  
        
        SET final_sum TO 0  
        
        FUNCTION process_edges_rec(edges_list, current_sum, deg_arr)  
            IF edges_list EQUALS []  
                RETURN current_sum  
            ELSE  
                SET edge_cur TO edges_list[0]  
                SET rest_list TO edges_list[1:]  
                SET x_val TO edge_cur[0]  
                SET y_val TO edge_cur[1]  
                SET weight_val TO edge_cur[2]  
                
                IF (deg_arr[x_val] < k) AND (deg_arr[y_val] < k) AND (uf_instance.find(x_val) NOT_EQUALS uf_instance.find(y_val))  
                    uf_instance.union(x_val, y_val)  
                    SET new_degs TO []  
                    FUNCTION increment_degree(arr, idx, result_arr, max_idx)  
                        IF idx GREATER_THAN max_idx  
                            RETURN result_arr  
                        ELSE  
                            IF idx EQUALS x_val OR idx EQUALS y_val  
                                SET result_arr TO result_arr + [arr[idx] + 1]  
                            ELSE  
                                SET result_arr TO result_arr + [arr[idx]]  
                            END IF  
                            RETURN increment_degree(arr, idx + 1, result_arr, max_idx)  
                        END IF  
                    END FUNCTION  
                    SET new_degs TO increment_degree(deg_arr, 0, [], length_n - 1)  
                    
                    RETURN process_edges_rec(rest_list, current_sum + weight_val, new_degs)  
                ELSE  
                    RETURN process_edges_rec(rest_list, current_sum, deg_arr)  
                END IF  
            END IF  
        END FUNCTION  
        
        SET max_result TO process_edges_rec(sorted_edges, final_sum, degrees_array)  
        
        RETURN max_result  
    END FUNCTION  
END CLASS  
```