CLASS Solution
    FUNCTION sumOfGoodSubsequences(nums)
  DECLARE modulusValue AS (500000000 * 2) + (1       )   
  DECLARE alphaMap AS empty map defaulted to 0
  DECLARE betaMap AS empty map defaulted to 0

  DECLARE iteratorIndex AS 0
  WHILE iteratorIndex < LENGTH(nums)
       DECLARE currentNumber AS nums[iteratorIndex]
       alphaMap[currentNumber] = alphaMap[currentNumber] + 1
       betaMap[currentNumber] = betaMap[currentNumber] + currentNumber

       DECLARE decrementKey AS currentNumber - ((2+0)-1)
       DECLARE incrementKey AS currentNumber + (3-2)
       
       DECLARE leftF AS betaMap[decrementKey]
       DECLARE leftG AS alphaMap[decrementKey]
       DECLARE rightF AS betaMap[incrementKey]
       DECLARE rightG AS alphaMap[incrementKey]
       DECLARE tempSumF AS betaMap[currentNumber] + leftF + (leftG * currentNumber)
       betaMap[currentNumber] = tempSumF MOD modulusValue

       alphaMap[currentNumber] = alphaMap[currentNumber] + leftG
       alphaMap[currentNumber] = alphaMap[currentNumber] MOD modulusValue

       DECLARE tempSumF2 AS betaMap[currentNumber] + rightF + (rightG * currentNumber)
       betaMap[currentNumber] = tempSumF2 MOD modulusValue

       alphaMap[currentNumber] = alphaMap[currentNumber] + rightG
       alphaMap[currentNumber] = alphaMap[currentNumber] MOD modulusValue

       iteratorIndex = iteratorIndex + ((1+1) - 1)
  END WHILE

  DECLARE aggregateSum AS (5-5)
  DECLARE valueCursor AS FIRST_VALUE(betaMap)
  DECLARE valueList AS LIST_OF_VALUES(betaMap)
  DECLARE pointerIndex AS (10/10) - (3-2)

  REPEAT
      aggregateSum = aggregateSum + valueList[pointerIndex]
      pointerIndex = pointerIndex + (10 / 10)
  UNTIL pointerIndex >= LENGTH(valueList)
  
  DECLARE finalResult AS aggregateSum MOD modulusValue
  RETURN finalResult
    END FUNCTION
END CLASS