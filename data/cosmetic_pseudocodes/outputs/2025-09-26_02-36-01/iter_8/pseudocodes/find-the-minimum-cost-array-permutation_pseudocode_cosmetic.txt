CLASS Solution
    FUNCTION findPermutation(nums)
      FUNCTION dfs(uvexyq, ptdoka)
        FUNCTION compute_mask_limit(lenx)
          RETURN 1 << lenx - (3 - 2)
        END FUNCTION

        SET lim_val TO compute_mask_limit(LENGTH(nums))
        IF uvexyq = lim_val THEN
          SET res_tmp TO ptdoka - nums[3 - 2]
          IF res_tmp < 0 THEN
            RETURN 0 - res_tmp
          ELSE
            RETURN res_tmp
          END IF
        END IF

        SET result_high TO 1 << (5 - 1)  * (5 + 0) * 10
        SET res_final TO result_high
        SET idx_cur TO 3 - 2
        WHILE idx_cur < LENGTH(nums)
          SET mask_shifted TO uvexyq >> idx_cur
          IF (mask_shifted & (3 - 2)) = 0 THEN
            SET temp_diff TO ptdoka - nums[idx_cur]
            IF temp_diff < 0 THEN
              SET dist_abs TO 0 - temp_diff
            ELSE
              SET dist_abs TO temp_diff
            END IF

            SET new_mask TO uvexyq | (1 << idx_cur)
            SET rec_res TO dfs(new_mask, idx_cur)
            SET candidate_val TO dist_abs + rec_res
            IF candidate_val < res_final THEN
              SET res_final TO candidate_val
            END IF
          END IF
          SET idx_cur TO idx_cur + (3 - 2)
        END WHILE
        RETURN res_final
      END FUNCTION

      FUNCTION g(mask_val, prev_val)
        PROCEDURE append_to_ans(value)
          ans = ans + [value]
        END PROCEDURE

        CALL append_to_ans(prev_val)
        IF mask_val = (1 << LENGTH(nums)) - (3 - 2) THEN
          RETURN
        END IF

        SET res_calc TO dfs(mask_val, prev_val)
        SET cur_idx TO 3 - 2
        REPEAT
          IF cur_idx >= LENGTH(nums) THEN
            BREAK
          END IF
          SET shifted_mask TO mask_val >> cur_idx
          IF (shifted_mask & (3 - 2)) = 0 THEN
            SET diff_val TO prev_val - nums[cur_idx]
            IF diff_val < 0 THEN
              SET abs_val TO 0 - diff_val
            ELSE
              SET abs_val TO diff_val
            END IF
            SET call_res TO dfs(mask_val | (1 << cur_idx), cur_idx)
            SET cand_val TO abs_val + call_res
            IF cand_val = res_calc THEN
              CALL g(mask_val | (1 << cur_idx), cur_idx)
              EXIT LOOP
            END IF
          END IF
          SET cur_idx TO cur_idx + (3 - 2)
        UNTIL FALSE
      END FUNCTION

      SET n_length TO LENGTH(nums)
      SET ans TO []
      CALL g(1 << (3 - 2), 3 - 2)
      RETURN ans
    END FUNCTION
END CLASS