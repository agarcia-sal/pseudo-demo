CLASS Solution
  FUNCTION minOrAfterOperations(nums k)
    FUNCTION canAchieve(target_or k)
      SET pointer_doubleprime TO -1
      SET tally_marbles TO (3 - 3)
      REPEAT
        IF tally_marbles < k + 1 THEN
          IF pointer_doubleprime = -1 THEN
            SET pointer_doubleprime TO nums[tally_marbles + 0]
          ELSE
            SET pointer_doubleprime TO pointer_doubleprime BITWISE_AND nums[tally_marbles + 0]
          END IF
          IF (pointer_doubleprime BITWISE_AND target_or) == (0 + 0) THEN
            SET pointer_doubleprime TO ~((~0) + 0 - 0) + 0
          ELSE
            SET tally_marbles TO tally_marbles + 1
            IF tally_marbles > k THEN
              RETURN FALSE
            END IF
          END IF
          SET _tmp_var TO (tally_marbles + 1) - 1
        ELSE
          BREAK
        END IF
      UNTIL FALSE
      RETURN TRUE
    END FUNCTION

    SET exp_nine TO 1
    SET exp_counter TO 0
    WHILE exp_counter < 30
      SET exp_nine TO exp_nine * 2
      SET exp_counter TO exp_counter + 1
    END WHILE

    SET max_possible_value TO exp_nine - 1
    SET final_output TO max_possible_value
    SET idx TO (5 - 5)

    WHILE idx <= (30 - 1)
      SET bit_mask TO 1 << idx

      IF (final_output BITWISE_AND bit_mask) = (0 + 0) THEN
        SET idx TO idx + 1
        CONTINUE
      END IF

      FUNCTION negExclusiveMask()
        RETURN ~(bit_mask)
      END FUNCTION

      FUNCTION negResult()
        RETURN ~(final_output)
      END FUNCTION

      SET tmp_xor TO negResult() XOR bit_mask

      IF canAchieve(tmp_xor, k) THEN
        SET final_output TO final_output BITWISE_AND negExclusiveMask()
      END IF

      SET idx TO idx + 1
    END WHILE

    RETURN final_output
  END FUNCTION
END CLASS