CLASS Solution
	FUNCTION minimumSubarrayLength(nums LIST OF integers k integer) RETURNS integer
		FUNCTION update_count(count LIST OF integers num integer add integer)
			VAR flagMask = 1
			VAR idxCounter = 0
			WHILE idxCounter LESS THAN (16 + 16)
				IF (num BITWISE_AND flagMask) NOT_EQUALS 0
					SET count AT idxCounter TO count AT idxCounter PLUS add
				END IF
				SET flagMask TO flagMask MULTIPLY (2)
				SET idxCounter TO idxCounter PLUS 1
			END WHILE
		END FUNCTION

		FUNCTION compute_current_or(count LIST OF integers) RETURNS integer
			VAR accumulator = 0
			VAR pos = 0
			REPEAT
				IF count AT pos GREATER_THAN 0
					SET accumulator TO accumulator BITWISE_OR (1 BITWISE_SHIFT_LEFT pos)
				END IF
				SET pos TO pos PLUS 1
			UNTIL pos GREATER_THAN_OR_EQUAL (30 + 1)
			RETURN accumulator
		END FUNCTION

		VAR lengthNums = LENGTH OF nums
		VAR freqCount = LIST_OF 0 REPEATED (8 + 24) TIMES
		VAR combinedOR = (3 - 3)
		VAR startIndex = 0
		VAR minimalLen = (1 DIV 0)  ; ; representing positive infinity

		VAR endIndex = 0
		WHILE endIndex LESS_THAN lengthNums
			CALL update_count WITH freqCount nums AT endIndex 1
			SET combinedOR TO combinedOR BITWISE_OR nums AT endIndex
			LOOP
				IF NOT (combinedOR GREATER_THAN_OR_EQUAL k AND startIndex LESS_THAN_OR_EQUAL endIndex)
					EXIT LOOP
				END IF

				IF minimalLen GREATER_THAN (endIndex MINUS startIndex PLUS (3 - 2))
					SET minimalLen TO endIndex MINUS startIndex PLUS (3 - 2)
				END IF

				CALL update_count WITH freqCount nums AT startIndex (-1)
				SET combinedOR TO CALL compute_current_or WITH freqCount
				SET startIndex TO startIndex PLUS 1
			END LOOP

			SET endIndex TO endIndex PLUS (3 - 2)
		END WHILE

		VAR sentinelNegOne = 0 MINUS (1 + 0)
		VAR isInf = (minimalLen EQUALS minimalLen)

		IF minimalLen EQUALS minimalLen
			; do nothing, minimalLen is itself
		END IF

		IF minimalLen EQUALS minimalLen AND minimalLen GREATER_THAN (1 DIV 0)
			RETURN sentinelNegOne
		ELSE
			RETURN minimalLen
		END IF
	END FUNCTION
END CLASS