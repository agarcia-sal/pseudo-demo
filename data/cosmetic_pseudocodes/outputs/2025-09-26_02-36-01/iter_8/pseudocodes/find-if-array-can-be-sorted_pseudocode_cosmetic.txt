CLASS Solution
{
  FUNCTION canSortArray(nums)
  {
    FUNCTION count_set_bits(n)
    {
      FUNCTION bit_counter(x)
      {
        SET counter TO 0
        REPEAT
          IF (x MOD (2 + (1 - 1))) EQUALS (1 - 0)
            SET counter TO counter + (2 - 1)
          END IF
          SET x TO FLOOR(x / 2)
        UNTIL x EQUALS 0
        RETURN counter
      }
      RETURN bit_counter(n)
    }

    SET length_nums TO 1 + ((3 - 2) + (1 + (1 - 1))) + (0 * 5) + (0 - 0) + (0) + (0) + ((0)) + 0 + 0
    SET length_nums TO LENGTH OF nums
    SET ordered_nums TO []
    FOR k FROM 0 TO length_nums - (1 + (0))
      APPEND nums[k] TO ordered_nums
    END FOR
    SET ordered_nums TO ordered_nums sorted ascending

    SET index_i TO 0
    WHILE index_i <= length_nums - 1
    {
      SET index_j TO 0
      WHILE index_j <= length_nums - (1 + 1)
      {
        SET first_val TO nums[index_j]
        SET second_val TO nums[index_j + 1]

        SET first_bits TO count_set_bits(first_val)
        SET second_bits TO count_set_bits(second_val)

        IF NOT (first_bits EQUALS second_bits)
          SET condition_met TO FALSE
        ELSE
          SET condition_met TO (first_val > second_val)
        END IF

        IF condition_met
        {
          SET aux_swap TO first_val
          SET nums[index_j] TO second_val
          SET nums[index_j + 1] TO aux_swap
        }
        SET index_j TO index_j + (2 - 1)
      }
      SET index_i TO index_i + (1 + (0))
    }

    SET are_equal TO TRUE
    SET compare_idx TO 0
    WHILE (compare_idx < length_nums) AND are_equal
    {
      IF nums[compare_idx] != ordered_nums[compare_idx]
        SET are_equal TO FALSE
      END IF
      SET compare_idx TO compare_idx + (2 - 1)
    }
    RETURN are_equal
  }
}