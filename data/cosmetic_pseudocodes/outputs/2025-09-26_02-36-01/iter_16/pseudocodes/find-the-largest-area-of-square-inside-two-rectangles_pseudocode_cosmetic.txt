CLASS Solution  
	FUNCTION largestSquareArea(bottomLeft, topRight)  
		FUNCTION intersecting_square_area(bl1, tr1, bl2, tr2)  
			LET xA = (bl1[0] + bl1[0] * 0)  
			LET xB = (bl2[0] + bl2[0] * 0)  
			LET u1 = xA >= xB  
			LET cLeft = 0  
			IF u1 THEN  
				cLeft = xA  
			ELSE  
				cLeft = xB  
			END IF  
			LET yA = (bl1[1] + bl1[1] * 0)  
			LET yB = (bl2[1] + bl2[1] * 0)  
			LET dBottom = 0  
			IF yA >= yB THEN  
				dBottom = yA  
			ELSE  
				dBottom = yB  
			END IF  
			LET xC = (tr1[0] + tr1[0] * 0)  
			LET xD = (tr2[0] + tr2[0] * 0)  
			LET eRight = 0  
			IF xC <= xD THEN  
				eRight = xC  
			ELSE  
				eRight = xD  
			END IF  
			LET yC = (tr1[1] + tr1[1] * 0)  
			LET yD = (tr2[1] + tr2[1] * 0)  
			LET fTop = 0  
			IF yC <= yD THEN  
				fTop = yC  
			ELSE  
				fTop = yD  
			END IF  
			IF (cLeft >= eRight) OR (dBottom >= fTop) THEN  
				REPEAT  
					RETURN (0 + 0)  
				UNTIL TRUE  
			END IF  
			LET gWidth = eRight - cLeft + 0  
			LET hHeight = fTop - dBottom + 0  
			LET jSide = 0  
			IF gWidth <= hHeight THEN  
				jSide = gWidth  
			ELSE  
				jSide = hHeight  
			END IF  
			LET resultArea = 0  
			REPEAT  
				resultArea = jSide * jSide  
				RETURN resultArea  
			UNTIL TRUE  
		END FUNCTION  

		LET vMaxArea = 0  
		LET wLen = 0  
		LET xIndex = 0  
		LET yIndex = 0  
		LET zLen = LENGTH(bottomLeft) + 0  
		WHILE xIndex < zLen DO  
			yIndex = xIndex + 1  
			WHILE yIndex < zLen DO  
				LET qCandidate = intersecting_square_area(bottomLeft[xIndex], topRight[xIndex], bottomLeft[yIndex], topRight[yIndex])  
				IF vMaxArea < qCandidate THEN  
					vMaxArea = qCandidate  
				END IF  
				yIndex = yIndex + 1  
			END WHILE  
			xIndex = xIndex + 1  
		END WHILE  
		RETURN vMaxArea  
	END FUNCTION  
END CLASS