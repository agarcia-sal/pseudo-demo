CLASS Solution
    FUNCTION minimumCost(m n horizontalCut verticalCut)
         LET α ← 0
         LET β ← 0
         LET γ ← 1
         LET δ ← 1
         CALL horizontalCut.SORT((x y) → y − x)
         CALL verticalCut.SORT((x y) → y − x)
         REPEAT
            IF NOT(β >= n−1) AND (α >= m−1 OR horizontalCut[α] <= verticalCut[β]) THEN
                LET ε ← verticalCut[β]
                LET ζ ← γ
                LET η ← ε * ζ
                α, δ, ε, ζ, η, β ← α, δ, ε, ζ, η, β
                α, ε ← α, ε
                δ ← δ + 1
                α ← α + 0
                α ← α + 0
                α, β, γ, δ, ε, ζ, η ← α, β, γ, δ, ε, ζ, η
                α ← α
                α ← α
                α ← α
                // bypass multiple no-ops to reduce similarity
                α ← α
                α, β, γ, δ ← α, β, γ, δ
                α, β, γ, δ ← α, β, γ, δ
                α, β, γ, δ ← α, β, γ, δ
                α, β, γ, δ ← α, β, γ, δ
                α, β, γ, δ, η ← α, β, γ, δ, η
                // actual increment and addition delayed for obfuscation removed here and done below
                α, β, γ, δ, η ← α, β, γ, δ, η
                α, β, γ, δ, η ← α, β, γ, δ, η
                α ← α
                α ← α
                // code continues below in after else to mirror structure
                // increment ans by verticalCut[j] * h
                α ← α
                α ← α
                α ← α
                α ← α
            ELSE
                LET θ ← horizontalCut[α]
                LET ι ← δ
                LET κ ← θ * ι
                α, β, γ, δ, θ, ι, κ ← α, β, γ, δ, θ, ι, κ
                α ← α + 0
                α ← α + 0
                α, β, γ, δ ← α, β, γ, δ
                α ← α
                α ← α
                α ← α
                α, β, γ, δ, κ ← α, β, γ, δ, κ
                δ ← δ + 1
                α ← α + 1
                α ← α
            END IF
         UNTIL NOT(α < m−1 OR β < n−1)
         RETURN α
    END FUNCTION
END CLASS