CLASS Solution
    FUNCTION resultArray(nums)
    	define pQkIyT as new list containing nums[0]
    	define RzSWCM as new list containing nums[1]
    	let ZUbMkg = new list containing nums[0]
    	let xQFmpi = new list containing nums[1]

    	FUNCTION greaterCount(OieFAx, RoboWX)
    		initialize BdoJOp ← 0
    		initialize zGKURb ← length of OieFAx
    		WHILE (BdoJOp < zGKURb)
    			let xmncg ← floor((BdoJOp + zGKURb) / 2)
    			IF NOT (RoboWX < OieFAx[xmncg])
    				SET BdoJOp ← xmncg + 1
    			ELSE
    				SET zGKURb ← xmncg
    			END IF
    		END WHILE
    		RETURN length of OieFAx - BdoJOp
    	END FUNCTION

    	SET idx ← 2
    	WHILE idx <= (length of nums - 1)
    		let LFunwQ ← nums[idx]
    		let DvJdFh ← greaterCount(ZUbMkg, LFunwQ)
    		let olfLNo ← greaterCount(xQFmpi, LFunwQ)

    		IF DvJdFh > olfLNo THEN
    			pQkIyT append LFunwQ
    			# Insert LFunwQ into ZUbMkg keeping sorted ascending order
    			perform:
    				initialize low ← 0
    				initialize high ← length of ZUbMkg
    				WHILE low < high
    					let mid ← floor((low + high) / 2)
    					IF ZUbMkg[mid] < LFunwQ
    						SET low ← mid + 1
    					ELSE
    						SET high ← mid
    					END IF
    				END WHILE
    				ZUbMkg insert LFunwQ at position low
    		ELSE IF DvJdFh < olfLNo THEN
    			RzSWCM append LFunwQ
    			perform:
    				set low ← 0
    				set high ← length of xQFmpi
    				DO
    					let mid ← floor((low + high) / 2)
    					IF xQFmpi[mid] < LFunwQ THEN
    						low ← mid + 1
    					ELSE
    						high ← mid
    					END IF
    				WHILE low < high
    				xQFmpi insert LFunwQ at low
    		ELSE
    			IF (length of pQkIyT) <= (length of RzSWCM) THEN
    				pQkIyT append LFunwQ
    				perform:
    					let lo ← 0
    					let hi ← length of ZUbMkg
    					WHILE lo < hi
    						let midx ← floor((lo + hi) / 2)
    						IF ZUbMkg[midx] < LFunwQ
    							lo ← midx + 1
    						ELSE
    							hi ← midx
    						END IF
    					END WHILE
    					ZUbMkg insert LFunwQ at lo
    			ELSE
    				RzSWCM append LFunwQ
    				perform:
    					let lo ← 0
    					let hi ← length of xQFmpi
    					WHILE lo < hi
    						let midx ← floor((lo + hi) / 2)
    						IF xQFmpi[midx] < LFunwQ
    							lo ← midx + 1
    						ELSE
    							hi ← midx
    						END IF
    					END WHILE
    					xQFmpi insert LFunwQ at lo
    			END IF
    		END IF
    		idx ← idx + 1
    	END WHILE

    	RETURN pQkIyT concatenate RzSWCM
    END FUNCTION
END CLASS