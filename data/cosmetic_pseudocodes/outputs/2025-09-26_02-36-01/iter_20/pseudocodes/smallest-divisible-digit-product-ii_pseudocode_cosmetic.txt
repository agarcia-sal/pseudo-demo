CLASS Solution
	 FUNCTION smallestNumber(number, flag)
		  FUNCTION wrapperAlpha(gamma)
			   SET delta TO new Counter()
			   SET beta TO 0
			   
			   PROCEDURE loopEpsilon(theta)
					WHILE theta MODULO gamma[beta] EQUALS 0 DO
							SET theta TO theta DIV gamma[beta]
							SET delta[gamma[beta]] TO delta[gamma[beta]] + 1
					END WHILE
					SET beta TO beta + 1
			   END PROCEDURE
			   
			   WHILE beta < 4 DO
					loopEpsilon(flag)
			   END WHILE
			   
			   RETURN delta, flag EQUALS 1
		  END FUNCTION

		  FUNCTION helperBeta(epsilon)
			  SET xi TO epsilon[2] DIV 3
			  SET rho TO epsilon[2] MOD 3
			  SET phi TO epsilon[3] DIV 2
			  SET chi TO epsilon[3] MOD 2
			  SET psi TO rho DIV 2
			  SET omega TO rho MOD 2
			  SET tau TO 0
			  
			  IF omega EQUALS 1 AND chi EQUALS 1 THEN
				   SET omega TO 0
				   SET chi TO 0
				   SET tau TO 1
			  ELSE
				   SET tau TO 0
			  END IF
			  
			  IF chi EQUALS 1 AND psi EQUALS 1 THEN
				   SET omega TO 1
				   SET tau TO 1
				   SET chi TO 0
				   SET psi TO 0
			  END IF
			  
			  RETURN Counter WITH MAPPINGS
				   '2' TO omega
				   '3' TO chi
				   '4' TO psi
				   '5' TO epsilon[5]
				   '6' TO tau
				   '7' TO epsilon[7]
				   '8' TO xi
				   '9' TO phi
		  END FUNCTION
		  
		  SET lambda, mu TO wrapperAlpha(flag)
		  IF NOT mu THEN
			   RETURN "-1"
		  END IF
		  SET nu TO helperBeta(lambda)
		  
		  SET sigma TO 0
		  SET kappa TO new Counter()
		  SET iota TO LENGTH(number) 
		  
		  FOR EACH char IN number DO
			   kappa UPDATE WITH helperBeta(Counter([INT(char)]))
			   
		  END FOR
		  
		  FOR EACH key, value IN kappa DO
			   SET sigma TO sigma + value
		  END FOR
		  
		  IF sigma > iota THEN
			   SET resultString TO ""
			   FOR EACH key, value IN nu DO
					FOR _ FROM 1 TO value DO
							SET resultString TO resultString + key
					END FOR
			   END FOR
			   RETURN resultString
		  END IF

		  SET zeta TO 0
		  SET pos TO 0
		  REPEAT
			   IF pos >= iota THEN BREAK
			   IF number[pos] = '0' THEN
					SET zeta TO pos
					SET pos TO iota
			   ELSE
					SET pos TO pos + 1
			   END IF
		  UNTIL FALSE

		  IF zeta EQUALS iota AND lambda <= kappa THEN
			   RETURN number
		  END IF
		  
		  SET sumHolder TO 0
		  
		  FUNCTION minusCounters(mainCounter, subCounter)
			   SET newCounter TO new Counter()
			   FOR EACH key in mainCounter KEYS DO
					SET newCounter[key] TO mainCounter.get(key, 0) - subCounter.get(key, 0)
			   END FOR
			   RETURN newCounter
		  END FUNCTION
		  
		  SET cumulativeCounter TO new Counter()
		  FOR j FROM iota - 1 DOWNTO 0 DO
			   SET digitChar TO number[j]
			   SET digitNum TO INT(digitChar)
			   SET deltaCounter TO helperBeta(Counter([digitNum]))
			   FOR EACH pKey IN deltaCounter KEYS DO
				    SET cumulativeCounter[pKey] TO cumulativeCounter.get(pKey, 0) + deltaCounter[pKey]
			   END FOR
		  END FOR
		  
		  SET recursionIndex TO iota - 1
		  FUNCTION runLoop()
				IF recursionIndex < 0 THEN RETURN NULL END IF
				SET charAtIndex TO number[recursionIndex]
				SET digitValue TO INT(charAtIndex)
				SET subtractCounter TO helperBeta(Counter([digitValue]))
				FOR EACH k IN subtractCounter KEYS DO
					 SET cumulativeCounter[k] = cumulativeCounter.get(k, 0) - subtractCounter[k]
				END FOR
				SET spaceRem TO LENGTH(number) - 1 - recursionIndex
				IF recursionIndex <= zeta THEN
					FOR numX FROM digitValue + 1 TO 9 DO
						 SET trialCounter TO helperBeta(minusCounters(lambda, cumulativeCounter))
						 IF numX_str NOT IN trialCounter THEN SET trialCounter[numX_str] TO 0 END IF
						 SET trialCounter TO helperBeta(minusCounters(trialCounter, helperBeta(Counter([numX]))))
						 SET totalVals TO 0
						 FOR EACH valX IN trialCounter VALUES DO
							totalVals = totalVals + valX
						 END FOR
						 IF totalVals <= spaceRem THEN
							  SET fillCount TO spaceRem - totalVals
							  SET part1 TO SUBSTRING(number, 0, recursionIndex)
							  SET part2 TO STRING(numX)
							  SET part3 TO REPEAT("1", fillCount)
							  SET part4 TO ""
							  FOR EACH keyQ, valQ IN trialCounter DO
								   FOR _ FROM 1 TO valQ DO
										part4 = part4 + keyQ
								   END FOR
							  END FOR
							  RETURN part1 + part2 + part3 + part4
						 END IF
					END FOR
				END IF
				SET recursionIndex TO recursionIndex - 1
				RETURN runLoop()
		  END FUNCTION
		  
		  SET outcome TO runLoop()
		  IF outcome IS NOT NULL THEN RETURN outcome END IF
		  
		  SET deltaFinal TO helperBeta(lambda)
		  SET finalLength TO LENGTH(number) + 1
		  SET countSumFinal TO 0
		  FOR EACH valZ IN deltaFinal VALUES DO
			   countSumFinal = countSumFinal + valZ
		  END FOR
		  SET frontPart TO REPEAT("1", finalLength - countSumFinal)
		  SET backPart TO ""
		  FOR EACH keyY, valY IN deltaFinal DO
			   FOR _ FROM 1 TO valY DO
					backPart = backPart + keyY
			   END FOR
		  END FOR
		  RETURN frontPart + backPart
	 END FUNCTION
END CLASS