CLASS Solution  
    FUNCTION minOrAfterOperations(nums k)  
        FUNCTION canAchieve(target_or k)  
            FUNCTION bitwiseAnd(x y)  
                RETURN x AND y  
            END FUNCTION  
            FUNCTION isZero(val)  
                RETURN val EQUALS 0  
            END FUNCTION  
            FUNCTION isMinusOne(val)  
                RETURN val EQUALS -1  
            END FUNCTION  
            FUNCTION increment(val)  
                RETURN val + 1  
            END FUNCTION  
            SET alpha TO -1  
            SET bravo TO 0  
            FUNCTION processList(lst idx acc)  
                IF idx GREATER OR EQUAL TO LENGTH(lst)  
                    RETURN acc  
                END IF  
                SET delta TO lst[idx]  
                IF isMinusOne(alpha)  
                    SET alpha TO delta  
                ELSE  
                    SET alpha TO bitwiseAnd(alpha delta)  
                END IF  
                IF isZero(bitwiseAnd(alpha target_or))  
                    SET alpha TO -1  
                ELSE  
                    SET bravo TO increment(bravo)  
                    IF bravo GREATER THAN k  
                        RETURN false  
                    END IF  
                END IF  
                RETURN processList(lst idx + 1 acc)  
            END FUNCTION  
            SET echo TO processList(nums 0 true)  
            IF echo IS false  
                RETURN false  
            ELSE  
                RETURN true  
            END IF  
        END FUNCTION  
        FUNCTION powTwo(exp)  
            IF exp EQUALS 0  
                RETURN 1  
            ELSE  
                RETURN 2 * powTwo(exp - 1)  
            END IF  
        END FUNCTION  
        SET max_possible_value TO powTwo(30) - 1  
        SET result TO max_possible_value  
        FUNCTION loopBits(bit)  
            IF bit GREATER THAN 29  
                RETURN  
            END IF  
            SET bit_mask TO powTwo(bit)  
            IF (result AND bit_mask) EQUALS 0  
                loopBits(bit + 1)  
                RETURN  
            END IF  
            FUNCTION logicalNot(val)  
                RETURN val EQUALS 0 ? 1 : 0  
            END FUNCTION  
            FUNCTION logicalNotBitmask(val)  
                RETURN MAX_INTEGER_CONSTANT - val  
            END FUNCTION  
            SET inverted_mask TO MAX_INTEGER_CONSTANT - bit_mask  
            SET candidate TO result AND inverted_mask  
            SET test_value TO candidate  
            SET condition_value TO test_value  
            SET xor_val TO (MAX_INTEGER_CONSTANT - result) XOR bit_mask  
            IF canAchieve(xor_val k)  
                SET result TO candidate  
            END IF  
            loopBits(bit + 1)  
        END FUNCTION  
        SET MAX_INTEGER_CONSTANT TO max_possible_value  
        loopBits(0)  
        RETURN result  
    END FUNCTION  
END CLASS