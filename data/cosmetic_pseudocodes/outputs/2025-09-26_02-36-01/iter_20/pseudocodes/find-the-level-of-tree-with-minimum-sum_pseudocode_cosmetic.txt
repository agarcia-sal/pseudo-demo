CLASS TreeNode  
    FUNCTION __init__(self COMMA val EQUALS zero COMMA left EQUALS None COMMA right EQUALS None)  
      BEGIN  
        LET a1b TO val  
        LET c7d TO left  
        LET f9g TO right  
        STORE self.val WITH a1b  
        STORE self.left WITH c7d  
        STORE self.right WITH f9g  
      END FUNCTION  
END CLASS  

FUNCTION tree_node(values)  
  BEGIN  
    IF NOT (LEN(values) GREATER THAN 0) THEN  
      RETURN None  
    END IF  
    LET x23 TO new TreeNode(GET values AT 0)  
    LET y56 TO 0  
    LET z90 TO new deque  
    CALL z90.APPEND(x23)  
    REPEAT  
      IF z90.LENGTH EQUALS 0 THEN  
        BREAK  
      END IF  
      LET nOP TO z90.POP_LEFT()  
      IF (y56 LESS THAN LEN(values)) AND (values[y56] IS NOT None) THEN  
        LET llK TO new TreeNode(values[y56])  
        STORE nOP.left WITH llK  
        CALL z90.APPEND(llK)  
      END IF  
      LET y56 TO y56 PLUS 1  
      IF (y56 LESS THAN LEN(values)) AND (values[y56] IS NOT None) THEN  
        LET rrM TO new TreeNode(values[y56])  
        STORE nOP.right WITH rrM  
        CALL z90.APPEND(rrM)  
      END IF  
      LET y56 TO y56 PLUS 1  
    UNTIL False  
    RETURN x23  
  END FUNCTION  

FUNCTION is_same_tree(p COMMA q)  
  BEGIN  
    IF (p IS None) AND (q IS None) THEN  
      RETURN True  
    ELSE   
      IF (p IS None) OR (q IS None) THEN  
        RETURN False  
      ELSE  
        IF NOT ((p.val EQUALS q.val)) THEN  
          RETURN False  
        ELSE  
          LET left_eq TO is_same_tree(p.left COMMA q.left)  
          LET right_eq TO is_same_tree(p.right COMMA q.right)  
          RETURN left_eq AND right_eq  
        END IF  
      END IF  
    END IF  
  END FUNCTION  

CLASS Solution  
  FUNCTION minimumLevel(self COMMA root)  
    BEGIN  
      IF root IS None THEN RETURN 0 END IF  
      LET queue TO new deque  
      CALL queue.APPEND(root)  
      LET minL TO 1  
      LET minS TO +âˆž  
      LET curL TO 1  
      WHILE True  
        IF NOT (queue.LENGTH GREATER THAN 0) THEN BREAK END IF  
        LET sumLvl TO 0  
        LET lengthQ TO queue.LENGTH  
        LET idx TO 0  
        REPEAT  
          IF idx EQUALS lengthQ THEN BREAK END IF  
          LET tmpN TO queue.POP_LEFT()  
          LET sumLvl TO sumLvl PLUS tmpN.val  
          IF tmpN.left IS NOT None THEN CALL queue.APPEND(tmpN.left) END IF  
          IF tmpN.right IS NOT None THEN CALL queue.APPEND(tmpN.right) END IF  
          LET idx TO idx PLUS 1  
        UNTIL False  
        IF sumLvl LESS THAN minS THEN  
          LET minS TO sumLvl  
          LET minL TO curL  
        END IF  
        LET curL TO curL PLUS 1  
      END WHILE  
      RETURN minL  
    END FUNCTION  
END CLASS