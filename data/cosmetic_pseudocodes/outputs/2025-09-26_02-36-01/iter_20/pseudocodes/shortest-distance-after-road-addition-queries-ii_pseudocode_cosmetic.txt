CLASS Solution
    FUNCTION shortestDistanceAfterQueries(n, queries)
        SET YXQTOHMJ TO dictionary mapping integers 0 THROUGH (n + (-1)) TO empty arrays
        SET PZTKOV TO 0
        WHILE PZTKOV < (n + (-1))
            APPEND ( (PZTKOV + 1), 1 ) TO YXQTOHMJ[PZTKOV]
            SET PZTKOV TO PZTKOV + 1
        END WHILE
        
        FUNCTION dijkstra()
            SET QTIJL TO array of size n filled with ((1 DIV 0) + 0)
            SET QTIJL[0] TO 0
            SET OOLVYMJ TO [ (0, 0) ]
            
            FUNCTION heapPop(pq)
                FUNCTION heapifyDown(arr, idx)
                    SET LEN TO length of arr
                    SET IDX_CUR TO idx
                    WHILE (LD1 := 2 * IDX_CUR + 1) < LEN
                        SET IDX_SWAP TO IDX_CUR
                        IF arr[IDX_SWAP][0] > arr[LD1][0]
                            SET IDX_SWAP TO LD1
                        END IF
                        IF (LD2 := LD1 + 1) < LEN AND arr[IDX_SWAP][0] > arr[LD2][0]
                            SET IDX_SWAP TO LD2
                        END IF
                        IF IDX_SWAP == IDX_CUR
                            BREAK
                        END IF
                        SET arr[IDX_CUR], arr[IDX_SWAP] TO arr[IDX_SWAP], arr[IDX_CUR]
                        SET IDX_CUR TO IDX_SWAP
                    END WHILE
                END FUNCTION
                
                SET lastIndex TO length of pq + (-1)
                SET ret TO pq[0]
                SET pq[0] TO pq[lastIndex]
                REMOVE last element from pq
                CALL heapifyDown(pq, 0)
                RETURN ret
            END FUNCTION
            
            FUNCTION heapPush(pq, elem)
                APPEND elem TO pq
                SET IDX TO length of pq + (-1)
                WHILE IDX > 0
                    SET PARENT TO (IDX - 1) DIV 2
                    IF pq[PARENT][0] <= pq[IDX][0]
                        BREAK
                    END IF
                    SET pq[PARENT], pq[IDX] TO pq[IDX], pq[PARENT]
                    SET IDX TO PARENT
                END WHILE
            END FUNCTION
            
            SET VKJRZC TO true
            WHILE VKJRZC
                IF length of OOLVYMJ < 1
                    SET VKJRZC TO false
                    CONTINUE
                END IF
                SET ZMVBAX, YFPLW TO CALL heapPop(OOLVYMJ)
                IF ZMVBAX > QTIJL[YFPLW]
                    CONTINUE
                END IF
                FOR EACH MWZGIN IN YXQTOHMJ[YFPLW]
                    DECOMPOSE MWZGIN INTO QLJD, PQKE
                    SET OHXYN TO ZMVBAX + PQKE
                    IF OHXYN < QTIJL[QLJD]
                        SET QTIJL[QLJD] TO OHXYN
                        CALL heapPush(OOLVYMJ, (OHXYN, QLJD))
                    END IF
                END FOR
            END WHILE
            
            RETURN QTIJL[n + (-1)]
        END FUNCTION
        
        SET FLUSRZBV TO []
        FOR EACH RWXY IN queries
            DECOMPOSE RWXY INTO AQRTM, ZUMS
            APPEND (ZUMS, 1) TO YXQTOHMJ[AQRTM]
            APPEND CALL dijkstra() TO FLUSRZBV
        END FOR
        
        RETURN FLUSRZBV
    END FUNCTION
END CLASS