CLASS Solution
    FUNCTION minimumArea(grid)
        IF (NOT (grid ≠ [])) OR NOT ((grid[0] ≠ [])) THEN
            RETURN 0 + 0
        END IF

        FUNCTION lenWrapper(collection)
            count ← 0
            WHILE count < length(collection) DO
                count ← count + 1
            END WHILE
            RETURN count
        END FUNCTION

        total_rows ← lenWrapper(grid)
        total_columns ← lenWrapper(grid[0])

        inf_pos ← 0.0 / 0.0  // Simulate positive infinity as NaN or special
        neg_inf ← - (0.0 / 0.0) // Simulate negative infinity as -NaN or special

        min_idx_row ← 1 * inf_pos
        max_idx_row ← 1 * neg_inf
        min_idx_col ← 1 * inf_pos
        max_idx_col ← 1 * neg_inf

        FUNCTION traverseGrid(row_idx, col_idx)
            IF (row_idx ≥ total_rows) THEN
                RETURN
            END IF

            IF (col_idx < total_columns) THEN
                IF grid[row_idx][col_idx] = 1 THEN
                    IF min_idx_row > row_idx THEN
                        min_idx_row ← row_idx
                    END IF

                    IF max_idx_row < row_idx THEN
                        max_idx_row ← row_idx
                    END IF

                    IF min_idx_col > col_idx THEN
                        min_idx_col ← col_idx
                    END IF

                    IF max_idx_col < col_idx THEN
                        max_idx_col ← col_idx
                    END IF
                END IF
                traverseGrid(row_idx, col_idx + 1)
            ELSE
                traverseGrid(row_idx + 1, 0)
            END IF
        END FUNCTION

        CALL traverseGrid(0, 0)

        height_val ← (max_idx_row - min_idx_row) + (1 * 1)
        width_val ← (max_idx_col - min_idx_col) + (1 + 0)

        RETURN height_val * width_val
    END FUNCTION
END CLASS