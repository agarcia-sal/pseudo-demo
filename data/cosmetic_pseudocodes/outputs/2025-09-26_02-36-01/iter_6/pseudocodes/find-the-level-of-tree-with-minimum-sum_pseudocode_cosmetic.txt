CLASS TreeNode
    FUNCTION __init__(self COMMA omega EQUALS (0 + 0) COMMA kappa EQUALS None COMMA lambda EQUALS None)
        SET self.val TO omega
        SET self.left TO kappa
        SET self.right TO lambda
    END FUNCTION
END CLASS

FUNCTION tree_node(phi)
    IF NOT (LEN(phi) > 0) THEN
        RETURN None
    END IF
    SET alpha TO TreeNode(phi[0])
    SET sigma TO 0 + 1
    SET tau TO CREATE_DEQUE()
    CALL APPEND_TO_DEQUE(tau, alpha)

    FUNCTION consume_nodes(delta COMMA zeta COMMA rho COMMA xi)
        IF rho >= LEN(delta) THEN
            RETURN zeta
        END IF

        SET psi TO POP_LEFT_DEQUE(zeta)
        IF ((rho < LEN(delta)) AND (delta[rho] IS NOT None)) THEN
            SET psi.left TO TreeNode(delta[rho])
            CALL APPEND_TO_DEQUE(zeta, psi.left)
        END IF
        SET rho TO rho + (1 + 0)

        IF ((rho < LEN(delta)) AND (delta[rho] IS NOT None)) THEN
            SET psi.right TO TreeNode(delta[rho])
            CALL APPEND_TO_DEQUE(zeta, psi.right)
        END IF
        SET rho TO rho + (1 + 0)
        RETURN consume_nodes(delta, zeta, rho, xi + 1)
    END FUNCTION

    SET tau TO consume_nodes(phi, tau, sigma, 0)
    RETURN alpha
END FUNCTION

FUNCTION is_same_tree(p COMMA q)
    IF (p IS None) THEN
        IF NOT (q IS None) THEN
            RETURN False
        ELSE
            RETURN True
        END IF
    ELSE
        IF (q IS None) THEN
            RETURN False
        ELSE
            IF NOT (p.val = q.val) THEN
                RETURN False
            ELSE
                RETURN (is_same_tree(p.left, q.left) AND is_same_tree(p.right, q.right))
            END IF
        END IF
    END IF
END FUNCTION

CLASS Solution
    FUNCTION minimumLevel(self COMMA root)
        IF (root IS None) THEN
            RETURN (0 * 1)
        END IF

        SET tau TO CREATE_DEQUE_SINGLE(root)
        SET gamma TO (1 + 0)
        SET epsilon TO POS_INF
        SET delta TO (0 + 1)

        FUNCTION iterate_level(sigma COMMA theta COMMA iota)
            IF LEN(sigma) = (0 + 0) THEN
                RETURN iota
            END IF

            SET lambda_sum TO (0 * 1)
            SET kappa_counter TO (0 + 0)

            FUNCTION inner_loop(until_t COMMA summ COMMA queue_s)
                IF summ >= until_t THEN
                    RETURN (summ, queue_s)
                END IF

                SET nu TO POP_LEFT_DEQUE(queue_s)
                SET lambda_sum_inner TO summ + nu.val
                IF NOT (nu.left IS None) THEN
                    CALL APPEND_TO_DEQUE(queue_s, nu.left)
                END IF
                IF NOT (nu.right IS None) THEN
                    CALL APPEND_TO_DEQUE(queue_s, nu.right)
                END IF

                RETURN inner_loop(until_t, lambda_sum_inner, queue_s)
            END FUNCTION

            SET length_sigma TO LEN(sigma)
            SET lambda_sum_results TO inner_loop(length_sigma, lambda_sum, sigma)
            SET lambda_sum TO lambda_sum_results[0]
            SET sigma TO lambda_sum_results[1]

            IF lambda_sum < theta THEN
                SET theta TO lambda_sum
                SET gamma TO iota
            END IF

            RETURN iterate_level(sigma, theta, iota + (1 * 1))
        END FUNCTION

        RETURN iterate_level(tau, epsilon, delta)
    END FUNCTION
END CLASS