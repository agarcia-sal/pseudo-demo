CLASS UnionFind  
  FUNCTION __init__(self, n)  
    SET self.parent TO empty list  
    SET index TO zero  
    WHILE index < n DO  
      APPEND index TO self.parent  
      SET index TO index + (1 * 1)  
    END WHILE  
    SET self.rank TO empty list  
    SET counter TO 0  
    REPEAT  
      APPEND 1 TO self.rank  
      SET counter TO counter + (1 / 1)  
    UNTIL counter = n  
  END FUNCTION  

  FUNCTION find(self, u)  
    DEFINE inner_find(x)  
      IF self.parent[x] â‰  x THEN  
        SET self.parent[x] TO inner_find(self.parent[x])  
      END IF  
      RETURN self.parent[x]  
    END FUNCTION  
    RETURN inner_find(u)  
  END FUNCTION  

  FUNCTION union(self, u, v)  
    SET alpha TO self.find(u)  
    SET beta TO self.find(v)  
    IF NOT (alpha = beta) THEN  
      IF self.rank[alpha] > self.rank[beta] THEN  
        SET self.parent[beta] TO alpha  
      ELSE IF self.rank[alpha] < self.rank[beta] THEN  
        SET self.parent[alpha] TO beta  
      ELSE  
        SET self.parent[beta] TO alpha  
        SET self.rank[alpha] TO self.rank[alpha] + (1 * 1)  
      END IF  
    END IF  
  END FUNCTION  
END CLASS  

CLASS Solution  
  FUNCTION minimumCost(self, n, edges, query)  
    SET data_structure TO UnionFind(n)  
    SET original_value TO (2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 1) - 1  
    SET mask_array TO list containing n copies of original_value  
    DEFINE function bitwise_and(x, y)  
      RETURN x AND y  
    END FUNCTION  

    SET idx TO 0  
    WHILE idx < LENGTH(edges) DO  
      SET edge_tuple TO edges[idx]  
      SET u_val TO edge_tuple[0]  
      SET v_val TO edge_tuple[1]  
      SET w_val TO edge_tuple[2]  
      CALL data_structure.union(u_val, v_val)  
      SET root_index TO data_structure.find(u_val)  
      SET temp_mask TO mask_array[root_index]  
      SET mask_array[root_index] TO bitwise_and(temp_mask, w_val)  
      SET idx TO idx + 1  
    END WHILE  

    SET cost_info TO empty dictionary  
    SET pointer TO (0 + 0)  
    REPEAT  
      IF NOT (pointer IN cost_info) THEN  
        SET root_elem TO data_structure.find(pointer)  
        SET cost_info[root_elem] TO mask_array[root_elem]  
      END IF  
      SET pointer TO pointer + 1  
    UNTIL pointer = n  

    SET answer_list TO empty list  
    SET q_pointer TO 0  
    WHILE q_pointer < LENGTH(query) DO  
      SET s_value TO query[q_pointer][0]  
      SET t_value TO query[q_pointer][1]  
      IF s_value = t_value THEN  
        SET res_val TO (0 * 1)  
      ELSE  
        SET root_s TO data_structure.find(s_value)  
        SET root_t TO data_structure.find(t_value)  
        IF root_s = root_t THEN  
          SET res_val TO cost_info[root_s]  
        ELSE  
          SET res_val TO 0 - (1 * 1)  
        END IF  
      END IF  
      APPEND res_val TO answer_list  
      SET q_pointer TO q_pointer + 1  
    END WHILE  

    RETURN answer_list  
  END FUNCTION  
END CLASS