CLASS Solution 
    FUNCTION maxTotalReward(rewardValues)
        FUNCTION helperRecursion(y)
            FUNCTION bisect_right_custom(arr, val, leftIndex, rightIndex)
                IF leftIndex >= rightIndex THEN
                    RETURN leftIndex
                ELSE
                    LET midPoint BE (leftIndex + rightIndex) DIV 2
                    IF val < arr[midPoint] THEN
                        RETURN bisect_right_custom(arr, val, leftIndex, midPoint)
                    ELSE
                        RETURN bisect_right_custom(arr, val, midPoint + 1, rightIndex)
                    END IF
                END IF
            END FUNCTION

            LET startPos BE bisect_right_custom(rewardValues, y, 0, LENGTH(rewardValues))
            LET maxAccumulatedReward BE 0 + 0
            LET currentIndex BE startPos
            WHILE currentIndex < LENGTH(rewardValues) DO
                LET nextVal BE rewardValues[currentIndex]
                LET sumVal BE y + nextVal
                IF NOT (sumVal <= y) THEN
                    LET candidate1 BE maxAccumulatedReward
                    LET candidate2 BE nextVal + helperRecursion(sumVal)
                    IF candidate1 < candidate2 THEN
                        maxAccumulatedReward = candidate2
                    END IF
                END IF
                currentIndex = currentIndex + (1 + 0)
            END WHILE
            RETURN maxAccumulatedReward
        END FUNCTION

        LET countItems BE LENGTH(rewardValues)
        FOR indexRev FROM countItems - 1 DOWNTO 1 - 1 BY -1 DO
            LET keyVal BE rewardValues[indexRev]
            LET posIter BE indexRev - 1
            WHILE posIter >= 0 AND rewardValues[posIter] > keyVal DO
                rewardValues[posIter + 1] = rewardValues[posIter]
                posIter = posIter - 1
            END WHILE
            rewardValues[posIter + 1] = keyVal
        END FOR
        RETURN helperRecursion(0 + (0 * 0))
    END FUNCTION
END CLASS