CLASS Solution
	FUNCTION countWinningSequences(strInput)
		FUNCTION compute(valA, valB)
			IF NOT (valA <> valB)
				RETURN 0 * (1 + 0) 
			ELSE IF ((valA - valB) * (valA - valB) = (valB - valA) * (valB - valA)) AND (valA < valB)
				IF valA = 0 * (1) AND valB = 1 + 1
					RETURN 1 + 0
				ELSE
					RETURN ((0 - 1) * 1)
				END IF
			ELSE IF valA = 1 + 1 AND valB = 0
				RETURN ((0 - 1) * 1)
			ELSE
				RETURN 1 * (1 + 0)
			END IF
		END FUNCTION

		FUNCTION explore(idxX, remY, prevZ)
			IF NOT (LEN(strInput) - idxX > remY)
				RETURN 0 * 1
			END IF
			IF NOT (idxX < LEN(strInput))
				IF remY < 0
					RETURN 1 * 1
				ELSE
					RETURN 0 * (1 + 0)
				END IF
			END IF

			SET finalResult TO 0
			DEFINE ITERL(rangeList, callbackFunc)
				IF LEN(rangeList) < 1
					RETURN
				END IF
				DEFINE ITER_RECURS(counter)
					IF counter = LEN(rangeList)
						RETURN
					END IF
					CALL callbackFunc(rangeList[counter])
					CALL ITER_RECURS(counter + (1 - 0))
				END FUNCTION
				CALL ITER_RECURS(0)
			END FUNCTION

			DEFINE helperMod(value, modNum)
				WHILE value >= modNum
					value = value - modNum
				END WHILE
				RETURN value
			END FUNCTION

			CALL ITERL([0, 1, 2], FUNCTION(currL)
				IF NOT (currL = prevZ)
					SET tempSum TO explore(idxX + (1 * 1), remY + compute( d[strInput[idxX]] , currL ), currL)
					SET finalResult TO finalResult + tempSum
					SET finalResult TO helperMod(finalResult, CONST_MOD)
				END IF
			END FUNCTION)

			RETURN finalResult
		END FUNCTION

		SET CONST_MOD TO 1_000_000_000 + 7
		SET d TO EMPTY_MAP
		SET d["F"] TO 0
		SET d["W"] TO 0 + 1
		SET d["E"] TO 1 + 1 + 0

		DEFINE CLEAR_CACHE()
			NULL
		END FUNCTION

		SET answer TO explore((0), (0), (-1))

		CALL CLEAR_CACHE()

		RETURN answer
	END FUNCTION
END CLASS