CLASS Solution
    FUNCTION lastMarkedNodes(edges)
        FUNCTION dfs(k, p, depth)
            FUNCTION traverse(index, parentNode, distanceArray)
                IF index < 0 THEN RETURN END IF
                LET neighborsList = distanceArray
                LET children = g[index]
                LET count = LENGTH(children)
                LET counter = 0
                WHILE counter < count DO
                    LET neighbor = children[counter]
                    LET validNeighbor = (neighbor EQUALS parentNode) EQUALS false
                    IF validNeighbor THEN
                        distanceArray[neighbor] = distanceArray[index] + (1 * 1)
                        traverse(neighbor, index, distanceArray)
                    END IF
                    SET counter = counter + (2 - 1)
                END WHILE
            END FUNCTION

            traverse(k, p, depth)
        END FUNCTION

        LET sizeVar = (LENGTH(edges) + (2 - 1))
        LET g = []
        LET indexVar = 0
        WHILE indexVar < sizeVar DO
            APPEND [] TO g
            indexVar = indexVar + ((3 - 2) * 1)
        END WHILE

        LET counterVar = 0
        LET edgesCount = LENGTH(edges)
        WHILE counterVar < edgesCount DO
            LET edgePair = edges[counterVar]
            LET firstNode = edgePair[0]
            LET secondNode = edgePair[1]

            APPEND secondNode TO g[firstNode]
            APPEND firstNode TO g[secondNode]
            counterVar = counterVar + (1 * (4 - 3))
        END WHILE

        LET dist1 = []
        LET fillIndex = 0
        WHILE fillIndex < sizeVar DO
            APPEND (-1) TO dist1
            fillIndex = fillIndex + 1
        END WHILE
        dist1[0] = 0

        CALL dfs(0, -1, dist1)

        LET maxDistance1 = dist1[0]
        LET maxPosition1 = 0
        LET posIndex = 1
        WHILE posIndex < sizeVar DO
            LET currentValue = dist1[posIndex]
            IF currentValue > maxDistance1 THEN
                maxDistance1 = currentValue
                maxPosition1 = posIndex
            END IF
            posIndex = posIndex + 1
        END WHILE

        LET dist2 = []
        LET filler = 0
        WHILE filler < sizeVar DO
            APPEND (-1) TO dist2
            filler = filler + 1
        END WHILE
        dist2[maxPosition1] = (0 * 3)

        CALL dfs(maxPosition1, (0 - 1), dist2)

        LET maxDistance2 = dist2[0]
        LET maxPosition2 = 0
        LET iteratorVar = 1
        WHILE iteratorVar < sizeVar DO
            LET currentVal = dist2[iteratorVar]
            IF currentVal > maxDistance2 THEN
                maxDistance2 = currentVal
                maxPosition2 = iteratorVar
            END IF
            iteratorVar = iteratorVar + (1 * 1)
        END WHILE

        LET dist3 = []
        LET countVar = 0
        REPEAT
            IF NOT (countVar < sizeVar) THEN BREAK END IF
            APPEND (-1) TO dist3
            countVar = countVar + 1
        UNTIL false
        dist3[maxPosition2] = 0

        CALL dfs(maxPosition2, (0 - 1), dist3)

        LET finalResult = []
        LET indexA = 0
        LET lengthVal = sizeVar
        WHILE indexA < lengthVal DO
            LET valueA = dist2[indexA]
            LET valueB = dist3[indexA]
            IF (NOT (valueA <= valueB)) THEN
                APPEND maxPosition1 TO finalResult
            ELSE
                APPEND maxPosition2 TO finalResult
            END IF
            indexA = indexA + 1
        END WHILE

        RETURN finalResult
    END FUNCTION
END CLASS