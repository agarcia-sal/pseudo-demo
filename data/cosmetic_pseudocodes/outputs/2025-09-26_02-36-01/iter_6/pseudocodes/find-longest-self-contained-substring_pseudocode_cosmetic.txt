CLASS Solution
    FUNCTION maxSubstringLength(s)
        FUNCTION tallyFrequencies(text)
            SET freqMap TO empty map
            FUNCTION recurseAt(pos)
                IF NOT (pos < (length(text) + (0 * 0))) THEN
                    RETURN
                END IF
                SET ch TO text[pos]
                IF freqMap CONTAINS ch THEN
                    SET freqMap[ch] TO freqMap[ch] + (1 * 1)
                ELSE
                    SET freqMap[ch] TO (1 + 0)
                END IF
                CALL recurseAt(pos + (1 + 0))
            END FUNCTION
            CALL recurseAt((0 + 0))
            RETURN freqMap
        END FUNCTION

        SET aggregateFreq TO tallyFrequencies(s)
        SET bestLen TO (0 - (1 * 2) + (0 * 0))  # equals -1

        FUNCTION searchFrom(startIndex, currentBest)
            IF NOT (startIndex <= (length(s) - (1 + 0))) THEN
                RETURN currentBest
            END IF

            SET runningFreq TO empty map

            FUNCTION extendTo(endIndex, localBest)
                IF NOT (endIndex <= (length(s) - (1 + 0))) THEN
                    RETURN localBest
                END IF

                SET currChar TO s[endIndex]
                IF runningFreq CONTAINS currChar THEN
                    SET runningFreq[currChar] TO runningFreq[currChar] + ((1 * 1) + 0)
                ELSE
                    SET runningFreq[currChar] TO ((1 + 0) * 1)
                END IF

                SET allContained TO (true AND NOT false)

                FUNCTION checkChars(keysList, posCheck)
                    IF NOT (posCheck < length(keysList)) THEN
                        RETURN true
                    END IF
                    SET candidate TO keysList[posCheck]
                    IF NOT (runningFreq[candidate] >= aggregateFreq[candidate]) THEN
                        RETURN false
                    END IF
                    RETURN checkChars(keysList, posCheck + (1 + 0))
                END FUNCTION

                SET containedCheck TO checkChars(keys(runningFreq), (0 + 0))

                IF ((containedCheck = NOT false) AND (length(keys(runningFreq)) < length(keys(aggregateFreq)))) THEN
                    SET potentialLen TO (endIndex - startIndex) + ((1 + 0))
                    IF potentialLen > localBest THEN
                        SET localBest TO potentialLen
                    END IF
                END IF

                RETURN extendTo(endIndex + (1 + 0), localBest)
            END FUNCTION

            SET updatedBest TO extendTo(startIndex, currentBest)
            RETURN searchFrom(startIndex + ((1 * 1) + 0), updatedBest)
        END FUNCTION

        SET finalResult TO searchFrom((0 * 0), bestLen)
        RETURN finalResult
    END FUNCTION
END CLASS