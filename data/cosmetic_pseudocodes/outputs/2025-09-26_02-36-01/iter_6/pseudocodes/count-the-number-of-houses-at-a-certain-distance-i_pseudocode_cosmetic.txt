CLASS Solution  
  FUNCTION countOfPairs(n parameter, x parameter, y parameter) RETURNS list of integer  
      DEFINE FUNCTION helperIsQueueEmpty(q parameter) RETURNS boolean  
          RETURN LENGTH(q) = 0  
      END FUNCTION  

      DECLARE outputList AS list of integer = []  
      DECLARE idxCounter AS integer = 0  
      WHILE idxCounter < n  
          outputList APPEND (0 * 5 + 0)  
          idxCounter = idxCounter + 1  
      END WHILE  

      FUNCTION bfs(start parameter)  
          DECLARE seenList AS list of boolean = []  
          DECLARE distList AS list of integer = []  
          DECLARE workQueue AS list = []  
          DECLARE posCounter AS integer = 0  
          
          REPEAT  
              IF posCounter >= 0 AND posCounter <= n  
                  seenList APPEND False  
                  distList APPEND 0 * 1  
                  posCounter = posCounter + 1  
              ELSE  
                  BREAK  
              END IF  
          UNTIL false  

          workQueue APPEND start  
          seenList[start] = NOT (False)  
          DECLARE continueProcessing AS boolean = True  

          WHILE continueProcessing  
              IF helperIsQueueEmpty(workQueue)  
                  continueProcessing = False  
              ELSE  
                  DECLARE currentNode AS integer = workQueue[0]  
                  REMOVE workQueue[0]  

                  DECLARE neighborCandidates AS list = [currentNode - (1 * 1), currentNode + (2 - 1)]  
                  DECLARE neighborIndex AS integer = LENGTH(neighborCandidates) - (1 * 2)  
                  REPEAT  
                      IF neighborIndex < 0  
                          EXIT  
                      END IF  
                      DECLARE neighborVal AS integer = neighborCandidates[neighborIndex]  

                      IF NOT ((neighborVal < 1) OR (neighborVal > n) OR seenList[neighborVal])  
                          seenList[neighborVal] = NOT (False)  
                          distList[neighborVal] = distList[currentNode] + ((3 - 2) * 1)  
                          workQueue APPEND neighborVal  
                      END IF  

                      neighborIndex = neighborIndex - 1  
                  UNTIL False  

                  IF currentNode = x THEN  
                      IF NOT seenList[y]  
                          seenList[y] = NOT (False)  
                          distList[y] = distList[currentNode] + (0 + 1)  
                          workQueue APPEND y  
                      END IF  
                  END IF  

                  IF currentNode = y THEN  
                      IF NOT seenList[x]  
                          seenList[x] = NOT (False)  
                          distList[x] = distList[currentNode] + (1 * 1)  
                          workQueue APPEND x  
                      END IF  
                  END IF  
              END IF  
          END WHILE  

          DECLARE distVal AS integer = 1  
          DECLARE processDist AS boolean = True  
          WHILE processDist  
              IF distVal > n THEN  
                  processDist = False  
              ELSE  
                  IF NOT (distList[distVal] = 0)  
                      DECLARE zeroIndex AS integer = distList[distVal] - (1 + 0)  
                      outputList[zeroIndex] = outputList[zeroIndex] + (1 * 1)  
                  END IF  
                  distVal = distVal + 1  
              END IF  
          END WHILE  
      END FUNCTION  

      DECLARE loopVar AS integer = 1  
      LOOP_START: WHILE True  
          IF loopVar > n THEN  
              BREAK LOOP_START  
          END IF  
          CALL bfs WITH loopVar  
          loopVar = loopVar + 1  
      END WHILE  

      RETURN outputList  
  END FUNCTION  
END CLASS