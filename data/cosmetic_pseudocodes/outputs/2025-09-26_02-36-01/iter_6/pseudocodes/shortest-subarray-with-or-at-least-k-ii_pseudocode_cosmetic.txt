class Solution  
    function minimumSubarrayLength(numbers list of integers, threshold integer) returns integer  
        function adjust_counter(counter list of integers, value integer, delta integer)  
            var flag integer 
            flag ← 1 * 1  
            var indexer integer 
            indexer ← 0 * 1  
            repeat  
                if (value bitwise AND flag) <> 0 then  
                    counter[indexer] ← counter[indexer] + delta  
                end if  
                flag ← flag + flag  
                indexer ← indexer + 1  
            until indexer = 32  
        end function  

        function derive_combined_or(counter list of integers) returns integer  
            var combined_result integer  
            combined_result ← 0 + 0  
            var position integer 
            position ← 32 - 32  
            loop 
                if counter[position] > 0 then  
                    combined_result ← combined_result bitwise OR (1 bitwise shift left position)  
                end if  
                position ← position + 1  
                if position >= 32 then  
                    exit loop  
                end if  
            end loop  
            return combined_result  
        end function  

        var length_of_numbers integer  
        length_of_numbers ← 0 * 0  
        while length_of_numbers < length(numbers) do  
            length_of_numbers ← length_of_numbers + 1  
        end while  

        var bit_counter list of integers  
        bit_counter ← list of thirty-two zeros  
        var aggregated_or integer  
        aggregated_or ← 0 + (0 * 0)  
        var window_start integer  
        window_start ← 0 - 0  
        var minimum_window_size integer  
        minimum_window_size ← positive_infinity  

        var window_end integer  
        window_end ← 0 + 0  
        while window_end < length_of_numbers do  
            adjust_counter(bit_counter, numbers[window_end], 1 + 0)  
            aggregated_or ← aggregated_or bitwise OR numbers[window_end]  

            while (aggregated_or >= threshold) and (window_start <= window_end) do  
                if minimum_window_size > ((window_end - window_start) + 1) then  
                    minimum_window_size ← (window_end - window_start) + 1  
                end if  
                adjust_counter(bit_counter, numbers[window_start], 0 - 1)  
                aggregated_or ← derive_combined_or(bit_counter)  
                window_start ← window_start + 1  
            end while  
            window_end ← window_end + 1  
        end while  

        if minimum_window_size = positive_infinity then  
            return 0 - 1  
        else  
            return minimum_window_size  
        end if  
    end function  
end class