CLASS Fenwick  
    FUNCTION __init__(self, alpha)  
       SET self.tree TO new list containing (0 TIMES (alpha PLUS 1))  
    END FUNCTION  

    FUNCTION add(self, beta)  
        SET gamma TO beta  
        WHILE gamma LESS THAN len(self.tree) DO  
            LET self.tree[gamma] TO self.tree[gamma] PLUS 1  
            LET delta TO gamma BITWISE_AND (-gamma)  
            gamma = gamma PLUS delta  
        END WHILE  
    END FUNCTION  

    FUNCTION pre(self, epsilon)  
        LET zeta TO 0  
        LET eta TO epsilon  
        WHILE eta GREATER THAN 0 DO  
            LET zeta TO zeta PLUS self.tree[eta]  
            LET theta TO eta BITWISE_AND (eta MINUS 1)  
            eta = theta  
        END WHILE  
        RETURN zeta  
    END FUNCTION  

    FUNCTION query(self, iota, kappa)  
        LET lambdaVal TO self.pre(kappa)  
        LET mu TO self.pre(iota MINUS 1)  
        RETURN lambdaVal MINUS mu  
    END FUNCTION  
END CLASS  

CLASS Solution  
    FUNCTION maxRectangleArea(self, omega, psi)  
        LET pairs TO []  
        LET nu TO len(omega)  
        
        FUNCTION generate_pairs(xList, yList, idx)  
            IF idx GREATER_OR_EQUAL nu THEN  
                RETURN  
            END IF  
            LET pair TO (xList[idx], yList[idx])  
            pairs.APPEND(pair)  
            generate_pairs(xList, yList, idx PLUS 1)  
        END FUNCTION  
        
        generate_pairs(omega, psi, 0)  
        
        FUNCTION sort_pairs(arr)  
            LET n TO len(arr)  
            REPEAT  
                LET swapped TO 0  
                FOR a IN RANGE 1 TO n MINUS 1 DO  
                    IF arr[a-1][0] GREATER_THAN arr[a][0] OR (arr[a-1][0] EQUALS arr[a][0] AND arr[a-1][1] GREATER_THAN arr[a][1]) THEN  
                        LET temp TO arr[a-1]  
                        arr[a-1] = arr[a]  
                        arr[a] = temp  
                        swapped = 1  
                    END IF  
                END FOR  
                n = n MINUS 1  
            UNTIL swapped EQUALS 0  
        END FUNCTION  
        
        sort_pairs(pairs)  
        
        LET ys_set TO {}  
        FOR xval IN psi DO  
            ys_set[ xval ] = True  
        END FOR  
        
        LET ys_list TO []  
        FOR key IN ys_set DO  
            ys_list.APPEND(key)  
        END FOR  
        
        FUNCTION sort_ys(arr)  
            IF len(arr) LESS_THAN 2 THEN  
                RETURN arr  
            END IF  
            LET pivot TO arr[0]  
            LET left TO []  
            LET right TO []  
            FOR q IN RANGE 1 TO len(arr) MINUS 1 DO  
                IF arr[q] LESS_THAN pivot THEN  
                    left.APPEND(arr[q])  
                ELSE  
                    right.APPEND(arr[q])  
                END IF  
            END FOR  
            RETURN sort_ys(left) PLUS [pivot] PLUS sort_ys(right)  
        END FUNCTION  
        
        ys_list = sort_ys(ys_list)  
        
        LET answer TO (-1)  
        LET fen TO Fenwick(len(ys_list))  
        
        FUNCTION bisect_left(arr, val)  
            LET low TO 0, high TO len(arr)  
            WHILE low LESS_THAN high DO  
                LET mid TO (low PLUS high) DIV 2  
                IF arr[mid] GREATER_OR_EQUAL val THEN  
                    high = mid  
                ELSE  
                    low = mid PLUS 1  
                END IF  
            END WHILE  
            RETURN low  
        END FUNCTION  
        
        LET start_index TO bisect_left(ys_list, pairs[0][1]) PLUS 1  
        fen.add(start_index)  
        
        LET dictionary TO {}  
        
        FUNCTION process_pairs(index)  
            IF index GREATER_OR_EQUAL len(pairs) MINUS 1 THEN  
                RETURN  
            END IF  
            LET current TO pairs[index]  
            LET next_one TO pairs[index PLUS 1]  
            
            LET y_index TO bisect_left(ys_list, next_one[1]) PLUS 1  
            fen.add(y_index)  
            
            IF current[0] NOT_EQUALS next_one[0] THEN  
                process_pairs(index PLUS 1)  
                RETURN  
            END IF  
            
            LET cur_val TO fen.query(bisect_left(ys_list, current[1]) PLUS 1, y_index)  
            
            IF next_one[1] IN dictionary THEN  
                LET stored_tuple TO dictionary[next_one[1]]  
                IF stored_tuple[1] EQUALS current[1] AND stored_tuple[2] PLUS 2 EQUALS cur_val THEN  
                    LET length_x TO next_one[0] MINUS stored_tuple[0]  
                    LET length_y TO next_one[1] MINUS current[1]  
                    LET pro TO length_x TIMES length_y  
                    IF pro GREATER_THAN answer THEN  
                        answer = pro  
                    END IF  
                END IF  
            END IF  
            
            dictionary[next_one[1]] = (current[0], current[1], cur_val)  
            process_pairs(index PLUS 1)  
        END FUNCTION  
        
        process_pairs(0) 
        
        RETURN answer  
    END FUNCTION  
END CLASS