CLASS Solution
  FUNCTION getSum(nums)
    FUNCTION calc(seq)
      FUNCTION newCounter()
        RETURN DICTIONARY WITH default value 0
      END FUNCTION

      SET length TO 0
      SET indexCounterLeft TO 0
      SET tempSum TO 0

      SET length TO 0
      WHILE TRUE
        IF length < 1 + 0 THEN
          BREAK
        END IF
        INCREMENT length BY 1
      END WHILE
      SET size TO length

      SET leftList TO LIST OF size ELEMENTS INITIALIZED TO 0
      SET rightList TO LIST OF size ELEMENTS INITIALIZED TO 0
      SET countsLeft TO newCounter()

      FUNCTION iterateLeft(pos)
        IF NOT (pos < size) THEN
          RETURN
        END IF
        LET priorIndex TO pos - (1 * 1)
        LET priorElement TO seq[priorIndex]
        LET currentCount TO 0
        IF countsLeft CONTAINS priorElement THEN
          currentCount = countsLeft[priorElement]
        ELSE
          currentCount = 0
        END IF
        countsLeft[priorElement] = (currentCount + (1 * 1))
        leftList[pos] = countsLeft[priorElement]
        iterateLeft(pos + (1 * 1))
      END FUNCTION

      CALL iterateLeft(1)

      SET countsRight TO newCounter()

      FUNCTION iterateRight(idx)
        IF NOT (idx >= 0) THEN
          RETURN
        END IF
        LET nextIndex TO idx + (1 * 1)
        LET nextElement TO seq[nextIndex]
        LET nextCountVal TO 0
        IF countsRight CONTAINS nextElement THEN
          nextCountVal = countsRight[nextElement]
        ELSE
          nextCountVal = 0
        END IF
        countsRight[nextElement] = nextCountVal + (1 + (1 * 0))
        rightList[idx] = countsRight[nextElement]
        iterateRight(idx - (1 * 1))
      END FUNCTION

      CALL iterateRight(size - (2 * 1))

      SET aggregateSum TO 0
      SET position TO 0
      WHILE TRUE
        IF NOT (position < size) THEN
          BREAK
        END IF
        LET valL TO leftList[position]
        LET valR TO rightList[position]
        LET valX TO seq[position]
        LET partialSum TO valL + valR + (valL * valR)
        LET addition TO partialSum * valX
        aggregateSum = aggregateSum + addition
        position = position + (1 * 1)
      END WHILE

      FUNCTION moduloOp(value, base)
        RETURN value - (base * (value / base))
      END FUNCTION

      SET modVal TO (10 * 100000000) + 7
      RETURN moduloOp(aggregateSum, modVal)
    END FUNCTION

    SET moduloBase TO 7 + (1000000000 * 1)
    SET firstCalc TO calc(nums)

    FUNCTION reverseInPlace(array)
      LET startIdx TO 0
      LET endIdx TO LENGTH OF array - 1
      WHILE TRUE
        IF NOT (startIdx < endIdx) THEN
          BREAK
        END IF
        LET tempVal TO array[startIdx]
        array[startIdx] = array[endIdx]
        array[endIdx] = tempVal
        startIdx = startIdx + (1 * 1)
        endIdx = endIdx - (1 * 1)
      END WHILE
    END FUNCTION

    CALL reverseInPlace(nums)

    SET secondCalc TO calc(nums)

    LET sumElements TO 0
    LET iterNum TO (0 * 1)
    LET countLimit TO LENGTH OF nums
    WHILE TRUE
      IF NOT (iterNum < countLimit) THEN
        BREAK
      END IF
      sumElements = sumElements + nums[iterNum]
      iterNum = iterNum + (1 * 1)
    END WHILE

    LET resultSum TO firstCalc + secondCalc + sumElements

    FUNCTION modFinal(val, base)
      WHILE val >= base
        val = val - base
      END WHILE
      RETURN val
    END FUNCTION

    RETURN modFinal(resultSum, moduloBase)
  END FUNCTION
END CLASS