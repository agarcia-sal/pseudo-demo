{
  "prompt": "Given input pseudocode, produce a fully transformed version that adheres to these strict requirements:\n\n- Functional equivalence: The output pseudocode must retain the exact original behavior, producing identical output, side effects, and adhering to all logic precisely.\n\n- Idempotent identifiers and structure: Preserve verbatim all class names, function/method names, class inheritance, and object organization exactly as in the input pseudocode. Function/method signatures (name, parameters, order, and return types if given) must remain unchanged. Do not rename or restructure these elements.\n\n- Maximize difference in all other code aspects, applying comprehensive, layered rewrites including but not limited to:  \n  \u2022 Convert all loop forms into alternate logically equivalent constructs, completely changing their style (for \u2194 while \u2194 recursion \u2194 tail recursion \u2194 repeat-until).  \n  \u2022 Globally rename every local variable, parameter, and temporary identifier to new, semantically consistent but unrelated names never used originally. Avoid repeating any original local or temporary name.  \n  \u2022 Restructure all expressions deeply: switch arithmetic and logical equivalences, exploit identities, rewrite conditionals via De Morgan\u2019s rules, replace compound operators with expanded forms and vice versa, reorder independent operations safely, use equivalent but differently formulated index computations.  \n  \u2022 Drastically reshape control flow by splitting or merging conditionals or loops, unrolling or refolding iterations, inlining or extracting expressions or subcomputations, switching between early returns and deferred return variables.  \n  \u2022 Introduce and remove intermediate temporary variables smartly to alter expression grouping and sequencing while preserving all dependencies and outcomes.  \n  \u2022 Substitute literal constants consistently with expanded expressions (e.g., use sums or multiplications to express numeric literals), alternative boolean literal styles, and alternate explicit constant definitions or derivations.  \n  \u2022 Vary all formatting styles thoroughly: change indentation, spacing, block delimiters, keyword casing, and line breaks to appear stylistically independent from the input.  \n  \u2022 Change traversal order of data structures where output and side effects remain invariant (e.g., iterate forwards versus backwards).  \n  \u2022 Replace direct calls to built-in or library routines with functionally identical custom helper subroutines defined locally, or vice versa.  \n  \u2022 Convert iterative constructs to recursion and recursion to iteration wherever semantics allow.  \n  \u2022 Re-express condition checks to equivalent alternative logical constructs, including nested ifs replaced with guard clauses or combined guards replaced by split conditionals.  \n  \u2022 Avoid any reuse of original local variable or temporary identifiers; ensure all such names are newly generated and unrelated to originals.  \n  \u2022 Preserve external API and interface identifiers exactly and verbatim with zero changes.\n\n- Do not remove, add, or abstract any algorithms, data structures, steps, or conceptual elements. No optimizations or semantic shortcuts allowed that change or simplify the logic.\n\n- The output must be exactly the rewritten pseudocode alone, presented as a self-contained, original-seeming, standalone elaboration distinct in syntax and style, but strictly semantically identical.\n\n- This transformation applies universally to any input pseudocode regardless of domain or problem content.\n\n- Your response must only be the transformed pseudocode text; omit any explanations, comments, annotations, or supplemental remarks.\n\n- Emphasize layered orthogonal transformations leveraging syntax, semantics-preserving rewriting, control flow refactoring, identifier substitution, expression re-encodings, and formatting variation to force maximal syntactic divergence while preserving all named interface elements unmodified.\n\n- Maintain provided function and class names and structure exactly as in the input.\n\n- This prompt is designed to produce maximal surface-level divergence, generating rewritten pseudocode that appears fully independently implemented, with minimal lexical or structural resemblance to the original, beyond the essential preserved identifiers.\n\nOutput only the rewritten pseudocode.",
  "response": "Given input pseudocode, produce a fully transformed version that adheres to these strict requirements:\n\n- Functional equivalence: The output pseudocode must retain the exact original behavior, producing identical output, side effects, and adhering to all logic precisely.\n\n- Idempotent identifiers and structure: Preserve verbatim all class names, function/method names, class inheritance, and object organization exactly as in the input pseudocode. Function/method signatures (name, parameters, order, and return types if given) must remain unchanged. Do not rename or restructure these elements.\n\n- Maximize difference in all other code aspects, applying comprehensive, layered rewrites including but not limited to:  \n  \u2022 Convert all loop forms into alternate logically equivalent constructs, completely changing their style (for \u2194 while \u2194 recursion \u2194 tail recursion \u2194 repeat-until).  \n  \u2022 Globally rename every local variable, parameter, and temporary identifier to new, semantically consistent but unrelated names never used originally. Avoid repeating any original local or temporary name.  \n  \u2022 Restructure all expressions deeply: switch arithmetic and logical equivalences, exploit identities, rewrite conditionals via De Morgan\u2019s rules, replace compound operators with expanded forms and vice versa, reorder independent operations safely, use equivalent but differently formulated index computations.  \n  \u2022 Drastically reshape control flow by splitting or merging conditionals or loops, unrolling or refolding iterations, inlining or extracting expressions or subcomputations, switching between early returns and deferred return variables.  \n  \u2022 Introduce and remove intermediate temporary variables smartly to alter expression grouping and sequencing while preserving all dependencies and outcomes.  \n  \u2022 Substitute literal constants consistently with expanded expressions (e.g., use sums or multiplications to express numeric literals), alternative boolean literal styles, and alternate explicit constant definitions or derivations.  \n  \u2022 Vary all formatting styles thoroughly: change indentation, spacing, block delimiters, keyword casing, and line breaks to appear stylistically independent from the input.  \n  \u2022 Change traversal order of data structures where output and side effects remain invariant (e.g., iterate forwards versus backwards).  \n  \u2022 Replace direct calls to built-in or library routines with functionally identical custom helper subroutines defined locally, or vice versa.  \n  \u2022 Convert iterative constructs to recursion and recursion to iteration wherever semantics allow.  \n  \u2022 Re-express condition checks to equivalent alternative logical constructs, including nested ifs replaced with guard clauses or combined guards replaced by split conditionals.  \n  \u2022 Avoid any reuse of original local variable or temporary identifiers; ensure all such names are newly generated and unrelated to originals.  \n  \u2022 Preserve external API and interface identifiers exactly and verbatim with zero changes.\n\n- Do not remove, add, or abstract any algorithms, data structures, steps, or conceptual elements. No optimizations or semantic shortcuts allowed that change or simplify the logic.\n\n- The output must be exactly the rewritten pseudocode alone, presented as a self-contained, original-seeming, standalone elaboration distinct in syntax and style, but strictly semantically identical.\n\n- This transformation applies universally to any input pseudocode regardless of domain or problem content.\n\n- Your response must only be the transformed pseudocode text; omit any explanations, comments, annotations, or supplemental remarks.\n\n- Emphasize layered orthogonal transformations leveraging syntax, semantics-preserving rewriting, control flow refactoring, identifier substitution, expression re-encodings, and formatting variation to force maximal syntactic divergence while preserving all named interface elements unmodified.\n\n- Maintain provided function and class names and structure exactly as in the input.\n\n- This prompt is designed to produce maximal surface-level divergence, generating rewritten pseudocode that appears fully independently implemented, with minimal lexical or structural resemblance to the original, beyond the essential preserved identifiers.\n\nOutput only the rewritten pseudocode.",
  "score": -0.06283693914366376,
  "feedback": "The following are 20 lines of original pseudocode of a random subset of the problems along with their modified pseudocodes.\n\nPseudocode for Problem 1:\nCLASS Solution\n    FUNCTION minOrAfterOperations(nums o,k)\n        \n        FUNCTION canAchieve(p,q)\n            VARIABLE r = -1\n            VARIABLE s = 0\n            \n            FUNCTION process_index(u)\n                IF u >= LENGTH(o) THEN\n                    RETURN true\n                ELSE\n                    VARIABLE v = o[u]\n                    IF r = -1 THEN\n                        r = v\n                    ELSE\n                        r = r & v\n                    END IF\n                    IF (r & p) = 0 THEN\n                        r = -1\n                    ELSE\n\nModified Pseudocode for Problem 1:\nCLASS Solution  \n    FUNCTION minOrAfterOperations(nums k)  \n        FUNCTION canAchieve(target_or k)  \n            SET current_and TO minus one  \n            SET operations TO zero  \n            FOR each num IN nums  \n                IF current_and EQUALS minus one  \n                    SET current_and TO num  \n                ELSE  \n                    SET current_and TO current_and AND num  \n                END IF  \n                IF current_and AND target_or EQUALS zero  \n                    SET current_and TO minus one  \n                ELSE  \n                    INCREMENT operations BY one  \n                    IF operations GREATER THAN k  \n                        RETURN false  \n                    END IF  \n                END IF  \n            END FOR  \n\nPseudocode for Problem 2:\nCLASS Solution\n    FUNCTION stringIndices(wordsContainer wordsContainer TO LIST OF STRING, wordsQuery wordsQuery TO LIST OF STRING) RETURNS LIST OF INTEGER\n  SET suffix_dictionary TO empty dictionary mapping STRING to INTEGER\n\n  DEFINE FUNCTION compute_suffixes(idx_current INTEGER, word_current STRING)\n    IF idx_current >= LENGTH(word_current)\n      RETURN\n    END IF\n    SET suffix_extracted TO SUBSTRING(word_current, idx_current, LENGTH(word_current) - idx_current)\n    IF NOT(CONTAINS_KEY(suffix_dictionary, suffix_extracted))\n      suffix_dictionary[suffix_extracted] = idx_current\n    ELSE\n      SET existing_index TO suffix_dictionary[suffix_extracted]\n      SET existing_word TO wordsContainer[existing_index]\n      SET current_word_length TO LENGTH(word_current)\n      SET existing_word_length TO LENGTH(existing_word)\n      IF (current_word_length < existing_word_length) OR ((current_word_length = existing_word_length) AND (idx_current < existing_index))\n        suffix_dictionary[suffix_extracted] = idx_current\n      END IF\n    END IF\n\nModified Pseudocode for Problem 2:\nCLASS Solution  \n    FUNCTION stringIndices(wordsContainer wordsContainer TO LIST OF STRING, wordsQuery wordsQuery TO LIST OF STRING) RETURNS LIST OF INTEGER  \n        SET suffix_map TO empty dictionary mapping STRING to INTEGER  \n        \n        FOR each index WITH each word IN wordsContainer WITH their indices starting from zero  \n            FOR i FROM zero TO the LENGTH OF word MINUS one  \n                SET suffix TO substring from position i TO the end of word  \n                IF suffix NOT IN suffix_map THEN  \n                    SET suffix_map element at key suffix TO index  \n                ELSE IF suffix IN suffix_map THEN  \n                    IF the LENGTH OF word LESS THAN the LENGTH OF element at position suffix_map element at key suffix of wordsContainer OR  \n                       the LENGTH OF word EQUALS the LENGTH OF element at position suffix_map element at key suffix of wordsContainer AND index LESS THAN suffix_map element at key suffix THEN  \n                        SET suffix_map element at key suffix TO index  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        FUNCTION get_best_match(query query TO STRING) RETURNS INTEGER  \n            FOR i FROM zero TO the LENGTH OF query MINUS one  \n\nPseudocode for Problem 3:\nCLASS Solution\n    FUNCTION sumDigitDifferences(xyz)\n        FUNCTION digit_difference(pqr, stu)\n            SET delta TO 0 * 1 + 0\n            SET idx TO 0\n            SET len_pqr TO LENGTH(pqr)\n            FUNCTION compare_chars(a, b, pos)\n                IF pos >= len_pqr THEN\n                    RETURN a\n                ELSE\n                    SET diff_found TO a\n                    IF (NOT (b = a)) THEN\n                        SET diff_found TO diff_found + 1 * 1\n                    END IF\n                    RETURN compare_chars(diff_found, b, pos + 1)\n                END IF\n            END FUNCTION\n            WHILE idx < len_pqr\n                SET delta TO compare_chars(delta, IF_CHARACTER_AT(pqr, idx) != IF_CHARACTER_AT(stu, idx) THEN 1 ELSE 0, 0)\n                SET idx TO idx + 1\n\nModified Pseudocode for Problem 3:\nCLASS Solution  \n    FUNCTION sumDigitDifferences(nums)  \n        FUNCTION digit_difference(num1, num2)  \n            SET count TO zero  \n            FOR each pair of character d1 and character d2 FROM the characters of num1 AND the characters of num2 IN PARALLEL  \n                IF character d1 NOT EQUALS character d2 THEN  \n                    INCREMENT count BY one  \n                END IF  \n            END FOR  \n            RETURN count  \n        END FUNCTION  \n        SET total_sum TO zero  \n        SET n TO the LENGTH OF nums  \n        FOR index i FROM zero TO n MINUS one  \n            FOR index j FROM i PLUS one TO n MINUS one  \n                SET total_sum TO total_sum PLUS digit_difference(element at position i of nums, element at position j of nums)  \n            END FOR  \n        END FOR  \n        RETURN total_sum  \n    END FUNCTION  \n\nPseudocode for Problem 4:\nCLASS Solution\n    FUNCTION maxOperations(pixels)\n        FUNCTION rec(a, b, target, cache)\n            IF NOT (a < b) THEN\n                RETURN 0 + 0\n            END IF\n            SET key TO (a, b, target)\n            IF key IN cache THEN\n                RETURN cache[key]\n            END IF\n            SET current_max TO 0 * 1\n            IF (pixels[a] + pixels[(a + 1) MOD LENGTH(pixels)]) = target THEN\n                SET tmp1 TO 1 + rec(a + 2, b, target, cache)\n                IF tmp1 > current_max THEN\n                    SET current_max TO tmp1\n                END IF\n            END IF\n            IF (pixels[b] + pixels[b - 1]) = target THEN\n                SET tmp2 TO 1 + rec(a, b - 2, target, cache)\n                IF tmp2 > current_max THEN\n\nModified Pseudocode for Problem 4:\nCLASS Solution  \n    FUNCTION maxOperations(nums)  \n        FUNCTION dfs(l, r, prev_score, memo)  \n            IF l GREATER THAN OR EQUAL TO r  \n                RETURN zero  \n            END IF  \n            IF tuple of l r prev_score EXISTS IN memo  \n                RETURN value at tuple of l r prev_score IN memo  \n            END IF  \n            SET max_ops TO zero  \n            IF element at position l of nums PLUS element at position l PLUS one of nums EQUALS prev_score  \n                SET max_ops TO maximum of max_ops AND one PLUS dfs of l PLUS two r prev_score memo  \n            END IF  \n            IF element at position r of nums PLUS element at position r MINUS one of nums EQUALS prev_score  \n                SET max_ops TO maximum of max_ops AND one PLUS dfs of l r MINUS two prev_score memo  \n            END IF  \n            IF element at position l of nums PLUS element at position r of nums EQUALS prev_score  \n                SET max_ops TO maximum of max_ops AND one PLUS dfs of l PLUS one r MINUS one prev_score memo  \n            END IF  \n            SET tuple of l r prev_score IN memo TO max_ops  \n\nPseudocode for Problem 5:\nFUNCTION is_prime(k)  \n  DEFINE FUNCTION divmod_equal(a, b, c)  \n    RETURN (a % b) = c  \n  END FUNCTION  \n\n  IF NOT (k > 1) THEN RETURN FALSE END IF  \n  IF k <= (1 + 2) THEN RETURN TRUE END IF  \n\n  IF (divmod_equal(k, 2, 0) OR divmod_equal(k, 3, 0)) THEN  \n    RETURN FALSE  \n  END IF  \n\n  DEFINE FUNCTION loop_check(idx)  \n    IF NOT ((idx * idx) <= k) THEN RETURN TRUE END IF  \n\n    IF (divmod_equal(k, idx, 0) OR divmod_equal(k, idx + 2, 0)) THEN  \n      RETURN FALSE  \n    END IF  \n\n    RETURN loop_check(idx + (3 * 2))  \n\nModified Pseudocode for Problem 5:\nFUNCTION is_prime(n)  \n    IF n LESS THAN OR EQUAL TO one  \n        RETURN false  \n    END IF  \n    IF n LESS THAN OR EQUAL TO three  \n        RETURN true  \n    END IF  \n    IF n MODULO two EQUALS zero OR n MODULO three EQUALS zero  \n        RETURN false  \n    END IF  \n    SET i TO five  \n    WHILE i MULTIPLIED BY i LESS THAN OR EQUAL TO n  \n        IF n MODULO i EQUALS zero OR n MODULO i PLUS two EQUALS zero  \n            RETURN false  \n        END IF  \n        INCREMENT i BY six  \n    END WHILE  \n    RETURN true  \nEND FUNCTION  \n\n\nPseudocode for Problem 6:\nCLASS Solution\n    FUNCTION maxTotalReward(rewardValues)\n        DEFINE FUNCTION computeBitLength(x)\n            SET count TO 0\n            WHILE x > 0 DO\n                SET count TO count + 1\n                SET x TO x DIV 2\n            END WHILE\n            RETURN count\n        END FUNCTION\n\n        DEFINE FUNCTION sortList(lst)\n            IF LENGTH(lst) <= (1 + 0) THEN\n                RETURN lst\n            END IF\n            SET pivotIndex TO (LENGTH(lst) - 1) DIV 2\n            SET pivotValue TO lst[pivotIndex]\n            SET leftPartition TO []\n            SET rightPartition TO []\n            SET idx TO 0\n\nModified Pseudocode for Problem 6:\nCLASS Solution  \n    FUNCTION maxTotalReward(rewardValues)  \n        SET nums TO the SORTED SET OF elements IN rewardValues  \n        SET f TO one  \n        FOR each v IN nums  \n            SET f TO f OR the BITWISE AND of f AND the DIFFERENCE of the VALUE one SHIFTED LEFT BY v and one, SHIFTED LEFT BY v  \n        END FOR  \n        RETURN the BIT LENGTH OF f MINUS one  \n    END FUNCTION  \nEND CLASS\n\nPseudocode for Problem 7:\nCLASS Solution\n    FUNCTION maxUpgrades(count LIST OF INTEGER upgrade LIST OF INTEGER sell LIST OF INTEGER money LIST OF INTEGER) RETURNS LIST OF INTEGER\n        DECLARE results AS LIST OF INTEGER\n        ASSIGN results TO new empty list\n\n        DECLARE idx INTEGER\n        ASSIGN idx TO 0\n        WHILE idx <= (LENGTH(count) - (1 + 0))\n            DECLARE current_units INTEGER = count[idx]\n            DECLARE price_upgrade INTEGER = upgrade[idx]\n            DECLARE value_sell INTEGER = sell[idx]\n            DECLARE fund_initial INTEGER = money[idx]\n            DECLARE best_upgrade INTEGER = 0\n            DECLARE temp_fund INTEGER = fund_initial\n\n            PROCEDURE ExploreSell( sell_iter INTEGER )\n                IF NOT (sell_iter <= current_units) THEN RETURN END IF\n\n                DECLARE num_left INTEGER = current_units - sell_iter\n                DECLARE cash_from_sale INTEGER = sell_iter * value_sell\n\nModified Pseudocode for Problem 7:\nCLASS Solution  \n    FUNCTION maxUpgrades(count LIST OF INTEGER upgrade LIST OF INTEGER sell LIST OF INTEGER money LIST OF INTEGER) RETURNS LIST OF INTEGER  \n        SET answer TO empty list  \n        FOR index FROM zero TO the LENGTH OF count MINUS one  \n            SET num_servers TO element at position index of count  \n            SET upgrade_cost TO element at position index of upgrade  \n            SET sell_price TO element at position index of sell  \n            SET initial_money TO element at position index of money  \n            SET max_upgrades TO zero  \n            SET remaining_money TO initial_money  \n            FOR sell_count FROM zero TO num_servers  \n                SET remaining_servers TO num_servers MINUS sell_count  \n                SET money_from_selling TO sell_count MULTIPLIED BY sell_price  \n                SET total_money TO remaining_money PLUS money_from_selling  \n                SET possible_upgrades TO total_money DIVIDED BY upgrade_cost  \n                IF possible_upgrades GREATER THAN remaining_servers  \n                    SET possible_upgrades TO remaining_servers  \n                END IF  \n                IF possible_upgrades GREATER THAN max_upgrades  \n                    SET max_upgrades TO possible_upgrades  \n\nPseudocode for Problem 8:\nCLASS Solution\r\n  FUNCTION minimumArrayLength(nums)\r\n    DEFINE FUNCTION findMinValue(inputList)\r\n      SET idx TO 1\r\n      SET smallest TO inputList[0]\r\n      WHILE idx < ( (len(inputList) - 0) )\r\n        IF NOT (inputList[idx] >= smallest)\r\n          SET smallest TO inputList[idx]\r\n        END IF\r\n        SET idx TO idx + 1\r\n      END WHILE\r\n      RETURN smallest\r\n    END FUNCTION\r\n\r\n    DEFINE FUNCTION countOccurrences(inputList, targetVal)\r\n      SET acc TO 0\r\n      SET pos TO 0\r\n      REPEAT\r\n        IF pos >= len(inputList)\r\n          BREAK\r\n\nModified Pseudocode for Problem 8:\nCLASS Solution  \n    FUNCTION minimumArrayLength(nums)  \n        SET min_val TO the minimum element IN nums  \n        SET count_min_val TO the number of occurrences OF min_val IN nums  \n        IF count_min_val EQUALS one  \n            RETURN one  \n        END IF  \n        RETURN the quotient of count_min_val PLUS one DIVIDED BY two  \n    END FUNCTION  \nEND CLASS\nScore of -1*(BLEU Score) for ALL the problems: -0.06283693914366376"
}