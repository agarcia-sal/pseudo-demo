Given any pseudocode input, generate a fully rewritten version that meets all these criteria exactly:

1. Preserve full original semantics: the output must produce identical results, maintain all side effects, and replicate all logical behaviors and algorithmic steps of the input pseudocode with no additions or omissions.

2. Keep verbatim all externally visible interface elements intact and unaltered:  
 • Class names, method and function names, exact signatures (names, parameter names, order, types, return types if present).  
 • Class inheritance hierarchies, field/object layouts, and any externally observable contracts.  
 No renaming, removal, or restructuring of these exposed interfaces or their hierarchies is permitted.

3. Aggressively and comprehensively transform all internal implementation details not covered above, maximizing lexical, syntactic, and structural divergence by applying arbitrary combinations of the following (and anything logically equivalent):  
 • Replace all loops of any type with any other logically equivalent loop constructs or recursion, including but not limited to converting for ↔ while ↔ repeat-until loops ↔ tail-recursion.  
 • Replace every local, temporary, and parameter variable identifier with entirely fresh, semantically consistent but unrelated names, avoiding all hints or resemblance to original identifiers; parameter variables may be renamed internally only if external signatures remain unchanged.  
 • Rearrange, split, or merge statements and conditionals; reorder safe independent instructions; reorder or change data traversal strategies as long as final outcomes and side effects remain identical.  
 • Rewrite and refactor all expressions systematically using equivalence transformations (arithmetic and logical identities, De Morgan’s laws, distributive/associative transformations), expanding or compressing compound assignments, decomposing/recombining expressions, introducing or eliminating temporary expressions, expressing constants in arithmetic or defined form, and so forth.  
 • Transform control flow by inlining/extracting helper subroutines, reordering early returns versus deferred return assignments, deeply reshaping nesting and branching structure.  
 • Replace direct built-in or standard library calls with appropriate locally defined helper functions implementing the same behavior, or conversely substitute local helpers with equivalent built-in/standard calls.  
 • Vary all formatting dramatically and orthogonally: keyword casing, indentation style and level, line breaks, spacing, block delimiters, and general code organization stylistic choices.  
 • Change the style and naming of user-defined helpers internally, except those exposed in preserved interfaces.

4. Absolutely do not remove, add, simplify, optimize away, or abstract any conceptual steps, data structures, or algorithmic elements of the original pseudocode.

5. The output must be a single, self-contained pseudocode listing that stands alone and is complete.

6. The transformation must be fully universal and applicable to any pseudocode input regardless of problem domain or language style.

7. Output only the rewritten pseudocode—no explanations, comments, annotations, analysis, or supplementary content.

Emphasize maximal multilayered, orthogonal rewriting of all code elements internal to the preserved interfaces, prioritizing deep semantic equivalences and structural novelty, so that lexical similarity with the original is minimized except where interface identifiers are mandated unchanged.

Output exclusively the transformed pseudocode text.