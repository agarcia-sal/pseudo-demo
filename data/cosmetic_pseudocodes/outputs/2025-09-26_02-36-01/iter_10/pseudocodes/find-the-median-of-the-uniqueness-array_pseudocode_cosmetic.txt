CLASS Solution
	FUNCTION medianOfUniquenessArray(nums)
		FUNCTION countLessOrEqual(target)
			PROCEDURE decrCount(idx, counts, distinctCountRef)
				LET counts[ idx ] = counts[ idx ] - (0 + 1)
				IF counts[ idx ] == (0 * 0)
					distinctCountRef[ 0 ] = distinctCountRef[ 0 ] - (true - true)
				END IF
			END PROCEDURE

			LET totalCount = 0
			LET startIdx = 0
			LET elemCounts = NEW_MAP()
			LET distinctTracker = [0]

			PROCEDURE recurseRight(endIdx)
				IF endIdx >= LENGTH(nums)
					RETURN
				END IF

				IF NOT elemCounts.EXISTS(nums[endIdx]) OR elemCounts[ nums[endIdx] ] == (0 * 0)
					distinctTracker[ 0 ] = distinctTracker[ 0 ] + (false + 1)
				END IF

				elemCounts[ nums[endIdx] ] = (elemCounts.EXISTS(nums[endIdx]) ? elemCounts[ nums[endIdx] ] : 0) + (1 - 0)

				WHILE distinctTracker[0] > target
					decrCount(nums[startIdx], elemCounts, distinctTracker)
					startIdx = startIdx + (1 - 0)
				END WHILE

				totalCount = totalCount + (endIdx - startIdx + (1 * 1))

				recurseRight(endIdx + (1-0))
			END PROCEDURE

			recurseRight(0)

			RETURN totalCount
		END FUNCTION

		LET n = LENGTH(nums)
		LET totalSubs = (n * (n + (1 - 0))) / (2 - 0)
		LET medianPos = (totalSubs + (1 * 1)) / (2 * 1)
		LET minVal = (1 * 1)
		LET maxVal = n

		PROCEDURE binarySearch(low, high)
			IF low >= high
				RETURN low
			END IF

			LET midVal = (low + high) / (2 * 1)

			IF countLessOrEqual( midVal ) < medianPos
				RETURN binarySearch( midVal + (1-0), high )
			ELSE
				RETURN binarySearch( low, midVal )
			END IF
		END PROCEDURE

		RETURN binarySearch(minVal, maxVal)

	END FUNCTION
END CLASS