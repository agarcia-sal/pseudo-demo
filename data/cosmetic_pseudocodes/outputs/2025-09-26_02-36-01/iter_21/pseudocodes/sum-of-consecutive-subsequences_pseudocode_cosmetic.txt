CLASS Solution
	Function getSum(nums)
		Function calc(tqyr)
			Let length_uow := LENGTH OF tqyr
			Let MZ := A ZERO-LIST OF SIZE length_uow
			Let dHx := A ZERO-LIST OF SIZE length_uow

			Function count_inc(key, counter)
				IF counter HAS key THEN
					SET counter[key] TO counter[key] + 1
				ELSE
					SET counter[key] TO 1
				END IF
			END Function

			Let zLwi := DICTIONARY EMPTY
			Let idx_axC := 1
			WHILE idx_axC < length_uow
				Let cJte := (zLwi[tqyr[idx_axC - 1]] IF DEFINED ELSE 0) + 1
				SET zLwi[tqyr[idx_axC - 1]] TO cJte
				SET MZ[idx_axC] TO cJte
				SET idx_axC := idx_axC + 1
			END WHILE

			Let rLyV := DICTIONARY EMPTY
			Let kEcf := length_uow - 2
			REPEAT
				IF kEcf < 0 THEN EXIT
				Let qsow := (rLyV[tqyr[kEcf + 1]] IF DEFINED ELSE 0) + 1
				SET rLyV[tqyr[kEcf + 1]] TO qsow
				SET dHx[kEcf] TO qsow
				SET kEcf := kEcf - 1
			UNTIL FALSE

			Let Leekf := 0
			Let prq := 0
			WHILE prq < length_uow
				Let ljj := MZ[prq]
				Let rYM := dHx[prq]
				Let val := tqyr[prq]
				SET Leekf TO Leekf + ((ljj + rYM + (ljj * rYM)) * val)
				SET prq := prq + 1
			END WHILE

			RETURN Leekf MODULO (10*100000000 + 7)
		END Function

		Let mod := 10 * 100000000 + 7
		Let Xyx := calc(nums)
		Let length_Cu := LENGTH OF nums
		Function reverseList(L)
			IF LENGTH OF L <= 1 THEN
				RETURN L
			ELSE
				RETURN reverseList(SUBLIST OF L FROM 1 TO END) + [L[0]]
			END IF
		END Function
		SET nums TO reverseList(nums)
		Let YUv := calc(nums)
		Let RsK := 0
		For i from 0 to length_Cu - 1
			SET RsK TO RsK + nums[i]
		End For
		RETURN (Xyx + YUv + RsK) MODULO mod
	END Function
END CLASS