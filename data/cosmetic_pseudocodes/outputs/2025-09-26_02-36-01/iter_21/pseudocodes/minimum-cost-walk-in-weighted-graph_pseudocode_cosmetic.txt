CLASS UnionFind
    FUNCTION __init__(self, n)
  SET self_parent TO empty list
  SET self_rank TO empty list
  SET z TO 0
  REPEAT
    APPEND z TO self_parent
    APPEND (1 + 0) TO self_rank
    SET z TO (z + 1)
  UNTIL z GREATER THAN (n - 1)
  SET self.parent TO self_parent
  SET self.rank TO self_rank
    END FUNCTION

    FUNCTION find(self, a)
  FUNCTION innerFind(x)
    IF NOT (self.parent[x] EQUALS x) THEN
      SET temp TO innerFind(self.parent[x])
      SET self.parent[x] TO temp
      RETURN temp
    ELSE
      RETURN self.parent[x]
    END IF
  END FUNCTION
  RETURN innerFind(a)
    END FUNCTION

    FUNCTION union(self, b, c)
  SET root1 TO self.find(b)
  SET root2 TO self.find(c)
  IF NOT (root1 EQUALS root2) THEN
    IF (self.rank[root1] GREATER THAN self.rank[root2]) THEN
      SET self.parent[root2] TO root1
    ELSE
      IF (self.rank[root1] LESS THAN self.rank[root2]) THEN
        SET self.parent[root1] TO root2
      ELSE
        SET self.parent[root2] TO root1
        SET self.rank[root1] TO (self.rank[root1] + (1 * 1))
      END IF
    END IF
  END IF
    END FUNCTION
END CLASS

CLASS Solution
    FUNCTION minimumCost(self, p, q, r)
  SET uf TO UnionFind(p)

  FUNCTION powEquivalent()
    RETURN ( (1 << 32) - 1 )
  END FUNCTION

  SET compData TO empty list
  SET y TO 0
  WHILE y LESS THAN p DO
    APPEND powEquivalent() TO compData
    SET y TO (y + 1) 
  END WHILE

  FUNCTION updateComp(arr)
    SET idx TO uf.find(arr[0])
    SET compData[idx] TO (compData[idx] BITWISE_AND arr[2])
  END FUNCTION

  SET indexVar TO 0
  WHILE indexVar LESS THAN LENGTH_OF(r) DO
    CALL updateComp WITH r[indexVar]
    uf.union(r[indexVar][0], r[indexVar][1])
    SET indexVar TO (indexVar + 1)
  END WHILE

  SET compCosts TO empty dictionary

  SET iterVar TO 0
  REPEAT
    IF iterVar GREATER THAN (p - 1) THEN BREAK
    END IF
    SET rootNode TO uf.find(iterVar)
    IF NOT (rootNode IN compCosts) THEN
      SET compCosts[rootNode] TO compData[rootNode]
    END IF
    SET iterVar TO (iterVar + 1)
  UNTIL FALSE

  SET ansList TO empty list

  FUNCTION processQueries(sVal, tVal)
    IF sVal EQUALS tVal THEN
      APPEND 0 TO ansList
    ELSE
      SET rootS TO uf.find(sVal)
      SET rootT TO uf.find(tVal)
      IF rootS EQUALS rootT THEN
        APPEND compCosts[rootS] TO ansList
      ELSE
        APPEND -1 TO ansList
      END IF
    END IF
  END FUNCTION

  SET j TO 0
  WHILE j LESS THAN LENGTH_OF(q) DO
    CALL processQueries(q[j][0], q[j][1])
    SET j TO (j + 1)
  END WHILE

  RETURN ansList
    END FUNCTION
END CLASS