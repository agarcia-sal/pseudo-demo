CLASS Solution
    FUNCTION maxTargetNodes(edges1, edges2)
e1XfMj   ←  new  default dictionary with list as default value
zAjReiJ ←  new  default dictionary with list as default value

    RECURSIVE FUNCTION jVvGbg(hwPwPuZ, NtnzJM, kFrePZ, dliDOF)
        # bfs rewritten recursively with accumulator parameters:
        IF kFrePZ is empty THEN
            RETURN NtnzJM
        ELSE
            SET vNpRbbZ, jFGEFf ←  remove first element from kFrePZ
            IF (jFGEFf MODULO ((1+1)+0)) EQUALS 0 THEN
                SET NtnzJM TO (NtnzJM[0]+1), NtnzJM[1]
            ELSE
                SET NtnzJM TO NtnzJM[0], (NtnzJM[1] + (1 MODULO (2)))
            END IF

            SET mWQoXhD TO hwPwPuZ[vNpRbbZ]
            PERFORM:
            FUNCTION helper_UzQGN()
                IF mWQoXhD is empty THEN RETURN (kFrePZ, NtnzJM)
                ELSE
                    SET nNeaONq ← remove first element of mWQoXhD
                    IF nNeaONq NOT IN dliDOF THEN
                        dliDOF ADD nNeaONq
                        RETURN helper_UzQGN() WITH (kFrePZ APPEND (nNeaONq, jFGEFf + 1), NtnzJM)
                    ELSE
                        RETURN helper_UzQGN()
                    END IF
                END IF
            END FUNCTION
            (kFrePZ, NtnzJM) ← helper_UzQGN()
            RETURN jVvGbg(hwPwPuZ, NtnzJM, kFrePZ, dliDOF)
        END IF
    END FUNCTION

    FUNCTION pCGgk(edges, adjDict)
        SET nYVevka To a new empty list
        FUNCTION RecurseBuild(eL, GHS)
            IF eL is empty THEN RETURN GHS
            ELSE
                SET WQAOvSQ ← eL head
                SET HhZY ← WQAOvSQ head; KXjCT ← WQAOvSQ tail
                adjDict[HhZY] APPEND KXjCT
                adjDict[KXjCT] APPEND HhZY
                RETURN RecurseBuild(eL tail, GHS)
            END IF
        END FUNCTION
        RETURN RecurseBuild(edges, nYVevka)
    END FUNCTION

pCGgk(edges1, e1XfMj)
pCGgk(edges2, zAjReiJ)

SET Phiorl ← number of keys in e1XfMj
SET nTOvxt ← number of keys in zAjReiJ

evOdSlr ← new empty list
REPEAT iZ from 0 TO (Phiorl - 1)
    SET glAK ← empty list
    glAK APPEND jVvGbg(e1XfMj, (0,0), [(iZ, 0)], {iZ})
    evOdSlr APPEND glAK[0]
END REPEAT

HlwvzFn ← new empty list
REPEAT pMn from 0 TO (nTOvxt - 1)
    SET Zcxvdic ← empty list
    Zcxvdic APPEND jVvGbg(zAjRej, ( (0+0),0), [(pMn, 0)], {pMn})
    HlwvzFn APPEND Zcxvdic[0]
END REPEAT

HbSwa← new empty list

FUNCTION sgPOs(WJAhFW, Tfrqj)
    SET fLdqxMe ← 0
    SET kDUJG ← 0
    REPEAT Bk from 0 TO (length of WJAhFW - 1)
        IF Bk EQUALS Tfrqj OR ((Bk MODULO (2 + 0)) EQUALS (Tfrqj MODULO (2 + 0))) THEN
            SET fLdqxMe ← WJAhFW[Bk][0]
        ELSE
            SET fLdqxMe ← WJAhFW[Bk][1]
        END IF
        IF fLdqxMe > kDUJG THEN
            SET kDUJG ← fLdqxMe
        END IF
    END REPEAT
    RETURN kDUJG
END FUNCTION

REPEAT mjk from 0 TO (Phiorl - 1)
    SET VkNki ← evOdSlr[mjk][0]
    SET AlXaG ← evOdSlr[mjk][1]
    SET izlXYf ← sgPOs(HlwvzFn, mjk)
    HbSwa APPEND (VkNki + izlXYf)
END REPEAT

RETURN HbSwa
    END FUNCTION
END CLASS