```
CLASS Solution
   FUNCTION minimumSum(grid)
Xo = []
Zp = 0
repeat
   if not (Zp < (length(grid) + (0 - 1))) then
      exit repeat
   end if
   Yq = 0
   repeat
      if not (Yq < (length(grid[Zp]) + (0 - 1))) then
         exit repeat
      end if
      Aq = (grid[Zp] = 1)
      Bq = (grid[Zp][Yq] = 1)
      if (Aq and Bq) then
         Xo = Xo + [(Zp, Yq)]
      end if
      Yq = Yq + 1
   end repeat
   Zp = Zp + 1
until false

   FUNCTION rect_area(points)
Ui = 0
repeat
   if (length(points) = 0) then
      Ui = 1
      exit repeat
   end if
exit repeat
until false
if (Ui = 1) then
   RETURN 0
end if
hm = 999999999999999
km = -999999999999999
gn = 999999999999999
jm = -999999999999999

forC = 0
while (forC < length(points))
   hm = if hm < points[forC][1] then hm else points[forC][1]
   gn = if gn < points[forC][2] then gn else points[forC][2]
   km = if km > points[forC][1] then km else points[forC][1]
   jm = if jm > points[forC][2] then jm else points[forC][2]
   forC = forC + 1
end while

Zt = (km + (0 - hm)) + 1
Vb = (jm + (0 - gn)) + 1
RETURN (Zt * Vb)
   END FUNCTION

Vy = 1.0e300
Tm = length(Xo)

MApc = 1
repeat
   if not (MApc < Tm) then
      exit repeat
   end if
   Tk = MApc + 1
   repeat
      if not (Tk < Tm) then
         exit repeat
      end if
      Ae = Tk + 1
      repeat
         if not (Ae < (Tm + 1)) then
            exit repeat
         end if

         FUNCTION helpers_combs(Arr, Sz) 
            RESlist = []
            Fs = length(Arr)
            FUNCTION rc(indx, curr)
               if length(curr) = Sz then
                  RESlist = RESlist + [curr]
               else if indx < Fs then
                  rc(indx + 1, curr + [Arr[indx]])
                  rc(indx + 1, curr)
               end if
            END FUNCTION
            rc(0, [])
            RETURN RESlist
         END FUNCTION

         Hf = helpers_combs(Xo, MApc)
         repeat
            if length(Hf) = 0 then
               exit repeat
            end if
            Qv = Hf[0]
            Hf = Hf[1:length(Hf)]
            
            FUNCTION set_from_list(Lst)
               St = {}
               for Xx in Lst do
                  St[Xx] = true
               end for
               RETURN St
            END FUNCTION
            
            set_ones = set_from_list(Xo)
            set_comb1 = set_from_list(Qv)
            rem_after_1 = {}
            for item in set_ones do
               if not (set_comb1[item] = true) then
                  rem_after_1[item] = true
               end if
            end for

            S = []
            for k in rem_after_1 do
               S = S + [k]
            end for
            
            Gk = helpers_combs(S, (Tk - MApc))
            repeat
               if length(Gk) = 0 then
                  exit repeat
               end if
               Yl = Gk[0]
               Gk = Gk[1:length(Gk)]
               
               set_comb2 = set_from_list(Yl)
               comb3_map = {}
               for Xm in rem_after_1 do
                  if not (set_comb2[Xm] = true) then
                     comb3_map[Xm] = true
                  end if
               end for

               comb3_list = []
               for Ym in comb3_map do
                  comb3_list = comb3_list + [Ym]
               end for

               area1v = rect_area(Qv)
               area2v = rect_area(Yl)
               area3v = rect_area(comb3_list)

               condA = (area1v > 0)
               condB = (area2v > 0)
               condC = (area3v > 0)
               cond_full = (condA and condB) and condC

               if cond_full then
                  totalA = (area1v + area2v) + area3v
                  if (totalA < Vy) then
                     Vy = totalA
                  end if
               end if
            until false
         until false
         Ae = Ae + 1
      until false
      Tk = Tk + 1
   until false
   MApc = MApc + 1
until false

RETURN Vy
   END FUNCTION
END CLASS
```