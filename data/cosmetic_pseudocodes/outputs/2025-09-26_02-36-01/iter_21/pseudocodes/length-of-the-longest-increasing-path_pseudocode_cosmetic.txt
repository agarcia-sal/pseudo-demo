CLASS Solution
    FUNCTION maxPathLength(coordinates, k)
 let zulu ← (coordinates at k) at 0
 let bravo ← (coordinates at k) at 1
 var delta ← [ ]
 var tango ← 0
 REPEAT
loop1:
    IF tango GREATER OR EQUAL LENGTH OF coordinates THEN
        EXIT loop1
    END IF
    LET omega ← (coordinates at tango) at 0
    LET alpha ← (coordinates at tango) at 1
    IF (omega LESS THAN zulu) AND (alpha LESS THAN bravo)
        APPEND (omega, alpha) TO delta
    END IF
    tango ← tango + 1
 UNTIL false
 var echo ← [ ]
 var foxtrot ← 0
 WHILE foxtrot NOT EQUAL LENGTH OF coordinates DO
     LET india ← (coordinates at foxtrot) at 0
     LET kilo ← (coordinates at foxtrot) at 1
     IF NOT (india LESS OR EQUAL zulu) AND NOT (kilo LESS OR EQUAL bravo)
         APPEND (india, kilo) TO echo
     END IF
     foxtrot ← foxtrot + 1
 END WHILE
 LET result ← 1 + self CALLS _lengthOfLIS WITH delta + self CALLS _lengthOfLIS WITH echo
 RETURN result
    END FUNCTION

    FUNCTION _lengthOfLIS(coordinates)
 PROCEDURE sortByFirstAscSecondDesc(arr)
   var i ← 0
   WHILE i LESS LENGTH OF arr - 1 DO
    var j ← i + 1
    REPEAT
      IF (arr at i) at 0 GREATER (arr at j) at 0
         SWAP arr at i WITH arr at j
      ELSE IF ((arr at i) at 0 EQUAL (arr at j) at 0) AND ((arr at i) at 1 LESS (arr at j) at 1)
         SWAP arr at i WITH arr at j
      END IF
      j ← j + 1
      IF j GREATER OR EQUAL LENGTH OF arr THEN
          BREAK
      END IF
    UNTIL false
    i ← i + 1
   END WHILE
 END PROCEDURE

 LET queue ← coordinates
 sortByFirstAscSecondDesc(queue)

 PROCEDURE bisectLeft(arr, val)
  var low ← 0
  var high ← LENGTH OF arr
  WHILE low NOT EQUAL high DO
   LET mid ← (low + high) / 2
   IF (arr at mid) GREATER OR EQUAL val
      high ← mid
   ELSE
      low ← mid + 1
   END IF
  END WHILE
  RETURN low
 END PROCEDURE

 var pipe ← [ ]
 var cursor ← 0
 REPEAT
loop2:
   IF cursor EQUAL LENGTH OF queue THEN
       EXIT loop2
   END IF
   LET _, y ← queue at cursor
   IF LENGTH OF pipe EQUAL 0 OR y GREATER (pipe at (LENGTH OF pipe MINUS 1))
     APPEND y TO pipe
   ELSE
    LET pos ← bisectLeft(pipe, y)
    SET (pipe at pos) TO y
   END IF
   cursor ← cursor + 1
 UNTIL false

 RETURN LENGTH OF pipe
    END FUNCTION
END CLASS