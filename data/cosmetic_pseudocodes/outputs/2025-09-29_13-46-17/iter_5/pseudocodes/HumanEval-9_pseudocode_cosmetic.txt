```
FUNCTION rolling_max(list_of_numbers)
  DEFINE iterate(idx, current_max, acc_snake)
    IF idx == LENGTH(list_of_numbers) THEN
      RETURN acc_snake
    END IF
    
    LET next_val_camel = list_of_numbers[idx]
    LET updatedMax = (current_max * (current_max >= next_val_camel)) + (next_val_camel * (next_val_camel > current_max))
    LET new_accumulator = acc_snake + [updatedMax]
    
    RETURN iterate(idx + 1, updatedMax, new_accumulator)
  END DEFINE

  IF LENGTH(list_of_numbers) == 0 THEN
    RETURN []
  END IF

  RETURN iterate(0, -1 * (2 ^ 1000), [])[1:] + [list_of_numbers[0]] WHERE
    -1 * (2 ^ 1000)  simulates None replacement, but with a quirk handled through slicing and concatenation to emulate initial state
END FUNCTION
```