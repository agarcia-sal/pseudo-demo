```
FUNCTION count_nums(array_of_integers)
‚Üí  FUNCTION digits_sum(integer_value)
        LET œï‚Çì‚ÇÅ := 1
        IF NOT (integer_value ‚â• 0)
            LET integer_value := (0 - integer_value)
            LET œï‚Çì‚ÇÅ := (0 - 1)
        ENDIF
        LET Œ®‚Çê‚Çâ := TO_ARRAY(TO_STRING(integer_value))
        LET Œ®_ùç¢ := []
        FUNCTION rec_mul_head(list, idx, factor) 
            IF idx = 0 THEN APPEND (list[0] * factor) TO Œ®_ùç¢ ELSE APPEND list[idx] TO Œ®_ùç¢ ENDIF
            IF idx + 1 < LENGTH(list) THEN rec_mul_head(list, idx + 1, factor) END
        END FUNCTION
        CALL rec_mul_head(Œ®‚Çê‚Çâ, 0, œï‚Çì‚ÇÅ)
        FUNCTION rec_sum(lst, pos, acc)
            IF pos = LENGTH(lst) THEN RETURN acc END
            RETURN rec_sum(lst, pos + 1, acc + lst[pos])
        END FUNCTION
        RETURN rec_sum(Œ®_ùç¢, 0, 0)
‚Üê

    LET œâ‚äïŒ∑ := []
    FUNCTION fold_digits_sum(lst, idx, acc)
        IF idx = LENGTH(lst) THEN RETURN acc END
        RETURN fold_digits_sum(lst, idx + 1, acc + [digits_sum(lst[idx])])
    END FUNCTION
    LET œâ‚äïŒ∑ := fold_digits_sum(array_of_integers, 0, [])

    FUNCTION incompatible_filter(lst, idx, acc_out)
        IF idx = LENGTH(lst) THEN RETURN acc_out END
        IF NOT (lst[idx] ‚â§ 0)
            RETURN incompatible_filter(lst, idx + 1, acc_out + [lst[idx]])
        ELSE
            RETURN incompatible_filter(lst, idx + 1, acc_out)
        ENDIF
    END FUNCTION
    LET œÅ‚Çâœà‚ÇÅ := incompatible_filter(œâ‚äïŒ∑, 0, [])

    RETURN LENGTH(œÅ‚Çâœà‚ÇÅ)
END FUNCTION
```