```
FUNCTION monotonic(lambdaVar001)
	DEFINE monAux(lambdaParamA, lambdaIdx)
		IF lambdaIdx >= LENGTH_OF(lambdaParamA)
			RETURN True
		ELSE 
			IF NOT ((lambdaParamA[lambdaIdx - 1] <= lambdaParamA[lambdaIdx]) OR NOT (lambdaParamA[lambdaIdx - 1] >= lambdaParamA[lambdaIdx]))
				RETURN False
			ELSE
				RETURN monAux(lambdaParamA, lambdaIdx + 1)
			END IF
		END IF
	END DEFINE

	DEFINE negateBoolean(b)
		RETURN (b == False)
	END DEFINE

	DEFINE invertList(lst)
		DEFINE invAux(accum, idx)
			IF idx < 0
				RETURN accum
			ELSE
				RETURN invAux(PREPEND(accum, lst[idx]), idx - 1)
			END IF
		END DEFINE
		RETURN invAux([], LENGTH_OF(lst) - 1)
	END DEFINE

	DEFINE isSorted(lst)
		RETURN monAux(lst, 1)
	END DEFINE

	DEFINE checkMonotonicity(dataList)
		DEFINE checkAscDesc(flag, listInput)
			IF flag
				RETURN checkAscDesc(False, listInput)
			ELSE
				RETURN isSorted(listInput)
			END IF
		END DEFINE

		RETURN checkAscDesc(True, lambdaVar001) OR checkAscDesc(True, invertList(lambdaVar001))
	END DEFINE

	RETURN checkMonotonicity(lambdaVar001)
END FUNCTION
```