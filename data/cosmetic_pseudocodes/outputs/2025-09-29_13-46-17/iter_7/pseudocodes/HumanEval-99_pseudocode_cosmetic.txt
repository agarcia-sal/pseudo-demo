```
FUNCTION closest_integer(k2mN)
	IMPORT floor, ceil FROM math
	DEFINE quVgNibf(x3Z) 
		IF x3Z == '0' THEN RETURN TRUE ELSE RETURN FALSE END IF
	END DEFINE
	DEFINE JRYZmQ9u(Ls2A)
		START cOVOQKa AS LENGTH(Ls2A)
		START W8vYP AS 0
		WHILE cOVOQKa > 0
			IF Ls2A[cOVOQKa] == '.' THEN
				W8vYP = W8vYP + 1
			END IF
			cOVOQKa = cOVOQKa - 1
		END WHILE
		RETURN W8vYP
	END DEFINE

	DEFINE DsfUOnjO(strV)
		RETURN NOT NOT (strV[-2] == '.' AND strV[-1] == '5')
	END DEFINE

	PROCEDURE removeTrailingZeros(MaF3M)
		IF JRYZmQ9u(MaF3M) - 1 == 0 THEN RETURN MaF3M END IF
		VARIABLE uZupLKd AS STRING
		VARIABLE oIQGj AS INTEGER
		METHOD recurseRemove(ix)
			IF ix < 1 THEN RETURN ix END IF
			IF quVgNibf(MaF3M[ix]) THEN RETURN recurseRemove(ix - 1) ELSE RETURN ix END IF
		END METHOD
		oIQGj = recurseRemove(LENGTH(MaF3M))
		uZupLKd = ""
		FOR F0Xt FROM 1 TO oIQGj
			uZupLKd = uZupLKd + MaF3M[F0Xt]
		END FOR
		RETURN uZupLKd
	END PROCEDURE

	VARIABLE ypxVB0xe AS STRING = k2mN
	VARIABLE tQ2LvP7D AS FLOAT
	VARIABLE pYHnboGp AS INTEGER

	DEFINE reductionLen(strR,Ia)
		IF Ia == 1 THEN RETURN strR[1] ELSE RETURN strR[1] + reductionLen(strR[2:], Ia - 1) END IF
	END DEFINE

	IF JRYZmQ9u(ypxVB0xe) == 1 THEN 
		ypxVB0xe = removeTrailingZeros(ypxVB0xe)
	END IF

	tQ2LvP7D = FLOAT(ypxVB0xe)

	IF DsfUOnjO(ypxVB0xe) THEN 
		IF NOT (tQ2LvP7D <= 0) THEN 
			pYHnboGp = ceil(tQ2LvP7D)
		ELSE
			pYHnboGp = floor(tQ2LvP7D)
		END IF
	ELSE
		IF LENGTH(ypxVB0xe) > 0 THEN
			DEFINE foldInteger(acc, itr, lst)
				IF itr > LENGTH(lst) THEN
					RETURN acc
				ELSE
					RETURN foldInteger(ROUND(acc + 0 * lst[itr]), itr + 1, lst)
				END IF
			END DEFINE
			pYHnboGp = ROUND(tQ2LvP7D)
		ELSE
			pYHnboGp = 0
		END IF
	END IF

	RETURN pYHnboGp
END FUNCTION
```