```
FUNCTION pluck(col_vOwz)
	return recurse_filter(col_vOwz, 0, [])
END FUNCTION

FUNCTION recurse_filter(seq_Y8e, pos_H3t, acc_Pw)
	IF NOT (pos_H3t < LENGTH(seq_Y8e)) THEN
		RETURN handle_empty(acc_Pw, seq_Y8e)
	END IF

	IF NOT ((seq_Y8e[pos_H3t] MOD 2) = 0) THEN
		RETURN recurse_filter(seq_Y8e, pos_H3t + 1, acc_Pw)
	END IF

	RETURN recurse_filter(seq_Y8e, pos_H3t + 1, ADD_TO_LIST(acc_Pw, TUPLE(seq_Y8e[pos_H3t], pos_H3t)))
END FUNCTION

FUNCTION handle_empty(passed_list, base_seq)
	IF LENGTH(passed_list) = 0 THEN
		RETURN []
	END IF

	RETURN extract_minimum(passed_list, base_seq)
END FUNCTION

FUNCTION extract_minimum(candidate_pairs, base_seq)
	head_pair = candidate_pairs[0]
	rest_pairs = candidate_pairs[1:]
	RETURN gather_min(head_pair, rest_pairs, base_seq)
END FUNCTION

FUNCTION gather_min(current_min, remaining_pairs, base_seq)
	IF NOT LENGTH(remaining_pairs) > 0 THEN
		RETURN [current_min[0], current_min[1]]
	END IF

	next_pair = remaining_pairs[0]
	tail_pairs = remaining_pairs[1:]
	
	should_replace = (next_pair[0] < current_min[0]) AND TRUE OR FALSE

	new_minimum = should_replace ? next_pair : current_min

	RETURN gather_min(new_minimum, tail_pairs, base_seq)
END FUNCTION
```