{
  "prompt": "Given an input pseudocode snippet, produce a fully restructured and reformulated version that is functionally and semantically identical, preserves all function and class names exactly as in the original, and maintains the original class and object hierarchy without alteration. Your rewritten pseudocode must be as syntactically, structurally, and stylistically divergent as possible by exhaustively applying aggressive, safe transformations such as (but not limited to):\n\n- Recast all control flow constructs into fundamentally different paradigms (e.g., replace loops with recursion, recursion with loops, if-else chains with pattern matching or guards, switch-case with nested conditionals, short-circuit logic with explicit branching).\n- Completely rename every local variable and parameter throughout the pseudocode using a coherent but non-overlapping naming scheme unrelated to the original names and varying styles (e.g., switch between camelCase, snake_case, UPPERCASE, thematic or mnemonic variables), while keeping all function and class identifiers intact.\n- Reorder independent statements, reorder conditions in compound logical expressions, and invert or rewrite conditional logic using equivalent transformations (including De Morgan\u2019s laws) to alter control flow appearance without changing behavior.\n- Inline functions into callers or conversely extract repeated code blocks into helper functions, varying between nesting and flattening to diversify structural presentation.\n- Convert between equivalent data iteration and access methods (e.g., from indexed loops to iterator-based, for-each constructs, recursive traversals; switch array accesses to dict/map keys where possible or vice versa).\n- Alter arithmetic and logical expressions via identities, expansion, factorization, distribution, or normalization that preserve exact results.\n- Transform usage of literal constants into equivalent expressions, symbolic constants, or computed values.\n- Revise how return statements and value propagation are handled (e.g., early returns vs accumulators, mutable state vs immutable assignments).\n- Heavily vary formatting and layout including indentation, spacing, line breaks, block delimiters, and comments removal to maximize visual dissimilarity.\n- Re-express accumulative computations using folds, reduces, explicit loops, or recursion interchangeably.\n- Restructure control flow to flatten nested constructs where possible or introduce nesting to obfuscate syntactic similarity.\n- Use alternative, valid pseudocode idioms or syntax for the same operations holding semantic invariance.\n- Pursue any additional safe syntactic, stylistic, or structural rewritings to maximize divergence while preserving all original runtime logic and outputs.\n\n**Absolutely do not modify function or class names, their inheritance or containment relationships, or add/remove any functional behavior or outputs.**  \n**Do not provide any explanations, comments, or extra text\u2014output only the complete rewritten pseudocode.**",
  "response": "Given an input pseudocode snippet, produce a fully restructured and reformulated version that is functionally and semantically identical, preserves all function and class names exactly as in the original, and maintains the original class and object hierarchy without alteration. Your rewritten pseudocode must be as syntactically, structurally, and stylistically divergent as possible by exhaustively applying aggressive, safe transformations such as (but not limited to):\n\n- Recast all control flow constructs into fundamentally different paradigms (e.g., replace loops with recursion, recursion with loops, if-else chains with pattern matching or guards, switch-case with nested conditionals, short-circuit logic with explicit branching).\n- Completely rename every local variable and parameter throughout the pseudocode using a coherent but non-overlapping naming scheme unrelated to the original names and varying styles (e.g., switch between camelCase, snake_case, UPPERCASE, thematic or mnemonic variables), while keeping all function and class identifiers intact.\n- Reorder independent statements, reorder conditions in compound logical expressions, and invert or rewrite conditional logic using equivalent transformations (including De Morgan\u2019s laws) to alter control flow appearance without changing behavior.\n- Inline functions into callers or conversely extract repeated code blocks into helper functions, varying between nesting and flattening to diversify structural presentation.\n- Convert between equivalent data iteration and access methods (e.g., from indexed loops to iterator-based, for-each constructs, recursive traversals; switch array accesses to dict/map keys where possible or vice versa).\n- Alter arithmetic and logical expressions via identities, expansion, factorization, distribution, or normalization that preserve exact results.\n- Transform usage of literal constants into equivalent expressions, symbolic constants, or computed values.\n- Revise how return statements and value propagation are handled (e.g., early returns vs accumulators, mutable state vs immutable assignments).\n- Heavily vary formatting and layout including indentation, spacing, line breaks, block delimiters, and comments removal to maximize visual dissimilarity.\n- Re-express accumulative computations using folds, reduces, explicit loops, or recursion interchangeably.\n- Restructure control flow to flatten nested constructs where possible or introduce nesting to obfuscate syntactic similarity.\n- Use alternative, valid pseudocode idioms or syntax for the same operations holding semantic invariance.\n- Pursue any additional safe syntactic, stylistic, or structural rewritings to maximize divergence while preserving all original runtime logic and outputs.\n\n**Absolutely do not modify function or class names, their inheritance or containment relationships, or add/remove any functional behavior or outputs.**  \n**Do not provide any explanations, comments, or extra text\u2014output only the complete rewritten pseudocode.**",
  "score": -0.16776771422109932,
  "feedback": "The following are 20 lines of original pseudocode of a random subset of the problems along with their modified pseudocodes.\n\nPseudocode for Problem 1:\n```\nFUNCTION poly(list_of_coefficients, point)\n    FUNCTION power_accumulate(counter, acc)\n        IF counter EQUALS LENGTH(list_of_coefficients)\n            RETURN acc\n        END IF\n        LET coeff_element BE list_of_coefficients[counter]\n        LET updated_acc BE acc + coeff_element * point^counter\n        RETURN power_accumulate(counter + 1, updated_acc)\n    END FUNCTION\n    RETURN power_accumulate(0, 0)\nEND FUNCTION\n\nFUNCTION find_zero(list_of_coefficients)\n    LET alpha = -1.0\n    LET omega = 1.0\n\n    FUNCTION expand_bounds(a, b)\n        LET eval_a = poly(list_of_coefficients, a)\n        LET eval_b = poly(list_of_coefficients, b)\n\nModified Pseudocode for Problem 1:\n```\nFUNCTION poly(list_of_coefficients, point)\n    RETURN SUM OF each coefficient MULTIPLIED BY point RAISED TO THE POWER OF coefficient_index FOR EACH coefficient AND coefficient_index IN ENUMERATE(list_of_coefficients)\nEND FUNCTION\n\nFUNCTION find_zero(list_of_coefficients)\n    SET begin TO -1.0\n    SET end TO 1.0\n    WHILE poly(list_of_coefficients, begin) MULTIPLIED BY poly(list_of_coefficients, end) IS GREATER THAN 0\n        MULTIPLY begin BY 2.0\n        MULTIPLY end BY 2.0\n    END WHILE\n    WHILE end MINUS begin IS GREATER THAN 1e-10\n        SET center TO (begin PLUS end) DIVIDED BY 2.0\n        IF poly(list_of_coefficients, center) MULTIPLIED BY poly(list_of_coefficients, begin) IS GREATER THAN 0\n            SET begin TO center\n        ELSE\n            SET end TO center\n        END IF\n    END WHILE\n\nPseudocode for Problem 2:\n```\nFUNCTION prime_fib(integer_n)\n    IMPORT mathematical_functions_module\n\n    FUNCTION is_prime(integer_p)\n        IF integer_p < 2 THEN\n            RETURN False\n        ENDIF\n\n        FUNCTION check_divisor(current_divisor, limit)\n            IF current_divisor > limit THEN\n                RETURN True\n            ELSE\n                IF integer_p MOD current_divisor = 0 THEN\n                    RETURN False\n                ELSE\n                    RETURN check_divisor(current_divisor + 1, limit)\n                ENDIF\n            ENDIF\n        END FUNCTION\n\nModified Pseudocode for Problem 2:\n```\nFUNCTION prime_fib(integer_n)\n    IMPORT mathematical_functions_module\n\n    FUNCTION is_prime(integer_p)\n        IF integer_p LESS THAN 2\n            RETURN False\n        FOR each integer_k FROM 2 TO MINIMUM OF (INTEGER PART OF SQUARE ROOT OF integer_p PLUS 1) AND (integer_p MINUS 1)\n            IF integer_p MODULO integer_k EQUALS 0\n                RETURN False\n        RETURN True\n    END FUNCTION\n\n    SET list_fibonacci TO LIST CONTAINING 0 AND 1\n\n    WHILE TRUE\n        APPEND TO list_fibonacci THE SUM OF THE LAST ELEMENT OF list_fibonacci AND THE SECOND TO LAST ELEMENT OF list_fibonacci\n        IF is_prime(LAST ELEMENT OF list_fibonacci)\n            DECREMENT integer_n BY 1\n        IF integer_n EQUALS 0\n\nPseudocode for Problem 3:\n```\nFUNCTION get_row(two_dimensional_list, target_integer)\n    PROCEDURE collect_positions(idx_outer, acc_positions)\n        IF idx_outer >= LENGTH(two_dimensional_list) THEN\n            RETURN acc_positions\n        ELSE\n            PROCEDURE collect_inner(idx_inner, current_row, acc_inner)\n                IF idx_inner >= LENGTH(current_row) THEN\n                    RETURN acc_inner\n                ELSE\n                    IF current_row[idx_inner] = target_integer THEN\n                        RETURN collect_inner(idx_inner + 1, current_row, acc_inner + [(idx_outer, idx_inner)])\n                    ELSE\n                        RETURN collect_inner(idx_inner + 1, current_row, acc_inner)\n            SET updated_positions TO collect_inner(0, two_dimensional_list[idx_outer], acc_positions)\n            RETURN collect_positions(idx_outer + 1, updated_positions)\n\n    SET found_coords TO collect_positions(0, [])\n    \n    FUNCTION desc_by_second(a, b)\n\nModified Pseudocode for Problem 3:\n```\nFUNCTION get_row(two_dimensional_list, target_integer)\n    SET coordinates TO EMPTY LIST\n    FOR each row_index FROM 0 TO LENGTH OF two_dimensional_list MINUS 1\n        FOR each column_index FROM 0 TO LENGTH OF two_dimensional_list AT row_index MINUS 1\n            IF two_dimensional_list AT row_index AT column_index EQUALS target_integer\n                APPEND TUPLE(row_index, column_index) TO coordinates\n    SET coordinates TO coordinates SORTED BY SECOND ELEMENT IN DESCENDING ORDER\n    SET coordinates TO coordinates SORTED BY FIRST ELEMENT IN ASCENDING ORDER\n    RETURN coordinates\nEND FUNCTION\n```\n\nPseudocode for Problem 4:\n```\nFUNCTION rounded_avg(integer_n, integer_m)\n    DEFINE compute_sum(curr_val, end_val, acc_total)\n        IF curr_val GREATER THAN end_val\n            RETURN acc_total\n        ELSE\n            RETURN compute_sum(curr_val + 1, end_val, acc_total + curr_val)\n    END DEFINE\n\n    IF NOT (integer_m >= integer_n)\n        RETURN -1\n\n    LET total_sum = compute_sum(integer_n, integer_m, 0)\n    LET count_elements = (integer_m - integer_n) + 1\n    LET raw_average = total_sum / count_elements\n    LET nearest_whole = (raw_average + 0.5) - ((raw_average + 0.5) MOD 1)\n    \n    DEFINE integer_to_binary(num)\n        LET bits_list = []\n        \n\nModified Pseudocode for Problem 4:\n```\nFUNCTION rounded_avg(integer_n, integer_m)\n    IF integer_m LESS THAN integer_n\n        RETURN -1\n    SET summation TO 0\n    FOR each integer_i FROM integer_n TO integer_m INCLUSIVE\n        INCREMENT summation BY integer_i\n    SET average_value TO summation DIVIDED BY (integer_m MINUS integer_n PLUS 1)\n    SET rounded_average TO ROUND average_value TO NEAREST INTEGER\n    RETURN BINARY REPRESENTATION OF rounded_average\nEND FUNCTION\n```\n\nPseudocode for Problem 5:\n```\nFUNCTION change_base(number_value, base_val)\n    FUNCTION helper(accumulated_str, current_num)\n        IF current_num EQUALS 0 THEN\n            RETURN accumulated_str\n        ELSE\n            RETURN helper(TO_STRING(current_num MOD base_val) + accumulated_str, current_num DIV base_val)\n    END FUNCTION\n    INITIALIZED_STRING = \"\"\n    IF number_value NOT EQUAL 0 THEN\n        RETURN helper(INITIALIZED_STRING, number_value)\n    ELSE\n        RETURN INITIALIZED_STRING\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 5:\n```\nFUNCTION change_base(integer_x, integer_base)\n    SET string_result TO empty string\n    WHILE integer_x GREATER THAN 0\n        SET string_result TO STRING OF (integer_x MODULO integer_base) CONCATENATED WITH string_result\n        SET integer_x TO integer_x DIVIDED BY integer_base USING INTEGER DIVISION\n    RETURN string_result\nEND FUNCTION\n```\n\nPseudocode for Problem 6:\n```\nFUNCTION add(alphaBeta, gammaDelta)\n  VAR SUM_RESULT = 0\n  SUM_RESULT = alphaBeta\n  SUM_RESULT = SUM_RESULT + gammaDelta\n  RETURN SUM_RESULT\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 6:\n```\nFUNCTION add(x, y)\n    RETURN x PLUS y\nEND FUNCTION\n```\n\nPseudocode for Problem 7:\n```\nFUNCTION words_string(input_string)\n    DEFINE recurse_replace_comma(index, acc)\n        IF index >= LENGTH(input_string)\n            RETURN acc\n        ELSE\n            LET cur_char = input_string[index]\n            LET updated_acc = acc + (IF cur_char != ',' THEN cur_char ELSE ' ')\n            RETURN recurse_replace_comma(index + 1, updated_acc)\n        END IF\n    END DEFINE\n\n    IF LENGTH(input_string) = 0 THEN\n        RETURN []\n    END IF\n\n    LET replaced_str = recurse_replace_comma(0, \"\")\n    LET word_array = SPLIT(replaced_str, \" \")\n    RETURN word_array\nEND FUNCTION\n\nModified Pseudocode for Problem 7:\n```\nFUNCTION words_string(input_string)\n    IF input_string IS EMPTY\n        RETURN empty list\n    END IF\n\n    SET character_list TO empty list\n\n    FOR each character IN input_string\n        IF character IS EQUAL TO comma\n            APPEND space TO character_list\n        ELSE\n            APPEND character TO character_list\n        END IF\n    END FOR\n\n    SET joined_string TO concatenation of all characters in character_list\n    RETURN list of words obtained by splitting joined_string on whitespace\nEND FUNCTION\n```\n\nPseudocode for Problem 8:\n```\nFUNCTION intersperse(sequence_values, sep_marker) \n    DEFINE recursive_build(index_pos, acc_array)\n        IF index_pos = LENGTH(sequence_values) THEN\n            RETURN acc_array\n        ELSE IF index_pos = LENGTH(sequence_values) - 1 THEN\n            RETURN acc_array + [sequence_values[index_pos]]\n        ELSE\n            RETURN recursive_build(index_pos + 1, acc_array + [sequence_values[index_pos], sep_marker])\n        END IF\n    END DEFINE\n\n    IF LENGTH(sequence_values) = 0 THEN\n        RETURN []\n    ELSE\n        RETURN recursive_build(0, [])\n    END IF\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 8:\n```\nFUNCTION intersperse(list_of_numbers, delimiter)\n    IF list_of_numbers IS EMPTY\n        RETURN EMPTY LIST\n    END IF\n\n    SET result_list TO EMPTY LIST\n\n    FOR each number IN list_of_numbers EXCLUDING LAST ELEMENT\n        APPEND number TO result_list\n        APPEND delimiter TO result_list\n    END FOR\n\n    APPEND LAST ELEMENT OF list_of_numbers TO result_list\n\n    RETURN result_list\nEND FUNCTION\n```\nScore of -1*(BLEU Score) for ALL the problems: -0.16776771422109932",
  "iter": 4
}