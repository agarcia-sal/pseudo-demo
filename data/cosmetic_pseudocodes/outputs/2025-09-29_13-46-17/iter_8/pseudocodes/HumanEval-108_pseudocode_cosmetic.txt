```
FUNCTION count_nums(array_of_integers)
  FUNCTION digits_sum(integer_value)
    FUNCTION eval_sign(num,acc)
      IF NOT (num < 0) THEN
        RETURN (num, acc)
      END IF
      RETURN (-num, acc * -1)
    END FUNCTION

    (zreWq, Bglpt) = eval_sign(integer_value, 1)
    FUNCTION to_digits_str_pos(x)
      IF x = 0 THEN
        RETURN []
      END IF
      RETURN to_digits_str_pos(x / 10) + [x MOD 10]
    END FUNCTION
    ythNm = to_digits_str_pos(zreWq)
    IF ythNm = [] THEN RETURN 0 END IF
    kXzLA = [Bglpt * ythNm[0]] + ythNm[1..]
    
    FUNCTION fold_sum(lst, acc)
      IF lst = [] THEN RETURN acc END IF
      HEAD = lst[0]
      TAIL = lst[1..]
      RETURN fold_sum(TAIL, acc + HEAD)
    END FUNCTION
    
    RETURN fold_sum(kXzLA, 0)
  END FUNCTION

  FUNCTION recurse_map(lst, acc)
    IF lst = [] THEN RETURN acc END IF
    H = lst[0]
    T = lst[1..]
    RETURN recurse_map(T, acc + [digits_sum(H)])
  END FUNCTION

  wiOjz = recurse_map(array_of_integers, [])
  
  FUNCTION filter_positive(xs)
    FUNCTION inner_filter(xs, res)
      IF xs = [] THEN RETURN res END IF
      IF xs[0] > 0 THEN
        RETURN inner_filter(xs[1..], res + [xs[0]])
      ELSE
        RETURN inner_filter(xs[1..], res)
      END IF
    END FUNCTION
    RETURN inner_filter(xs, [])
  END FUNCTION

  dXVNq = filter_positive(wiOjz)

  RETURN 0 + LENGTH(dXVNq)
END FUNCTION
```