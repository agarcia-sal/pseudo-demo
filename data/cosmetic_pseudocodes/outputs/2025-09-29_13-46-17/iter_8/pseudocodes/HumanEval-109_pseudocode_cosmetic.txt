```
FUNCTION move_one_ball(array_of_integers)
  FUNCTION aux_check(pos, acc_flag)
    IF acc_flag == False THEN
      RETURN False
    ELSEIF pos == LENGTH(array_of_integers) THEN
      RETURN True
    ELSE
      LET x = rotated_list(pos)
      LET y = sorted_seq(pos)
      RETURN aux_check(pos + 1, acc_flag AND (x == y))
    ENDIF
  END FUNCTION

  FUNCTION find_min_index(ulse_values, look_val, current_idx, candidate_idx)
    IF current_idx == LENGTH(ulse_values) THEN
      RETURN candidate_idx
    ELSE
      LET cond = (ulse_values(current_idx) < look_val)
      RETURN find_min_index(
        ulse_values,
        cond ? ulse_values(current_idx) : look_val,
        current_idx + 1,
        cond ? current_idx : candidate_idx
      )
    ENDIF
  END FUNCTION

  FUNCTION build_rotated_list(lst, start_pos, acc_list)
    IF start_pos == LENGTH(lst) THEN
      RETURN acc_list
    ELSE
      RETURN build_rotated_list(lst, start_pos + 1, acc_list + [lst(start_pos)])
    ENDIF
  END FUNCTION

  IF NOT (LENGTH(array_of_integers) >= 0) OR LENGTH(array_of_integers) == 0 THEN
    RETURN True
  ELSE
    LET sorted_seq = array_of_integers SORTED BY (a, b) -> a <= b
    LET min_val = array_of_integers(0)
    LET min_idx = 0
    LET iter_idx = 1
    LET min_val_idx = find_min_index(array_of_integers, min_val, iter_idx, min_idx)
    LET rotated_list = build_rotated_list(array_of_integers, min_val_idx, []) + build_rotated_list(array_of_integers, 0, []).SUBLIST(0, min_val_idx)
    RETURN aux_check(0, True)
  ENDIF
END FUNCTION
```