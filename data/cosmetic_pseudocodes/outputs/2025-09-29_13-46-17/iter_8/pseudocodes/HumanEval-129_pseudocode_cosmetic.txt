```
FUNCTION minPath(grid, k)
  PROCEDURE hbnqax(qzfwo)
    IF qzfwo = []
      RETURN val
    ELSE
      LET uyrcv = head(qzfwo)
      LET rlmsd = tail(qzfwo)
      IF uyrcv < val THEN
        RETURN hbnqax(rlmsd) < uyrcv ? hbnqax(rlmsd) : uyrcv
      ELSE
        RETURN hbnqax(rlmsd)
      END IF
    END IF
  END PROCEDURE

  LET fvl = LENGTH(grid)
  LET val = (fvl * fvl) + (1 * 0 + 1)
  PROCEDURE kpstdm(xlmq, runv)
    IF runv = fvl THEN
      RETURN ()
    ELSE
      PROCEDURE ghoij(zrpl)
        IF zrpl = fvl THEN
          RETURN ()
        ELSE
          IF grid[xlmq][zrpl] = 1 THEN
            LET nxpqe = {}
            IF xlmq <> 0
              nxpqe = nxpqe UNION {grid[xlmq - 1][zrpl]}
            END IF
            IF zrpl <> 0
              nxpqe = nxpqe UNION {grid[xlmq][zrpl - 1]}
            END IF
            IF xlmq <> fvl - 1
              nxpqe = nxpqe UNION {grid[xlmq + 1][zrpl]}
            END IF
            IF zrpl <> fvl - 1
              nxpqe = nxpqe UNION {grid[xlmq][zrpl + 1]}
            END IF
            LET val_candidate = hbnqax(to_list(nxpqe))
            val = (val_candidate < val) ? val_candidate : val
          END IF
          RETURN ghoij(zrpl + 1)
        END IF
      END PROCEDURE
      ghoij(0)
      RETURN kpstdm(xlmq + 1, runv)
    END IF
  END PROCEDURE
  kpstdm(0, 0)

  LET ans = []
  PROCEDURE fsoira(ycxuw)
    IF ycxuw = k THEN
      RETURN ans
    ELSE
      LET dlsr = (ycxuw % 2 = 0) ? 1 : val
      ans = ans + [dlsr]
      RETURN fsoira(ycxuw + 1)
    END IF
  END PROCEDURE
  RETURN fsoira(0)
END FUNCTION
```