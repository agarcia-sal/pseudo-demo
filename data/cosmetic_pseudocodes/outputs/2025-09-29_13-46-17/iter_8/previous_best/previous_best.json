{
  "prompt": "Given an input pseudocode snippet, produce a fully semantically equivalent rewriting that **maximizes syntactic and structural divergence** from the original, subject to the strict preservation of:\n\n- All original **function and class names**, exactly as given,\n- Original **function signatures** (names, parameters, and their order),\n- Original **class declarations, inheritance, and nesting hierarchies** intact (no additions, removals, or rearrangements).\n\nYour output must be **only** the complete transformed pseudocode, with no explanations or annotations.\n\nTo achieve maximal dissimilarity, apply **deep, multi-layered, and mutually reinforcing transformations** at all levels\u2014control flow, data structures, variable naming, expression form, and code organization\u2014combining techniques such as but not limited to:\n\n1. **Control Flow Reconfiguration:**\n\n   - Replace all iterative constructs with equivalent recursive or tail-recursive forms, or vice versa.\n   - Substitute conditional branches combining if-else chains, guard clauses, early returns, pattern matching, dispatch tables, logical short-circuiting, or polymorphic dispatch.\n   - Desugar or reconstruct switch/case-style logic into nested ifs, and vice versa.\n   - Expand or contract loops via loop unrolling or loop fusion; convert loops to explicit enumerations or iterator protocols.\n\n2. **Identifier Transformations:**\n\n   - Systematically rename every **local variable**, **parameter**, and **temporary identifier** in every scope to fresh, semantically opaque and distinct identifiers using varied and inconsistent naming schemes (e.g., random alphanumeric strings, thematic codes, mixed casing styles, non-meaningful substitutions) with **no semantic overlap or hints** linking to original identifiers.\n   - Reuse original **function and class names exactly**, without change.\n\n3. **Data Structure Replacements:**\n\n   - Substitute arrays, lists, sets, queues, maps, or other collections for one another wherever semantics permit.\n   - Convert index-based iteration to iterator protocols or recursive traversal.\n   - Represent accumulations alternately via different paradigms: folds, reduces, explicit accumulators, or recursion.\n\n4. **Expression and Logic Rewrites:**\n\n   - Apply Boolean algebra extensively: De Morgan\u2019s laws, contraposition, distributivity, absorption, and associative rearrangements to reorder and rewrite all logical expressions.\n   - Expand, factor, or otherwise algebraically transform all arithmetic expressions; replace exponentiation with iterative or recursive multiplication; convert numeric constants to computations or symbolic expressions.\n   - Re-express conditionals and boolean checks using boolean arithmetic, conditional expressions (ternaries), or pattern matching.\n\n5. **Structural Rearrangements:**\n\n   - Inline functions or extract repeated code into newly introduced helper functions with varied and different nesting depths and naming.\n   - Reorganize, reorder, or regroup statements to alter block structure, balancing between flattening and deepening nested scopes.\n   - Alter order of independent statements, respecting semantic dependencies strictly.\n\n6. **State and Flow Management:**\n\n   - Replace mutable variables with chains of immutable reassignment or pure functional transformations.\n   - Alternate between early returns, accumulators, control flags, or result objects to propagate outputs.\n   - Alter return statement structures and result aggregation logic to drastically transform control flow readability without changing behavior.\n\n7. **Formatting and Syntax Variation:**\n\n   - Aggressively vary indentation style (spaces vs. tabs), indent widths, line breaking, statement grouping.\n   - Change delimiters, punctuation, and whitespace patterns respecting pseudocode grammar to maximize textual divergence.\n   - Remove all comments, docstrings, or annotations.\n\n8. **Idiomatic Construct Substitution:**\n\n   - Replace idiomatic pseudocode features with alternative, valid constructs (e.g., substitute explicit loops with pattern matching or higher-order function analogues, or express logic using boolean short-circuit arithmetic).\n   - Employ explicit enumerations, accumulator passing styles, or monadic-style chaining wherever valid.\n\n**Combine and nest these transformations extensively and recursively throughout the pseudocode rather than applying them superficially.**\n\n**Do not**:\n\n- Change any function or class names or signatures.\n- Alter any external behavior, outputs, side effects, or data semantics.\n- Add or remove any functions, classes, or methods.\n- Introduce any new libraries or language constructs beyond valid pseudocode norms.\n\n**Only output the full transformed pseudocode. Nothing else.**",
  "response": "Given an input pseudocode snippet, produce a fully semantically equivalent rewriting that **maximizes syntactic and structural divergence** from the original, subject to the strict preservation of:\n\n- All original **function and class names**, exactly as given,\n- Original **function signatures** (names, parameters, and their order),\n- Original **class declarations, inheritance, and nesting hierarchies** intact (no additions, removals, or rearrangements).\n\nYour output must be **only** the complete transformed pseudocode, with no explanations or annotations.\n\nTo achieve maximal dissimilarity, apply **deep, multi-layered, and mutually reinforcing transformations** at all levels\u2014control flow, data structures, variable naming, expression form, and code organization\u2014combining techniques such as but not limited to:\n\n1. **Control Flow Reconfiguration:**\n\n   - Replace all iterative constructs with equivalent recursive or tail-recursive forms, or vice versa.\n   - Substitute conditional branches combining if-else chains, guard clauses, early returns, pattern matching, dispatch tables, logical short-circuiting, or polymorphic dispatch.\n   - Desugar or reconstruct switch/case-style logic into nested ifs, and vice versa.\n   - Expand or contract loops via loop unrolling or loop fusion; convert loops to explicit enumerations or iterator protocols.\n\n2. **Identifier Transformations:**\n\n   - Systematically rename every **local variable**, **parameter**, and **temporary identifier** in every scope to fresh, semantically opaque and distinct identifiers using varied and inconsistent naming schemes (e.g., random alphanumeric strings, thematic codes, mixed casing styles, non-meaningful substitutions) with **no semantic overlap or hints** linking to original identifiers.\n   - Reuse original **function and class names exactly**, without change.\n\n3. **Data Structure Replacements:**\n\n   - Substitute arrays, lists, sets, queues, maps, or other collections for one another wherever semantics permit.\n   - Convert index-based iteration to iterator protocols or recursive traversal.\n   - Represent accumulations alternately via different paradigms: folds, reduces, explicit accumulators, or recursion.\n\n4. **Expression and Logic Rewrites:**\n\n   - Apply Boolean algebra extensively: De Morgan\u2019s laws, contraposition, distributivity, absorption, and associative rearrangements to reorder and rewrite all logical expressions.\n   - Expand, factor, or otherwise algebraically transform all arithmetic expressions; replace exponentiation with iterative or recursive multiplication; convert numeric constants to computations or symbolic expressions.\n   - Re-express conditionals and boolean checks using boolean arithmetic, conditional expressions (ternaries), or pattern matching.\n\n5. **Structural Rearrangements:**\n\n   - Inline functions or extract repeated code into newly introduced helper functions with varied and different nesting depths and naming.\n   - Reorganize, reorder, or regroup statements to alter block structure, balancing between flattening and deepening nested scopes.\n   - Alter order of independent statements, respecting semantic dependencies strictly.\n\n6. **State and Flow Management:**\n\n   - Replace mutable variables with chains of immutable reassignment or pure functional transformations.\n   - Alternate between early returns, accumulators, control flags, or result objects to propagate outputs.\n   - Alter return statement structures and result aggregation logic to drastically transform control flow readability without changing behavior.\n\n7. **Formatting and Syntax Variation:**\n\n   - Aggressively vary indentation style (spaces vs. tabs), indent widths, line breaking, statement grouping.\n   - Change delimiters, punctuation, and whitespace patterns respecting pseudocode grammar to maximize textual divergence.\n   - Remove all comments, docstrings, or annotations.\n\n8. **Idiomatic Construct Substitution:**\n\n   - Replace idiomatic pseudocode features with alternative, valid constructs (e.g., substitute explicit loops with pattern matching or higher-order function analogues, or express logic using boolean short-circuit arithmetic).\n   - Employ explicit enumerations, accumulator passing styles, or monadic-style chaining wherever valid.\n\n**Combine and nest these transformations extensively and recursively throughout the pseudocode rather than applying them superficially.**\n\n**Do not**:\n\n- Change any function or class names or signatures.\n- Alter any external behavior, outputs, side effects, or data semantics.\n- Add or remove any functions, classes, or methods.\n- Introduce any new libraries or language constructs beyond valid pseudocode norms.\n\n**Only output the full transformed pseudocode. Nothing else.**",
  "score": -0.11539449248193093,
  "feedback": "The following are 20 lines of original pseudocode of a random subset of the problems along with their modified pseudocodes.\n\nPseudocode for Problem 1:\n```\nFUNCTION numerical_letter_grade(xY2zQ9)\n\tT4v = new map()\n\t\n\tDEFINE KLa(x):\n\t\tIF x = 4.0 THEN RETURN \"A+\" END IF\n\t\tIF (NOT (x <= 3.7)) THEN RETURN \"A\" END IF\n\t\tIF (3.3 < x) THEN RETURN \"A-\" END IF\n\t\tIF (x > 3.0) THEN RETURN \"B+\" END IF\n\t\tIF (2.7 < x) THEN RETURN \"B\" END IF\n\t\tIF ((x > 2.3)) THEN RETURN \"B-\" END IF\n\t\tIF (2.0 < x) THEN RETURN \"C+\" END IF\n\t\tIF (x > 1.7) THEN RETURN \"C\" END IF\n\t\tIF (1.3 < x) THEN RETURN \"C-\" END IF\n\t\tIF (x > 1.0) THEN RETURN \"D+\" END IF\n\t\tIF (0.7 < x) THEN RETURN \"D\" END IF\n\t\tIF (0.0 < x) THEN RETURN \"D-\" END IF\n\t\tRETURN \"E\"\n\t\n\tDEFINE HbR(Lmj, DI7):\n\nModified Pseudocode for Problem 1:\n```\nFUNCTION numerical_letter_grade(list_of_grades)\n    SET letter_grade_list TO empty list\n    FOR each grade_point_average IN list_of_grades\n        IF grade_point_average EQUALS 4.0\n            APPEND \"A+\" TO letter_grade_list\n        ELSE IF grade_point_average GREATER THAN 3.7\n            APPEND \"A\" TO letter_grade_list\n        ELSE IF grade_point_average GREATER THAN 3.3\n            APPEND \"A-\" TO letter_grade_list\n        ELSE IF grade_point_average GREATER THAN 3.0\n            APPEND \"B+\" TO letter_grade_list\n        ELSE IF grade_point_average GREATER THAN 2.7\n            APPEND \"B\" TO letter_grade_list\n        ELSE IF grade_point_average GREATER THAN 2.3\n            APPEND \"B-\" TO letter_grade_list\n        ELSE IF grade_point_average GREATER THAN 2.0\n            APPEND \"C+\" TO letter_grade_list\n        ELSE IF grade_point_average GREATER THAN 1.7\n            APPEND \"C\" TO letter_grade_list\n\nPseudocode for Problem 2:\n```\nFUNCTION incr_list(y72h9)\n\tDEFINE kDf(*C) = IF (NOT (0 = #*C)) THEN (#*C * 0 + 1) ELSE 0\n\tDEFINE xLq7 = []\n\tDEFINE HTm4 = 0\n\tDEFINE FUNCTION RBpQ(Ut)\n\t\tIF (Ut < len(y72h9)) THEN\n\t\t\tDO xLq7.APPEND(y72h9[Ut] + kDf([1]))\n\t\t\tRETURN RBpQ(Ut + kDf([]))\n\t\tEND IF\n\t\tRETURN NIL\n\tEND FUNCTION\n\tRBpQ(0)\n\tRETURN xLq7\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 2:\n```\nFUNCTION incr_list(list_of_elements)\n    RETURN new_list WHERE each element IS element PLUS 1 FOR each element IN list_of_elements\nEND FUNCTION\n```\n\nPseudocode for Problem 3:\n```\nFUNCTION sort_even(scrqv)\n\trecur fgxoc(ulpzv, mzlut, xijseh, qwfzok) =\n\t\tIF ulpzv >= mzlut THEN xijseh\n\t\tELSE recur(ulpzv + 2, mzlut, (qwfzok(xijseh, ulpzv)), qwfzok)\n\tfgz := fgxoc(0, LEN(scrqv), [], (l, i) -> l + [scrqv[i]])\n\twtrriy := fgxoc(1, LEN(scrqv), [], (v, j) -> v + [scrqv[j]])\n\tkyplvc := (function(ptswv)\n\t\tlcbijn(sw, irzjx)\n\t\t\tIF NOT (LEN(sw) > 0 AND LEN(irzjx) > 0) THEN []\n\t\t\tELSE [sw[0]] + [irzjx[0]] + lcbijn(sw[1:], irzjx[1:])\n\t\tRETURN lcbijn(ptswv[0], ptswv[1])\n\tend)([SORTED(fgz), wtrriy])\n\tRET qdcz =(function(zxvpqr)\n\t\tIF (LEN(fgz) <= LEN(wtrriy)) THEN zxvpqr\n\t\tELSE zxvpqr + [fgz[ -1]]\n\tend)(kyplvc)\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 3:\n```\nFUNCTION sort_even(list_of_elements)\n    SET even_indexed_elements TO list_of_elements AT EVERY SECOND ELEMENT STARTING FROM INDEX ZERO\n    SET odd_indexed_elements TO list_of_elements AT EVERY SECOND ELEMENT STARTING FROM INDEX ONE\n    SORT even_indexed_elements IN NON-DECREASING ORDER\n    SET answer_list TO EMPTY LIST\n    FOR each pair_of_elements IN ZIP OF even_indexed_elements AND odd_indexed_elements\n        EXTEND answer_list BY ELEMENTS OF pair_of_elements IN ORDER\n    IF LENGTH OF even_indexed_elements IS GREATER THAN LENGTH OF odd_indexed_elements\n        APPEND LAST ELEMENT OF even_indexed_elements TO answer_list\n    RETURN answer_list\nEND FUNCTION\n```\n\nPseudocode for Problem 4:\n```\nFUNCTION flip_case(a1B2C3)\n\tDEFINE FUNCTION x9Z(oO0)\n\t\tIF (NOT (oO0 >= 'a' AND oO0 <= 'z')) AND NOT (oO0 >= 'A' AND oO0 <= 'Z') THEN \n\t\t\tRETURN oO0 \n\t\tELSE \n\t\t\tRETURN IF oO0 >= 'a' AND oO0 <= 'z' THEN CHAR(ASCII(oO0) - (('a' - 'A'))) ELSE CHAR(ASCII(oO0) + (('a' - 'A'))) \n\t\tEND IF\n\tEND FUNCTION\n\tDEFINE FUNCTION Vmq(lW5, Jf4)\n\t\tIF Jf4 = 0 THEN\n\t\t\tRETURN []\n\t\tELSE\n\t\t\tLET W91 = Vmq(lW5, Jf4 - 1)\n\t\t\tRETURN W91 + [x9Z(lW5[Jf4 - 1])]\n\t\tEND IF\n\tEND FUNCTION\n\tRETURN Vmq(a1B2C3, LENGTH(a1B2C3))\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 4:\n```\nFUNCTION flip_case(input_string)\n    RETURN input_string WITH EACH CHARACTER converted TO OPPOSITE CASE\nEND FUNCTION\n```\n\nPseudocode for Problem 5:\n```\nFUNCTION is_prime(prZxN)\n\treturn (function OXP(pURE)\n\t\tif pURE < (1 + 1) then\n\t\t\treturn false\n\t\telse\n\t\t\tfunction g612(HprG, ARNV)\n\t\t\t\treturn (ARNV > (pURE - (1 + 1))) or ((pURE mod HprG) <> 0 and g612(HprG + 1, ARNV))\n\t\t\tend function\n\t\t\treturn g612((1 + 1), true)\n\t\tend if\n\tend)(prZxN)\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 5:\n```\nFUNCTION is_prime(number)\n    IF number LESS THAN 2\n        RETURN False\n    END IF\n    FOR each divisor FROM 2 TO number MINUS 2\n        IF number MODULO divisor EQUALS 0\n            RETURN False\n        END IF\n    END FOR\n    RETURN True\nEND FUNCTION\n```\n\nPseudocode for Problem 6:\n```\nFUNCTION all_prefixes(pByzCw)\n\ttabMvs \u2190 []\n\tRETURN (FUNCTION MhREz(qhVRj, GtUOJ)\n\t\tIF NOT (qhVRj \u2264 0)\n\t\t\tRETURN (FUNCTION IVrBk(vguvTy, RatJF)\n\t\t\t\tIF RatJF < 0\n\t\t\t\t\tRETURN vguvTy\n\t\t\t\tELSE\n\t\t\t\t\tLET ZeSkF \u2190 vguvTy + [SUBSTRING(pByzCw, 0, RatJF + 1)]\n\t\t\t\t\tRETURN IVrBk(ZeSkF, RatJF - 1)\n\t\t\t\tEND IF\n\t\t\t)([], qhVRj - 1)\n\t\tELSE\n\t\t\tRETURN []\n\t\tEND IF\n\t)(LENGTH(pByzCw))\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 6:\n```\nFUNCTION all_prefixes(input_string)\n    SET result_list TO empty list\n    FOR each index FROM 0 TO LENGTH OF input_string MINUS 1\n        APPEND SUBSTRING OF input_string FROM START TO index PLUS 1 TO result_list\n    RETURN result_list\nEND FUNCTION\n```\n\nPseudocode for Problem 7:\n```\nFUNCTION string_sequence(integer_n)\n\tTAG48J = 0\n\tSL5mP = Queue()\n\tDEFINE kRVbY2(k1BX) \n\t\tRETURN STR(k1BX)\n\tEND DEFINE\n\tFUNCTION EmFq_T()\n\t\tIF NOT (TAG48J <= integer_n) THEN\n\t\t\tRETURN SL5mP\n\t\tELSE\n\t\t\tAPPEND TO SL5mP kRVbY2(TAG48J)\n\t\t\tTAG48J = TAG48J + 1\n\t\t\tRETURN EmFq_T()\n\t\tEND IF\n\tEND FUNCTION\n\tZ_9w = EmFq_T()\n\tRETURN REDUCE(LAMBDA(x,y): x + \" \" + y, CONVERT_TO_LIST(Z_9w), \"\")\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 7:\n```\nFUNCTION string_sequence(integer_n)\n    RETURN JOIN WITH SINGLE SPACE THE LIST CREATED BY CONVERTING EACH NUMBER TO STRING FOR EACH NUMBER IN RANGE FROM 0 TO integer_n INCLUSIVE\nEND FUNCTION\n```\n\nPseudocode for Problem 8:\n```\nFUNCTION sum_product(wq9Zv)\n\treturn Qx6([], 0, 1)\n\t\tfunction Qx6(fG2o, Cmt0, sLr)\n\t\t\tif NOT (fG2o <> wq9Zv) then\n\t\t\t\treturn (Cmt0, sLr)\n\t\t\telse\n\t\t\t\tLET _b1XP = prc(Fz5B(fG2o))\n\t\t\t\tLET _hVtm = Cmt0 + _b1XP\n\t\t\t\tLET _LuCK = sLr * _b1XP\n\t\t\t\treturn Qx6(TsLAB(fG2o), _hVtm, _LuCK)\n\t\t\tend if\n\t\tend function\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 8:\n```\nFUNCTION sum_product(list_of_integers)\n    SET sum_value TO 0\n    SET product_value TO 1\n    FOR each integer IN list_of_integers\n        INCREMENT sum_value BY integer\n        MULTIPLY product_value BY integer\n    RETURN tuple(sum_value, product_value)\nEND FUNCTION\n```\nScore of -1*(BLEU Score) for ALL the problems: -0.11539449248193093",
  "iter": 7
}