{
  "prompt": "Given the original pseudocode as input, produce a transformed version that preserves all original semantics, functionality, and exact function and class names, along with the original class and object hierarchy unchanged. Your rewritten pseudocode must be as syntactically and stylistically different as possible, employing any combination of the following transformations comprehensively and aggressively:\n\n- Convert all control flow structures to fundamentally different equivalents (e.g., replace all loops with recursion or vice versa; substitute conditionals with guard clauses or pattern matching where applicable)\n- Systematically rename **all** local variables and parameters using a consistent but different naming convention (e.g., change `snake_case` to `camelCase` or vice versa, or use thematic naming unrelated to original variable names), while keeping function/class identifiers exactly the same\n- Rearrange the order of logically independent statements or expressions to alter flow without changing semantics\n- Refactor compound expressions by expanding or consolidating nested operations, using equivalent arithmetic transformations or logical equivalences\n- Change how data structures are accessed, iterated, or constructed (e.g., convert index-based loops to iterator-based ones, replace explicit indexing with `for-each` constructs, or vice versa)\n- Modify formatting heavily\u2014alter indentation styles, bracket usage, whitespace, and line breaks to maximize visual difference\n- Replace literal constants with equivalent expressions or symbolic constants where meaningful\n- Use alternative syntactical forms for the same operations (e.g., write `IF NOT condition THEN` in place of `IF condition = False THEN`)\n- Decompose or inline helper functions or nested definitions, swapping between them as appropriate\n- Change the order of conditions in compound logical expressions, or rewrite them using De Morgan\u2019s laws and equivalent logic\n- Vary the style of returning values or setting intermediate variables (e.g., use early returns instead of accumulators, or vice versa)\n- Re-express iterative accumulations as folds/reductions or explicit iterative constructs\n- Apply any other safe syntactic or structural rewriting that preserves logic exactly\n\n**Critically, do not modify any function or class names or their hierarchy, nor remove or add any functional behavior or outputs.**  \n**Output only the fully rewritten pseudocode\u2014no explanations, comments, or extra text.**",
  "response": "Given the original pseudocode as input, produce a transformed version that preserves all original semantics, functionality, and exact function and class names, along with the original class and object hierarchy unchanged. Your rewritten pseudocode must be as syntactically and stylistically different as possible, employing any combination of the following transformations comprehensively and aggressively:\n\n- Convert all control flow structures to fundamentally different equivalents (e.g., replace all loops with recursion or vice versa; substitute conditionals with guard clauses or pattern matching where applicable)\n- Systematically rename **all** local variables and parameters using a consistent but different naming convention (e.g., change `snake_case` to `camelCase` or vice versa, or use thematic naming unrelated to original variable names), while keeping function/class identifiers exactly the same\n- Rearrange the order of logically independent statements or expressions to alter flow without changing semantics\n- Refactor compound expressions by expanding or consolidating nested operations, using equivalent arithmetic transformations or logical equivalences\n- Change how data structures are accessed, iterated, or constructed (e.g., convert index-based loops to iterator-based ones, replace explicit indexing with `for-each` constructs, or vice versa)\n- Modify formatting heavily\u2014alter indentation styles, bracket usage, whitespace, and line breaks to maximize visual difference\n- Replace literal constants with equivalent expressions or symbolic constants where meaningful\n- Use alternative syntactical forms for the same operations (e.g., write `IF NOT condition THEN` in place of `IF condition = False THEN`)\n- Decompose or inline helper functions or nested definitions, swapping between them as appropriate\n- Change the order of conditions in compound logical expressions, or rewrite them using De Morgan\u2019s laws and equivalent logic\n- Vary the style of returning values or setting intermediate variables (e.g., use early returns instead of accumulators, or vice versa)\n- Re-express iterative accumulations as folds/reductions or explicit iterative constructs\n- Apply any other safe syntactic or structural rewriting that preserves logic exactly\n\n**Critically, do not modify any function or class names or their hierarchy, nor remove or add any functional behavior or outputs.**  \n**Output only the fully rewritten pseudocode\u2014no explanations, comments, or extra text.**",
  "score": -0.19331468520063574,
  "feedback": "The following are 20 lines of original pseudocode of a random subset of the problems along with their modified pseudocodes.\n\nPseudocode for Problem 1:\n```\nFUNCTION encode_cyclic(input_string)\ngroupsList \u2190 []\n\nFUNCTION processGroup(idx)\n    IF idx = ((LENGTH(input_string) + 2) DIV 3) THEN\n        RETURN\n    ELSE\n        startPos \u2190 idx * 3\n        endPos \u2190 startPos + 3\n        endPos \u2190 IF endPos < LENGTH(input_string) THEN endPos ELSE LENGTH(input_string)\n        groupsList APPEND SUBSTRING(input_string, startPos, endPos)\n        processGroup(idx + 1)\n    END IF\nEND FUNCTION\n\nprocessGroup(0)\n\nrotatedGroups \u2190 []\n\n\nModified Pseudocode for Problem 1:\n```\nFUNCTION encode_cyclic(input_string)\n    SET groups TO empty list\n    FOR each index FROM 0 TO (LENGTH OF input_string + 2) INTEGER DIVIDED BY 3 MINUS 1\n        ADD SUBSTRING OF input_string FROM (3 TIMES index) TO MINIMUM OF ((3 TIMES index PLUS 3), LENGTH OF input_string) TO groups\n    SET groups TO empty list\n    FOR each group IN groups\n        IF LENGTH OF group EQUALS 3\n            ADD CONCATENATION OF SUBSTRING OF group FROM SECOND CHARACTER TO END AND FIRST CHARACTER OF group TO groups\n        ELSE\n            ADD group TO groups\n    RETURN CONCATENATION OF ALL ELEMENTS IN groups\nEND FUNCTION\n\nFUNCTION decode_cyclic(input_string)\n    RETURN encode_cyclic(encode_cyclic(input_string))\nEND FUNCTION\n```\n\nPseudocode for Problem 2:\n```\nFUNCTION poly(list_of_coefficients, point)\n    FUNCTION powerSum(coeffs, idx)\n        IF idx = LENGTH(coeffs) THEN\n            RETURN 0\n        END IF\n        RETURN coeffs[idx] * (point ^ idx) + powerSum(coeffs, idx + 1)\n    END FUNCTION\n    RETURN powerSum(list_of_coefficients, 0)\nEND FUNCTION\n\nFUNCTION find_zero(list_of_coefficients)\n    FUNCTION searchInterval(startVal, endVal)\n        IF poly(list_of_coefficients, startVal) * poly(list_of_coefficients, endVal) > 0 THEN\n            RETURN searchInterval(startVal * 2.0, endVal * 2.0)\n        END IF\n        RETURN (startVal, endVal)\n    END FUNCTION\n\n    FUNCTION binarySearch(beginVal, endVal)\n\nModified Pseudocode for Problem 2:\n```\nFUNCTION poly(list_of_coefficients, point)\n    RETURN SUM OF each coefficient MULTIPLIED BY point RAISED TO THE POWER OF coefficient_index FOR EACH coefficient AND coefficient_index IN ENUMERATE(list_of_coefficients)\nEND FUNCTION\n\nFUNCTION find_zero(list_of_coefficients)\n    SET begin TO -1.0\n    SET end TO 1.0\n    WHILE poly(list_of_coefficients, begin) MULTIPLIED BY poly(list_of_coefficients, end) IS GREATER THAN 0\n        MULTIPLY begin BY 2.0\n        MULTIPLY end BY 2.0\n    END WHILE\n    WHILE end MINUS begin IS GREATER THAN 1e-10\n        SET center TO (begin PLUS end) DIVIDED BY 2.0\n        IF poly(list_of_coefficients, center) MULTIPLIED BY poly(list_of_coefficients, begin) IS GREATER THAN 0\n            SET begin TO center\n        ELSE\n            SET end TO center\n        END IF\n    END WHILE\n\nPseudocode for Problem 3:\n```\nFUNCTION is_prime(numVal)\n    FUNCTION check_div(currentDiv)\n        IF currentDiv GREATER THAN (numVal - 2)\n            RETURN True\n        END IF\n        IF NOT (numVal MOD currentDiv) = 0\n            RETURN check_div(currentDiv + 1)\n        ELSE\n            RETURN False\n        END IF\n    END FUNCTION\n\n    IF numVal < (1 + 1) THEN\n        RETURN False\n    END IF\n\n    RETURN check_div(2)\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 3:\n```\nFUNCTION is_prime(number)\n    IF number LESS THAN 2\n        RETURN False\n    END IF\n    FOR each divisor FROM 2 TO number MINUS 2\n        IF number MODULO divisor EQUALS 0\n            RETURN False\n        END IF\n    END FOR\n    RETURN True\nEND FUNCTION\n```\n\nPseudocode for Problem 4:\n```\nFUNCTION change_base(integer_x, integer_base)\n\toutputString \u2190 \"\"\n\t\n\tPROCEDURE recurse(currentNumber)\n\t\tIF NOT (currentNumber > 0) THEN\n\t\t\tRETURN\n\t\tEND IF\n\t\t\n\t\trecurse(currentNumber DIV integer_base)\n\t\toutputString \u2190 outputString CONCAT STRING(currentNumber MOD integer_base)\n\tEND PROCEDURE\n\t\n\trecurse(integer_x)\n\tRETURN outputString\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 4:\n```\nFUNCTION change_base(integer_x, integer_base)\n    SET string_result TO empty string\n    WHILE integer_x GREATER THAN 0\n        SET string_result TO STRING OF (integer_x MODULO integer_base) CONCATENATED WITH string_result\n        SET integer_x TO integer_x DIVIDED BY integer_base USING INTEGER DIVISION\n    RETURN string_result\nEND FUNCTION\n```\n\nPseudocode for Problem 5:\n```\nFUNCTION choose_num(x, y)\n    guard x > y THEN RETURN -1\n    guard x = y THEN RETURN -1\n    IF NOT (y % 2 = 0) THEN\n        RETURN y - 1\n    END IF\n    RETURN y\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 5:\n```\nFUNCTION choose_num(x, y)\n    IF x GREATER THAN y\n        RETURN -1\n    END IF\n    IF y MODULO 2 EQUALS 0\n        RETURN y\n    END IF\n    IF x EQUALS y\n        RETURN -1\n    END IF\n    RETURN y MINUS 1\nEND FUNCTION\n```\n\nPseudocode for Problem 6:\n```\nFUNCTION add(alphaValue, betaValue)\n    tempResult := 0\n    tempResult := alphaValue\n    tempResult := tempResult + betaValue\n    RETURN tempResult\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 6:\n```\nFUNCTION add(x, y)\n    RETURN x PLUS y\nEND FUNCTION\n```\n\nPseudocode for Problem 7:\n```\nFUNCTION largest_prime_factor(n)\n    FUNCTION is_prime(k)\n        IF NOT (k >= 2) THEN RETURN False\n        RETURN check_divisor(2, k)\n\n        FUNCTION check_divisor(dividend, limit)\n            IF dividend = limit THEN RETURN True\n            IF (limit MOD dividend) = 0 THEN RETURN False\n            RETURN check_divisor(dividend + 1, limit)\n        END FUNCTION\n    END FUNCTION\n\n    FUNCTION find_largest(divisor, limit, currentMax)\n        IF divisor > limit THEN RETURN currentMax\n        IF (limit MOD divisor = 0) THEN\n            IF is_prime(divisor) THEN\n                RETURN find_largest(divisor + 1, limit, \n                    (IF divisor > currentMax THEN divisor ELSE currentMax))\n            END IF\n\nModified Pseudocode for Problem 7:\n```\nFUNCTION largest_prime_factor(n)\n    FUNCTION is_prime(k)\n        IF k LESS THAN 2\n            RETURN False\n        FOR i FROM 2 TO k MINUS 1\n            IF k MODULO i EQUALS 0\n                RETURN False\n        RETURN True\n    END FUNCTION\n\n    SET largest TO 1\n    FOR j FROM 2 TO n\n        IF n MODULO j EQUALS 0 AND is_prime(j)\n            SET largest TO MAXIMUM OF largest AND j\n    RETURN largest\nEND FUNCTION\n```\n\nPseudocode for Problem 8:\n```\nFUNCTION encode_shift(inputString)\n    FUNCTION encode_recursive(index, accumulator)\n        IF index >= LENGTH(inputString) THEN\n            RETURN accumulator\n        END IF\n        DECLARE currentChar = inputString[index]\n        DECLARE asciiVal = TO_ASCII(currentChar)\n        DECLARE shiftedVal = ((asciiVal - TO_ASCII(\"a\") + 5) MOD 26) + TO_ASCII(\"a\")\n        DECLARE encodedChar = TO_CHAR(shiftedVal)\n        RETURN encode_recursive(index + 1, accumulator + encodedChar)\n    END FUNCTION\n    RETURN encode_recursive(0, \"\")\nEND FUNCTION\n\nFUNCTION decode_shift(inputString)\n    FUNCTION decode_recursive(position, result)\n        IF position = LENGTH(inputString) THEN\n            RETURN result\n        END IF\n\nModified Pseudocode for Problem 8:\n```\nFUNCTION encode_shift(input_string)\n    RETURN CONCATENATION OF CHARACTER FOR EACH character IN input_string WHERE\n        CHARACTER IS COMPUTED BY\n            CONVERT character TO ASCII VALUE\n            ADD 5 TO ASCII VALUE\n            SUBTRACT ASCII VALUE OF \"a\"\n            COMPUTE RESULT MODULO 26\n            ADD ASCII VALUE OF \"a\"\n            CONVERT RESULT BACK TO CHARACTER\nEND FUNCTION\n\nFUNCTION decode_shift(input_string)\n    RETURN CONCATENATION OF CHARACTER FOR EACH character IN input_string WHERE\n        CHARACTER IS COMPUTED BY\n            CONVERT character TO ASCII VALUE\n            SUBTRACT 5 FROM ASCII VALUE\n            SUBTRACT ASCII VALUE OF \"a\"\n            COMPUTE RESULT MODULO 26\n            ADD ASCII VALUE OF \"a\"\nScore of -1*(BLEU Score) for ALL the problems: -0.19331468520063574",
  "iter": 3
}