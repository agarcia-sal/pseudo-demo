{
  "prompt": "Given an input pseudocode snippet, produce an extensively transformed yet semantically equivalent version that strictly preserves all function and class names, their exact argument lists and signatures, plus the original class inheritance and containment hierarchies without adding or removing any elements. Your rewritten pseudocode must maximize dissimilarity from the original by aggressively applying a diverse, comprehensive, and recursively layered array of transformation techniques, including but not limited to:\n\n- Reconstruct all control flow: convert loops to recursion or tail-call variants; unfold recursion into loops; replace if-else chains with guard clauses, pattern matching, dispatch tables, or boolean logic rewrites; substitute switch/case with nested conditionals or polymorphic dispatch analogues.\n- Systematically rename every local variable and parameter in each scope using distinct, unrelated naming conventions (e.g., alternating between camelCase, snake_case, uppercase, thematic or arbitrary alphanumeric sets), ensuring no semantic hint or resemblance to original identifiers while never changing function/class names.\n- Alter data access and iteration: interchange index-based loops, iterators, foreach constructs; convert arrays to maps, sets, or other data structures if semantically valid; transform accumulation patterns fluently between explicit loops, folds, reduces, recursion, and accumulator-passing styles.\n- Reorganize and reorder independent and associative statements; rewrite logical expressions by applying Boolean algebra laws (including De Morgan\u2019s, contrapositives, distributive, associative identities) to restructure conditions while preserving exact semantics.\n- Inline function bodies or factor out repeated code into new helper subroutines with different nesting depths; arbitrarily flatten or deepen nesting to rearrange code blocks structurally.\n- Rewrite all arithmetic and logical expressions through equivalent identities, expansions, factorizations, or numeric transformations (e.g., replace exponentiation with repeated multiplication loops or recursive calls, convert constants into computed expressions or symbolic intermediates).\n- Reframe state management and value propagation: swap mutable variables for immutable reassignment chains or pure-functional style equivalents; alternate early returns with accumulators or control flags; change return statement structure and result aggregation logic dramatically to alter control flow and readability.\n- Modify formatting aggressively and consistently: switch indentation styles (spaces vs tabs, indent widths), randomize line breaks and statement grouping, alter delimiters and punctuation within pseudocode norms, remove all comments, and vary spacing to maximize textual divergence.\n- Replace idiomatic pseudocode constructs with alternative valid forms, including but not limited to using pattern matching, conditional expressions, logical short-circuiting, boolean arithmetic, higher-order constructs, or explicitly enumerated control flow.\n- Combine these transformations extensively, deeply, and recursively\u2014avoid shallow or superficial rewrites. Do not add, omit, or modify any external behavior, outputs, or functional effects.\n\nThe output must be **only** the fully rewritten pseudocode, without explanations, annotations, comments, partial snippets, or meta-discussion.\n\n**Absolutely preserve all original function and class names and maintain their original class/object nesting and inheritance structure intact.**  \n**Do not alter function signatures or class declarations in any way.**\n\nOutput exclusively the complete rewritten pseudocode.",
  "response": "Given an input pseudocode snippet, produce an extensively transformed yet semantically equivalent version that strictly preserves all function and class names, their exact argument lists and signatures, plus the original class inheritance and containment hierarchies without adding or removing any elements. Your rewritten pseudocode must maximize dissimilarity from the original by aggressively applying a diverse, comprehensive, and recursively layered array of transformation techniques, including but not limited to:\n\n- Reconstruct all control flow: convert loops to recursion or tail-call variants; unfold recursion into loops; replace if-else chains with guard clauses, pattern matching, dispatch tables, or boolean logic rewrites; substitute switch/case with nested conditionals or polymorphic dispatch analogues.\n- Systematically rename every local variable and parameter in each scope using distinct, unrelated naming conventions (e.g., alternating between camelCase, snake_case, uppercase, thematic or arbitrary alphanumeric sets), ensuring no semantic hint or resemblance to original identifiers while never changing function/class names.\n- Alter data access and iteration: interchange index-based loops, iterators, foreach constructs; convert arrays to maps, sets, or other data structures if semantically valid; transform accumulation patterns fluently between explicit loops, folds, reduces, recursion, and accumulator-passing styles.\n- Reorganize and reorder independent and associative statements; rewrite logical expressions by applying Boolean algebra laws (including De Morgan\u2019s, contrapositives, distributive, associative identities) to restructure conditions while preserving exact semantics.\n- Inline function bodies or factor out repeated code into new helper subroutines with different nesting depths; arbitrarily flatten or deepen nesting to rearrange code blocks structurally.\n- Rewrite all arithmetic and logical expressions through equivalent identities, expansions, factorizations, or numeric transformations (e.g., replace exponentiation with repeated multiplication loops or recursive calls, convert constants into computed expressions or symbolic intermediates).\n- Reframe state management and value propagation: swap mutable variables for immutable reassignment chains or pure-functional style equivalents; alternate early returns with accumulators or control flags; change return statement structure and result aggregation logic dramatically to alter control flow and readability.\n- Modify formatting aggressively and consistently: switch indentation styles (spaces vs tabs, indent widths), randomize line breaks and statement grouping, alter delimiters and punctuation within pseudocode norms, remove all comments, and vary spacing to maximize textual divergence.\n- Replace idiomatic pseudocode constructs with alternative valid forms, including but not limited to using pattern matching, conditional expressions, logical short-circuiting, boolean arithmetic, higher-order constructs, or explicitly enumerated control flow.\n- Combine these transformations extensively, deeply, and recursively\u2014avoid shallow or superficial rewrites. Do not add, omit, or modify any external behavior, outputs, or functional effects.\n\nThe output must be **only** the fully rewritten pseudocode, without explanations, annotations, comments, partial snippets, or meta-discussion.\n\n**Absolutely preserve all original function and class names and maintain their original class/object nesting and inheritance structure intact.**  \n**Do not alter function signatures or class declarations in any way.**\n\nOutput exclusively the complete rewritten pseudocode.",
  "score": -0.13904506054731938,
  "feedback": "The following are 20 lines of original pseudocode of a random subset of the problems along with their modified pseudocodes.\n\nPseudocode for Problem 1:\n```\nFUNCTION change_base(integer_x, integer_base)\n  LET recurse_convert(accumulator_str, current_num) =\n    IF NOT (current_num > 0) THEN\n      accumulator_str\n    ELSE\n      LET mod_digit = current_num % integer_base\n      LET new_accumulator = TO_STRING(mod_digit) + accumulator_str\n      LET next_num = (current_num - mod_digit) / integer_base\n      recurse_convert(new_accumulator, next_num)\n  RETURN recurse_convert(\"\", integer_x)\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 1:\n```\nFUNCTION change_base(integer_x, integer_base)\n    SET string_result TO empty string\n    WHILE integer_x GREATER THAN 0\n        SET string_result TO STRING OF (integer_x MODULO integer_base) CONCATENATED WITH string_result\n        SET integer_x TO integer_x DIVIDED BY integer_base USING INTEGER DIVISION\n    RETURN string_result\nEND FUNCTION\n```\n\nPseudocode for Problem 2:\n```\nFUNCTION is_palindrome(text)\n\treturn _verify_palindrome(0, LENGTH(text), text)\nEND FUNCTION\n\nFUNCTION _verify_palindrome(pos_A, length_of_input, string_input)\n\tIF NOT (pos_A < length_of_input / 2) THEN\n\t\tRETURN True\n\tELSE\n\t\tVAR leftChar = GET_CHAR(string_input, pos_A)\n\t\tVAR rightCharPosition = (length_of_input - 1) - pos_A\n\t\tVAR rightChar = GET_CHAR(string_input, rightCharPosition)\n\t\tIF NOT (leftChar = rightChar) THEN RETURN False\n\t\tRETURN _verify_palindrome(pos_A + 1, length_of_input, string_input)\n\tEND IF\nEND FUNCTION\n\nFUNCTION LENGTH(seq)\n\tVAR count_accumulator = 0\n\tVAR iterator = SEQ_ITER(seq)\n\nModified Pseudocode for Problem 2:\n```\nFUNCTION is_palindrome(text)\n    FOR each index FROM 0 TO LENGTH OF text MINUS 1\n        IF CHARACTER AT text[index] IS NOT EQUAL TO CHARACTER AT text[LENGTH OF text MINUS 1 MINUS index]\n            RETURN False\n    RETURN True\nEND FUNCTION\n```\n\nPseudocode for Problem 3:\n```\nFUNCTION add(list_of_integers)\n\ttail_sum_helper(current_index, acc) =\n\t\tIF current_index > LENGTH(list_of_integers) THEN acc\n\t\tELSE\n\t\t\tcurrent_element := (SELECT list_of_integers AT current_index)\n\t\t\tnext_acc := acc + current_element * (1 - ((current_element % 2) AND 1))\n\t\t\ttail_sum_helper(current_index + 2, next_acc)\n\tEND IF\n\tRETURN tail_sum_helper(1, 0)\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 3:\n```\nFUNCTION add(list_of_integers)\n    RETURN SUM OF ELEMENTS AT positions FROM 1 TO LENGTH OF list_of_integers STEP 2 WHERE ELEMENT IS EVEN\nEND FUNCTION\n```\n\nPseudocode for Problem 4:\n```\nFUNCTION rounded_avg(integer_n, integer_m)\n\tvar1_sum_accumulator \u2190 0\n\tvar2_counter \u2190 integer_n\n\n\tFUNCTION loop_accumulate(value_acc, curr_index)\n\t\tguard curr_index > integer_m IN\n\t\t\tRETURN value_acc\n\t\tELSE\n\t\t\tRETURN loop_accumulate(value_acc + curr_index, curr_index + 1)\n\t\tEND\n\tEND\n\n\tFUNCTION is_less(a, b) RETURN a < b END\n\n\tguard NOT is_less(integer_m, integer_n) IN\n\t\tvar1_sum_accumulator \u2190 loop_accumulate(var1_sum_accumulator, var2_counter)\n\t\tvar3_count \u2190 (integer_m - integer_n) + 1\n\t\tvar4_avg \u2190 var1_sum_accumulator / var3_count\n\t\n\nModified Pseudocode for Problem 4:\n```\nFUNCTION rounded_avg(integer_n, integer_m)\n    IF integer_m LESS THAN integer_n\n        RETURN -1\n    SET summation TO 0\n    FOR each integer_i FROM integer_n TO integer_m INCLUSIVE\n        INCREMENT summation BY integer_i\n    SET average_value TO summation DIVIDED BY (integer_m MINUS integer_n PLUS 1)\n    SET rounded_average TO ROUND average_value TO NEAREST INTEGER\n    RETURN BINARY REPRESENTATION OF rounded_average\nEND FUNCTION\n```\n\nPseudocode for Problem 5:\n```\nFUNCTION encode_shift(input_string)\n\treturn (function process_enc(kleptos)\n\t\tif kleptos == \"\" then return \"\" end if\n\t\tlocal c = kleptos[0]\n\t\tlocal x1, x2, x3, x4, x5, x6 = 0, 0, 0, 0, 0, 0\n\t\tx1 = ORD(c)\n\t\tx2 = (x1 + 5)\n\t\tx3 = x2 - ORD(\"a\")\n\t\tx4 = ((x3 % 26) + 26) % 26\n\t\tx5 = x4 + ORD(\"a\")\n\t\tx6 = CHR(x5)\n\t\treturn x6 .. process_enc(SUBSTRING(kleptos, 1))\n\tend)(input_string)\nEND FUNCTION\n\nFUNCTION decode_shift(input_string)\n\ttailcall := function(dec_iter, tail_acc)\n\t\tif LEN(dec_iter) <= 0 then return tail_acc end if\n\t\tlocal h = dec_iter[0]\n\nModified Pseudocode for Problem 5:\n```\nFUNCTION encode_shift(input_string)\n    RETURN CONCATENATION OF CHARACTER FOR EACH character IN input_string WHERE\n        CHARACTER IS COMPUTED BY\n            CONVERT character TO ASCII VALUE\n            ADD 5 TO ASCII VALUE\n            SUBTRACT ASCII VALUE OF \"a\"\n            COMPUTE RESULT MODULO 26\n            ADD ASCII VALUE OF \"a\"\n            CONVERT RESULT BACK TO CHARACTER\nEND FUNCTION\n\nFUNCTION decode_shift(input_string)\n    RETURN CONCATENATION OF CHARACTER FOR EACH character IN input_string WHERE\n        CHARACTER IS COMPUTED BY\n            CONVERT character TO ASCII VALUE\n            SUBTRACT 5 FROM ASCII VALUE\n            SUBTRACT ASCII VALUE OF \"a\"\n            COMPUTE RESULT MODULO 26\n            ADD ASCII VALUE OF \"a\"\n\nPseudocode for Problem 6:\n```\nFUNCTION sort_even(list_of_elements)\n\treturn GET_RESULT(0, [], SPLIT_ELEMENTS(list_of_elements, 0, [], []))\n\t\n\tFUNCTION SPLIT_ELEMENTS(inputList, idx, evens_acc, odds_acc)\n\t\tIF idx >= LENGTH(inputList)\n\t\t\tRETURN (evens_acc, odds_acc)\n\t\tELSE\n\t\t\tIF (idx % 2) = 0\n\t\t\t\tRETURN SPLIT_ELEMENTS(inputList, idx + 1, APPEND_TO(evens_acc, inputList[idx]), odds_acc)\n\t\t\tELSE\n\t\t\t\tRETURN SPLIT_ELEMENTS(inputList, idx + 1, evens_acc, APPEND_TO(odds_acc, inputList[idx]))\n\t\n\tFUNCTION GET_RESULT(iter, acc, tupleList)\n\t\tSET (evenList, oddList) = tupleList\n\t\tIF iter >= MIN(LENGTH(evenList), LENGTH(oddList))\n\t\t\tIF LENGTH(evenList) > LENGTH(oddList)\n\t\t\t\tRETURN CONCATENATE(acc, [evenList[LENGTH(evenList) - 1]])\n\t\t\tELSE\n\t\t\t\tRETURN acc\n\nModified Pseudocode for Problem 6:\n```\nFUNCTION sort_even(list_of_elements)\n    SET even_indexed_elements TO list_of_elements AT EVERY SECOND ELEMENT STARTING FROM INDEX ZERO\n    SET odd_indexed_elements TO list_of_elements AT EVERY SECOND ELEMENT STARTING FROM INDEX ONE\n    SORT even_indexed_elements IN NON-DECREASING ORDER\n    SET answer_list TO EMPTY LIST\n    FOR each pair_of_elements IN ZIP OF even_indexed_elements AND odd_indexed_elements\n        EXTEND answer_list BY ELEMENTS OF pair_of_elements IN ORDER\n    IF LENGTH OF even_indexed_elements IS GREATER THAN LENGTH OF odd_indexed_elements\n        APPEND LAST ELEMENT OF even_indexed_elements TO answer_list\n    RETURN answer_list\nEND FUNCTION\n```\n\nPseudocode for Problem 7:\n```\nFUNCTION iscube(integer_value)\n\tvar nZ3Yq := integer_value\n    FUNCTION auxiliary_check(p_value)\n\t    IF NOT (p_value >= 0) THEN\n\t\t    RETURN auxiliary_check(-p_value)\n\t\tELSE \n\t        var X7nH := p_value\n\t        FUNCTION pow_three(xy1)\n\t\t        var zRt2 := 0\n\t\t        FUNCTION mulaccum(vA, total)\n\t\t\t        IF vA = 0 THEN RETURN total\n\t\t\t        ELSE RETURN mulaccum(vA - 1, total + xy1)\n\t\t        END FUNCTION\n\t\t        RETURN mulaccum(3, 0) + (xy1 * xy1) - (xy1 * xy1)  + (xy1 * xy1) - (xy1 * xy1)  + (xy1 * xy1) - (xy1 * xy1) + (xy1 * xy1) - (xy1 * xy1) + (xy1 * xy1) - (xy1 * xy1) + (xy1 * xy1) - (xy1 * xy1) + (xy1 * xy1) - (xy1 * xy1) + (xy1 * xy1)\n\t\t        /* replaced exponentiation by a convoluted addition pattern that is mathematically equivalent to xy1\u00b3 */\n\t        END FUNCTION\n\t        var s_Qv := ROUND(EXP(LOG(X7nH)/3))\n\t        var Y20u := pow_three(s_Qv)\n\t        RETURN Y20u = X7nH\n\nModified Pseudocode for Problem 7:\n```\nFUNCTION iscube(integer_value)\n    SET absolute_value TO ABSOLUTE VALUE OF integer_value\n    SET cube_root_approximation TO ROUND OF absolute_value TO THE POWER OF (1 DIVIDED BY 3)\n    SET cube_of_approximation TO cube_root_approximation RAISED TO THE POWER OF 3\n    RETURN cube_of_approximation EQUALS absolute_value\nEND FUNCTION\n```\n\nPseudocode for Problem 8:\n```\nFUNCTION poly(list_of_coefficients, point)\n\tLET coefficient_137x = 0\n\tLET exponent_mnop = 0\n\tLET accVal = 0\n\tLET iterator_QwErTy = 0\n\tLET MAX_L = LENGTH(list_of_coefficients)\n\tWHILE iterator_QwErTy < MAX_L DO\n\t\tLET cj_9dS = list_of_coefficients[iterator_QwErTy]\n\t\taccVal = accVal + (cj_9dS * POWER(point, iterator_QwErTy))\n\t\titerator_QwErTy = iterator_QwErTy + 1\n\tEND WHILE\n\tRETURN accVal\nEND FUNCTION\n\nFUNCTION find_zero(list_of_coefficients)\n\tLET negOne = -1.0\n\tLET posOne = 1.0\n\tFUNCTION check_signs(neg_val, pos_val)\n\t\tRETURN poly(list_of_coefficients, neg_val) * poly(list_of_coefficients, pos_val) > 0\n\nModified Pseudocode for Problem 8:\n```\nFUNCTION poly(list_of_coefficients, point)\n    RETURN SUM OF each coefficient MULTIPLIED BY point RAISED TO THE POWER OF coefficient_index FOR EACH coefficient AND coefficient_index IN ENUMERATE(list_of_coefficients)\nEND FUNCTION\n\nFUNCTION find_zero(list_of_coefficients)\n    SET begin TO -1.0\n    SET end TO 1.0\n    WHILE poly(list_of_coefficients, begin) MULTIPLIED BY poly(list_of_coefficients, end) IS GREATER THAN 0\n        MULTIPLY begin BY 2.0\n        MULTIPLY end BY 2.0\n    END WHILE\n    WHILE end MINUS begin IS GREATER THAN 1e-10\n        SET center TO (begin PLUS end) DIVIDED BY 2.0\n        IF poly(list_of_coefficients, center) MULTIPLIED BY poly(list_of_coefficients, begin) IS GREATER THAN 0\n            SET begin TO center\n        ELSE\n            SET end TO center\n        END IF\n    END WHILE\nScore of -1*(BLEU Score) for ALL the problems: -0.13904506054731938",
  "iter": 6
}