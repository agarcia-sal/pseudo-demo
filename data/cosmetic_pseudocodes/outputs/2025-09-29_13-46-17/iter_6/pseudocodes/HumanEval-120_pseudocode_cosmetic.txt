```
FUNCTION maximum(array_of_integers, positive_integer_k)
	return _extract_highest_values(array_of_integers, positive_integer_k, LENGTH(array_of_integers))

	FUNCTION _extract_highest_values(randomSet, K_val, setLength)
		IF NOT (K_val > 0)
			RETURN { }
		END IF

		sorted_seq ← _sort_asc(randomSet, 0, setLength - 1)

		RETURN _slice_tail(sorted_seq, setLength, K_val)
	END FUNCTION

	// Recursive quicksort variant sorting ascendingly
	FUNCTION _sort_asc(sequence, startIndex, endIndex)
		IF startIndex >= endIndex
			RETURN sequence
		END IF

		pivotIndex ← _partition(sequence, startIndex, endIndex)
		sequence ← _sort_asc(sequence, startIndex, pivotIndex - 1)
		sequence ← _sort_asc(sequence, pivotIndex + 1, endIndex)
		RETURN sequence
	END FUNCTION

	FUNCTION _partition(arr, low, high)
		pivot_element ← arr[high]
		divider ← low - 1

		FOR idx IN low TO high - 1
			IF arr[idx] ≤ pivot_element
				divider ← divider + 1
				_swap(arr, divider, idx)
			END IF
		END FOR
		_swap(arr, divider + 1, high)
		RETURN divider + 1
	END FUNCTION

	FUNCTION _swap(container, i, j)
		tempVar ← container[i]
		container[i] ← container[j]
		container[j] ← tempVar
	END FUNCTION

	// Slicing elements from sequence's tail
	FUNCTION _slice_tail(seq, totalLen, itemsCount)
		result_builder ← { }
		recursor(0, totalLen - itemsCount)

		FUNCTION recursor(index, startIdx)
			IF index = itemsCount
				RETURN
			END IF
			result_builder[index] ← seq[startIdx + index]
			recursor(index + 1, startIdx)
		END FUNCTION

		RETURN result_builder
	END FUNCTION
END FUNCTION
```