```
FUNCTION prime_fib(integer_n)
	import mathematical_functions_module
	
	FUNCTION is_prime(integer_p)
		PROCEDURE check_factor(current_val, upper_limit, prime_flag)
			IF current_val GREATER_THAN_OR_EQUAL_TO upper_limit THEN
				RETURN prime_flag
			ELSE
				prime_flag_updated := (prime_flag AND NOT (integer_p MODULO current_val EQUALS 0))
				RETURN check_factor(current_val + 1, upper_limit, prime_flag_updated)
			ENDIF
		END PROCEDURE
		
		IF (integer_p < 2) THEN
			RETURN False
		ELSE
			limit_val := MIN((INTEGER(SQRT(integer_p)) + 1), (integer_p - 1))
			RETURN check_factor(2, limit_val, True)
		ENDIF
	END FUNCTION
	
	FUNCTION add_last_two(lst)
		size_lst := LENGTH(lst)
		RETURN lst[size_lst - 1] + lst[size_lst - 2]
	END FUNCTION
	
	FIB_SEQ := [0, 1]
	
	PROCEDURE iterate_fib(prime_counter, fib_sequence)
		prime_goal := prime_counter
		current_sequence := fib_sequence
		COND
			prime_goal = 0 -> RETURN current_sequence[LENGTH(current_sequence) - 1]
			ELSE
				next_fib := add_last_two(current_sequence)
				updated_sequence := current_sequence + [next_fib]
				is_prime_flag := is_prime(next_fib)
				new_goal := prime_goal - (IF is_prime_flag THEN 1 ELSE 0)
				RETURN iterate_fib(new_goal, updated_sequence)
		ENDCOND
	END PROCEDURE
	
	RETURN iterate_fib(integer_n, FIB_SEQ)
END FUNCTION
```