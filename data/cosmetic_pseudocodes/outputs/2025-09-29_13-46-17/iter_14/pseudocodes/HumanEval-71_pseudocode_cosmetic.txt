```
FUNCTION triangle_area(side_a, side_b, side_c)
⮞ fun₁_fA₍=₎ {↯
  ↮ func⟡₈ := λ(λ₀ᶳ) → {
    ↻⇨ (λ₁ᶳ,λ₂ᶳ,λ₃ᶳ) ← (side_a,side_b,side_c);↳
    ↻ flagʙAₓ := FALSE;
    ↳
    ⋄ checkTriangle := λ(x,y,z) → {
      ⎴    IF ¬(x + y > z) THEN { RETURN TRUE } ELSE { RETURN FALSE }
    };
    ↴
    ↳ flagʙAₓ := (checkTriangle(λ₁ᶳ,λ₂ᶳ,λ₃ᶳ) ∨ checkTriangle(λ₁ᶳ,λ₃ᶳ,λ₂ᶳ) ∨ checkTriangle(λ₂ᶳ,λ₃ᶳ,λ₁ᶳ));
    ↳ IF flagʙAₓ THEN {
      RETURN -1
    };
    ↳
    ↯composeSemi := λ(a,b,c,acc) → {
      IF a + b + c - acc > 0 THEN {
        composeSemi(a,b,c,acc)
      } ELSE RETURN acc
    };
    semippₑrᵢ := (side_a + side_b + side_c) * (1 / 2);
    ↳
    ↻ squareRootH := λ(ω, α, β, γ) → {
      ↑Π := ω*(ω - α)*(ω - β)*(ω - γ);
      λ R_s⊖ := λ recursiveMult(n, acc) → {
        IF n == 0 THEN RETURN acc ELSE RETURN recursiveMult(n-1, acc * R_s⊖)
      };
      ⍥ rootResult := exp(log(↑Π) * 0.5);
      RETURN rootResult
    };
    ↳
    areaΔ := squareRootH(semippₑrᵢ, side_a, side_b, side_c);
    ↳
    roundFunc := λ(v,d) → {
      multiplierₓₛ := λ i → (10 ^ i);
      resₙ ← v * multiplierₓₛ(d);
      truncatedₙ ← (resₙ - (resₙ mod 1));
      RETURN truncatedₙ / multiplierₓₛ(d)
    };
    ↳ rounded_val := roundFunc(areaΔ, 2);
    RETURN rounded_val
  };
  RETURN fun₁_fA₍=₎(side_a, side_b, side_c)
}
```