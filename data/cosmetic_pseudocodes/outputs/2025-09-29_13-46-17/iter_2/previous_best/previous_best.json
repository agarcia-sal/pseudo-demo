{
  "prompt": "Given the original pseudocode as input, produce a rewritten version that preserves **all** original semantics and functionality exactly, including keeping all function and class names **identical** and maintaining the same class/object hierarchy **unchanged**, but transforms the code into an entirely different pseudocode style and structure by:  \n- Using alternate control flow constructs (e.g., replace loops with recursion or vice versa)  \n- Modifying variable naming styles while keeping function/class identifiers intact  \n- Changing the order and style of expressions and statements  \n- Replacing explicit control structures with equivalent but syntactically different ones  \n- Utilizing different indentation and formatting conventions  \n- Rephrasing conditions and arithmetic operations in varied but equivalent ways  \n- Unfolding or folding expressions without altering logic  \n- Varying the way data structures are manipulated and iterated over  \n- Simplifying or reorganizing code blocks while maintaining behavior  \n\n**Output only the rewritten pseudocode without any explanations, comments, or additional text.**  \nAll function and class names must remain exactly as in the input pseudocode, with the original class and object hierarchy preserved.",
  "response": "Given the original pseudocode as input, produce a rewritten version that preserves **all** original semantics and functionality exactly, including keeping all function and class names **identical** and maintaining the same class/object hierarchy **unchanged**, but transforms the code into an entirely different pseudocode style and structure by:  \n- Using alternate control flow constructs (e.g., replace loops with recursion or vice versa)  \n- Modifying variable naming styles while keeping function/class identifiers intact  \n- Changing the order and style of expressions and statements  \n- Replacing explicit control structures with equivalent but syntactically different ones  \n- Utilizing different indentation and formatting conventions  \n- Rephrasing conditions and arithmetic operations in varied but equivalent ways  \n- Unfolding or folding expressions without altering logic  \n- Varying the way data structures are manipulated and iterated over  \n- Simplifying or reorganizing code blocks while maintaining behavior  \n\n**Output only the rewritten pseudocode without any explanations, comments, or additional text.**  \nAll function and class names must remain exactly as in the input pseudocode, with the original class and object hierarchy preserved.",
  "score": -0.21965086003024947,
  "feedback": "The following are 20 lines of original pseudocode of a random subset of the problems along with their modified pseudocodes.\n\nPseudocode for Problem 1:\n```\nFUNCTION add(a, b)\n  RETURN b ADD a\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 1:\n```\nFUNCTION add(x, y)\n    RETURN x PLUS y\nEND FUNCTION\n```\n\nPseudocode for Problem 2:\n```\nFUNCTION vowels_count(string_input)\n  vowelsList \u2190 ['a','e','i','o','u','A','E','I','O','U']\n  DEFINE count_vowels(idx, total)\n    IF idx = LENGTH(string_input) THEN\n      RETURN total\n    ELSE\n      currentChar \u2190 string_input[idx]\n      added \u2190 0\n      IF currentChar IN vowelsList THEN\n        added \u2190 1\n      END IF\n      RETURN count_vowels(idx + 1, total + added)\n    END IF\n  END DEFINE\n\n  total_vowels \u2190 count_vowels(1, 0)\n\n  lastChar \u2190 string_input[LENGTH(string_input)]\n  IF lastChar = 'Y' OR lastChar = 'y' THEN\n\nModified Pseudocode for Problem 2:\n```\nFUNCTION vowels_count(string_input)\n    SET vowels TO \"aeiouAEIOU\"\n    SET number_of_vowels TO SUM OF (character IS IN vowels) FOR EACH character IN string_input\n    IF LAST CHARACTER OF string_input IS 'y' OR LAST CHARACTER OF string_input IS 'Y'\n        INCREMENT number_of_vowels BY 1\n    END IF\n    RETURN number_of_vowels\nEND FUNCTION\n```\n\nPseudocode for Problem 3:\n```\nFUNCTION fizz_buzz(integer_n)\n list_nums \u2190 []\n  \n  FUNCTION check_and_add(index)\n   IF NOT (index >= integer_n) THEN\n    IF (index MOD 11 = 0) OR (index MOD 13 = 0) THEN\n     list_nums \u2190 list_nums + [index]\n    END IF\n    check_and_add(index + 1)\n   END IF\n  END FUNCTION\n  \n  check_and_add(0)\n  \n  concatenated_str \u2190 \"\"\n  \n  FUNCTION concat_numbers(pos)\n   IF NOT (pos >= LENGTH(list_nums)) THEN\n    concatenated_str \u2190 concatenated_str + TO_STRING(list_nums[pos])\n\nModified Pseudocode for Problem 3:\n```\nFUNCTION fizz_buzz(integer_n)\n    SET list_of_numbers TO empty list\n    FOR each integer_i IN range FROM 0 TO integer_n EXCLUSIVE\n        IF integer_i MODULO 11 EQUALS 0 OR integer_i MODULO 13 EQUALS 0\n            APPEND integer_i TO list_of_numbers\n        END IF\n    END FOR\n    SET concatenated_string TO empty string\n    FOR each number IN list_of_numbers\n        CONCATENATE string representation of number TO concatenated_string\n    END FOR\n    SET count_of_sevens TO 0\n    FOR each character_c IN concatenated_string\n        INCREMENT count_of_sevens BY (character_c EQUALS '7')\n    END FOR\n    RETURN count_of_sevens\nEND FUNCTION\n```\n\nPseudocode for Problem 4:\n```\nFUNCTION modp(integer_n, integer_p)\n resultVal \u2190 1\n PROCEDURE multiplyRecursively(counter)\n  IF counter = integer_n THEN\n   RETURN\n  ELSE\n   resultVal \u2190 (resultVal * 2) % integer_p\n   multiplyRecursively(counter + 1)\n  ENDIF\n END PROCEDURE\n multiplyRecursively(0)\n RETURN resultVal\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 4:\n```\nFUNCTION modp(integer_n, integer_p)\n    SET result_value TO 1\n    FOR each integer_index FROM 0 TO integer_n MINUS 1\n        SET result_value TO (2 MULTIPLIED BY result_value) MODULO integer_p\n    RETURN result_value\nEND FUNCTION\n```\n\nPseudocode for Problem 5:\n```\nFUNCTION words_string(input_string)\n  DEFINE process_characters(index, chars_accum)\n    IF index >= length(input_string) THEN RETURN chars_accum END IF\n\n    LET current_char = input_string[index]\n    LET next_accum = IF current_char == \",\" THEN chars_accum + [\" \"] ELSE chars_accum + [current_char] END IF\n\n    RETURN process_characters(index + 1, next_accum)\n  END DEFINE\n\n  IF input_string == \"\" THEN RETURN [] END IF\n\n  LET result_chars = process_characters(0, [])\n  LET combined_str = \"\"\n  FOR element IN result_chars DO combined_str = combined_str + element END FOR\n\n  RETURN split(combined_str, \" \")\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 5:\n```\nFUNCTION words_string(input_string)\n    IF input_string IS EMPTY\n        RETURN empty list\n    END IF\n\n    SET character_list TO empty list\n\n    FOR each character IN input_string\n        IF character IS EQUAL TO comma\n            APPEND space TO character_list\n        ELSE\n            APPEND character TO character_list\n        END IF\n    END FOR\n\n    SET joined_string TO concatenation of all characters in character_list\n    RETURN list of words obtained by splitting joined_string on whitespace\nEND FUNCTION\n```\n\nPseudocode for Problem 6:\n```\nFUNCTION rounded_avg(integer_n, integer_m)\n  integer_sum <- 0\n  FUNCTION recursive_add(current, end)\n    IF current IS GREATER THAN end THEN\n      RETURN 0\n    ELSE\n      RETURN current + recursive_add(current + 1, end)\n    ENDIF\n  END FUNCTION\n\n  IF NOT (integer_m >= integer_n) THEN\n    RETURN -1\n  ENDIF\n\n  integer_sum <- recursive_add(integer_n, integer_m)\n  integer_length <- (integer_m - integer_n) + 1\n  average_val <- integer_sum / integer_length\n  rounded_val <- ROUND(average_val)\n  \n\nModified Pseudocode for Problem 6:\n```\nFUNCTION rounded_avg(integer_n, integer_m)\n    IF integer_m LESS THAN integer_n\n        RETURN -1\n    SET summation TO 0\n    FOR each integer_i FROM integer_n TO integer_m INCLUSIVE\n        INCREMENT summation BY integer_i\n    SET average_value TO summation DIVIDED BY (integer_m MINUS integer_n PLUS 1)\n    SET rounded_average TO ROUND average_value TO NEAREST INTEGER\n    RETURN BINARY REPRESENTATION OF rounded_average\nEND FUNCTION\n```\n\nPseudocode for Problem 7:\n```\nFUNCTION change_base(integer_x, integer_base)\n  FUNCTION helper(n, b, acc)\n    IF NOT (n > 0)\n      RETURN acc\n    ELSE\n      LET digit = STRING(n MOD b)\n      RETURN helper(n DIV b, b, digit + acc)\n  END FUNCTION\n  RETURN helper(integer_x, integer_base, \"\")\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 7:\n```\nFUNCTION change_base(integer_x, integer_base)\n    SET string_result TO empty string\n    WHILE integer_x GREATER THAN 0\n        SET string_result TO STRING OF (integer_x MODULO integer_base) CONCATENATED WITH string_result\n        SET integer_x TO integer_x DIVIDED BY integer_base USING INTEGER DIVISION\n    RETURN string_result\nEND FUNCTION\n```\n\nPseudocode for Problem 8:\n```\nFUNCTION is_prime(number)\n  IF NOT (number >= 2) THEN\n    RETURN False\n  END IF\n\n  FUNCTION check_divisor(current)\n    IF current > number - 2 THEN\n      RETURN True\n    END IF\n    IF (number % current) = 0 THEN\n      RETURN False\n    ELSE\n      RETURN check_divisor(current + 1)\n    END IF\n  END FUNCTION\n\n  RETURN check_divisor(2)\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 8:\n```\nFUNCTION is_prime(number)\n    IF number LESS THAN 2\n        RETURN False\n    END IF\n    FOR each divisor FROM 2 TO number MINUS 2\n        IF number MODULO divisor EQUALS 0\n            RETURN False\n        END IF\n    END FOR\n    RETURN True\nEND FUNCTION\n```\nScore of -1*(BLEU Score) for ALL the problems: -0.21965086003024947",
  "iter": 2
}