FUNCTION encode(input_text)  
    SET swap_set TO "AEIOUaeiou"  
    SET translation_map TO EMPTY DICTIONARY  
    SET temp_char TO NIL  
    SET index_counter TO 0  
    WHILE index_counter IS LESS THAN LENGTH OF swap_set DO  
        SET current_char TO swap_set.at(index_counter)  
        SET ascii_val TO ASCII_VALUE(current_char)  
        SET incremented_ascii TO ascii_val + 2  
        SET translated_char TO CHARACTER_FROM_ASCII(incremented_ascii)  
        ASSIGN translation_map[current_char] = translated_char  
        INCREMENT index_counter BY 1  
    END WHILE  
    SET swapped_text TO EMPTY STRING  
    SET walk_index TO 0  
    WHILE walk_index LESS THAN LENGTH OF input_text DO  
        SET original_char TO input_text.at(walk_index)  
        IF original_char IS GREATER OR EQUAL TO "a" AND original_char IS LESS OR EQUAL TO "z" THEN  
            SET swapped_char TO CHARACTER_FROM_ASCII(ASCII_VALUE(original_char) - (ASCII_VALUE('a') - ASCII_VALUE('A')))  
        ELSE IF original_char IS GREATER OR EQUAL TO "A" AND original_char IS LESS OR EQUAL TO "Z" THEN  
            SET swapped_char TO CHARACTER_FROM_ASCII(ASCII_VALUE(original_char) + (ASCII_VALUE('a') - ASCII_VALUE('A')))  
        ELSE  
            SET swapped_char TO original_char  
        END IF  
        APPEND swapped_char TO swapped_text  
        INCREMENT walk_index BY 1  
    END WHILE  
    SET output_string TO EMPTY STRING  
    SET step_index TO 0  
    REPEAT  
        EXIT WHEN step_index IS GREATER OR EQUAL TO LENGTH OF swapped_text  
        SET curr_char TO swapped_text.at(step_index)  
        IF translation_map CONTAINS KEY curr_char THEN  
            APPEND translation_map[curr_char] TO output_string  
        ELSE  
            APPEND curr_char TO output_string  
        END IF  
        INCREMENT step_index BY 1  
    UNTIL FALSE  
    RETURN output_string  
END FUNCTION