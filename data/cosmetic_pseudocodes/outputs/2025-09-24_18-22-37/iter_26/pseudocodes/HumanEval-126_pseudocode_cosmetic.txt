```
FUNCTION is_sorted(numbers_array)
    DECLARE frequency_map AS dictionary
    FOR each elem IN numbers_array DO
        frequency_map.at(elem) ← 0
    END FOR

    DECLARE idx AS integer ← 0
    WHILE idx < LENGTH(numbers_array) DO
        DECLARE current_val AS integer ← numbers_array.at(idx)
        DECLARE old_count AS integer ← frequency_map.at(current_val)
        frequency_map.at(current_val) ← old_count + 1
        idx ← idx + 1
    END WHILE

    DECLARE violation_found AS boolean ← False
    DECLARE position AS integer ← 0

    WHILE position < LENGTH(numbers_array) DO
        DECLARE candidate AS integer ← numbers_array.at(position)
        DECLARE freq_val AS integer ← frequency_map.at(candidate)
        IF freq_val > 2 THEN
            violation_found ← True
            BREAK
        END IF
        position ← position + 1
    END WHILE

    IF violation_found THEN
        RETURN False
    END IF

    DECLARE is_ordered AS boolean ← True
    DECLARE point AS integer ← 1

    SWITCH
        CASE LENGTH(numbers_array) = 0
        OR LENGTH(numbers_array) = 1
            RETURN True
        DEFAULT
            WHILE point < LENGTH(numbers_array) DO
                DECLARE previous_val AS integer ← numbers_array.at(point - 1)
                DECLARE current_val AS integer ← numbers_array.at(point)
                IF NOT (previous_val ≤ current_val) THEN
                    is_ordered ← False
                    BREAK
                END IF
                point ← point + 1
            END WHILE
            RETURN is_ordered
    END SWITCH
END FUNCTION
```