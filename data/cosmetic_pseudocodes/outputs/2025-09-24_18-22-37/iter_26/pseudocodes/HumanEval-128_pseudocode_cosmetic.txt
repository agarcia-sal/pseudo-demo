```
FUNCTION prod_signs(sequence_of_digits)
	aux_index ← 0
	WHILE aux_index < LENGTH(sequence_of_digits) DO
		IF LENGTH(sequence_of_digits) IS 0 THEN
			RETURN None
		END IF
		EXIT
	END WHILE

	has_zero_flag ← false
	forward_cursor ← 0
	WHILE forward_cursor < LENGTH(sequence_of_digits)
		IF sequence_of_digits.at(forward_cursor) = 0 THEN
			has_zero_flag ← true
			EXIT
		END IF
		forward_cursor ← forward_cursor + 1
	END WHILE

	product_sign ← 0
	IF has_zero_flag = false THEN
		negatives_count ← 0
		scan_index ← LENGTH(sequence_of_digits) - 1
		WHILE scan_index ≥ 0
			current_val ← sequence_of_digits.at(scan_index)
			IF current_val < 0 THEN
				negatives_count ← negatives_count + 1
			END IF
			scan_index ← scan_index - 1
		END WHILE

		temp_sign ← -1
		accumulator ← 1
		exp_counter ← 0
		WHILE exp_counter < negatives_count
			accumulator ← accumulator × temp_sign
			exp_counter ← exp_counter + 1
		END WHILE
		product_sign ← accumulator
	END IF

	total_magnitude ← 0
	stepper ← 0
	WHILE stepper < LENGTH(sequence_of_digits)
		temp_abs ← sequence_of_digits.at(stepper)
		IF temp_abs < 0 THEN
			temp_abs ← -temp_abs
		END IF
		total_magnitude ← total_magnitude + temp_abs
		stepper ← stepper + 1
	END WHILE

	result_value ← product_sign × total_magnitude
	RETURN result_value
END FUNCTION
```