{
  "prompt": "Rewrite the given pseudocode into a version that is functionally identical in every detail: it must preserve all outputs, side effects, logic, and algorithmic behavior exactly, including the original function and class names and their full class-object hierarchies without any change. The output must be exclusively valid pseudocode text\u2014no explanations, comments, annotations, markdown formatting, or extraneous text.\n\nTo create the maximally distinct yet semantically equivalent pseudocode, apply at least the following comprehensive transformation strategies consistently throughout the entire input:\n\n1. **Systematic and consistent renaming:** Rename all variables, parameters, and temporary identifiers to new, unrelated names\u2014uniformly across all their occurrences to maintain correctness.\n\n2. **Control flow restructuring:** Replace all loops and conditional constructs with logically equivalent alternatives, for example:  \n   - Convert FOR-loops to WHILE-loops and vice versa.  \n   - Replace IF/ELSE with SWITCH/CASE or nested IF/ELSE chains.  \n   - Introduce or eliminate early returns and guard clauses to flatten or deepen nesting, as long as semantic equivalence holds.\n\n3. **Statement and expression reordering:** Reorder independent or commutative statements and computations without altering the final results.\n\n4. **Expression decomposition and consolidation:** Break down complex expressions into multiple simpler assignment steps, or merge sequential assignments into compound expressions, while preserving semantics.\n\n5. **Operator and syntax variation:** Use alternative syntactic forms and synonyms for assignments (e.g., \u201c:=\u201d vs \u201c=\u201d), logical and comparison operators (e.g., \u201cis equal to\u201d, \u201c==\u201d, \u201c\u2260\u201d, \u201cnot equal to\u201d), arithmetic operations (e.g., \u201cplus\u201d, \u201c+\u201d, \u201cincrement by\u201d), and data access (e.g., bracket vs dot notation if applicable).\n\n6. **Data structure and control constructs idiomatic variation:** Modify how data structures are traversed or manipulated without changing their meaning (e.g., iterate using indices versus iterators), reorder data access operations when safe.\n\n7. **Whitespace and formatting changes:** Vary indentation schemes, line breaks, spacing, and grouping within the bounds of valid pseudocode formatting rules.\n\n8. **Preserve all conditional and loop boundaries, all method signatures, class structures, and hierarchy:** absolutely do not rename or alter function names, class names, or their positions in the object/class structure.\n\n9. **No removal or semantic simplification:** Avoid replacing logic with mathematically simplified or built-in shortcuts that would alter the algorithm\u2019s step-by-step structure or effect.\n\nThe goal is to produce pseudocode text that is syntactically, structurally, and stylistically radically different from the original input, while remaining provably behaviorally equivalent. Output only the pseudocode\u2014nothing else.",
  "response": "Rewrite the given pseudocode into a version that is functionally identical in every detail: it must preserve all outputs, side effects, logic, and algorithmic behavior exactly, including the original function and class names and their full class-object hierarchies without any change. The output must be exclusively valid pseudocode text\u2014no explanations, comments, annotations, markdown formatting, or extraneous text.\n\nTo create the maximally distinct yet semantically equivalent pseudocode, apply at least the following comprehensive transformation strategies consistently throughout the entire input:\n\n1. **Systematic and consistent renaming:** Rename all variables, parameters, and temporary identifiers to new, unrelated names\u2014uniformly across all their occurrences to maintain correctness.\n\n2. **Control flow restructuring:** Replace all loops and conditional constructs with logically equivalent alternatives, for example:  \n   - Convert FOR-loops to WHILE-loops and vice versa.  \n   - Replace IF/ELSE with SWITCH/CASE or nested IF/ELSE chains.  \n   - Introduce or eliminate early returns and guard clauses to flatten or deepen nesting, as long as semantic equivalence holds.\n\n3. **Statement and expression reordering:** Reorder independent or commutative statements and computations without altering the final results.\n\n4. **Expression decomposition and consolidation:** Break down complex expressions into multiple simpler assignment steps, or merge sequential assignments into compound expressions, while preserving semantics.\n\n5. **Operator and syntax variation:** Use alternative syntactic forms and synonyms for assignments (e.g., \u201c:=\u201d vs \u201c=\u201d), logical and comparison operators (e.g., \u201cis equal to\u201d, \u201c==\u201d, \u201c\u2260\u201d, \u201cnot equal to\u201d), arithmetic operations (e.g., \u201cplus\u201d, \u201c+\u201d, \u201cincrement by\u201d), and data access (e.g., bracket vs dot notation if applicable).\n\n6. **Data structure and control constructs idiomatic variation:** Modify how data structures are traversed or manipulated without changing their meaning (e.g., iterate using indices versus iterators), reorder data access operations when safe.\n\n7. **Whitespace and formatting changes:** Vary indentation schemes, line breaks, spacing, and grouping within the bounds of valid pseudocode formatting rules.\n\n8. **Preserve all conditional and loop boundaries, all method signatures, class structures, and hierarchy:** absolutely do not rename or alter function names, class names, or their positions in the object/class structure.\n\n9. **No removal or semantic simplification:** Avoid replacing logic with mathematically simplified or built-in shortcuts that would alter the algorithm\u2019s step-by-step structure or effect.\n\nThe goal is to produce pseudocode text that is syntactically, structurally, and stylistically radically different from the original input, while remaining provably behaviorally equivalent. Output only the pseudocode\u2014nothing else.",
  "score": 0.851942035579356,
  "feedback": "The following are 20 lines of original pseudocode of a random subset of the problems along with their modified pseudocodes.\n\nPseudocode for Problem 1:\nFUNCTION rounded_avg(p, q)\n    SWITCH\n        CASE q < p:\n            RETURN -1\n    END SWITCH\n    SET total_sum := 0\n    SET idx := p\n    WHILE idx <= q\n        total_sum := total_sum + idx\n        idx := idx + 1\n    END WHILE\n    SET count := q - p + 1\n    SET avg := total_sum / count\n    SET rounded_val := ROUND(avg)\n    SET bin_str := CONVERT_TO_BINARY(rounded_val)\n    RETURN bin_str\nEND FUNCTION\n\nModified Pseudocode for Problem 1:\n```\nFUNCTION rounded_avg(n, m)\n    IF m IS LESS THAN n\n        RETURN -1\n    SET summation TO 0\n    FOR each integer i FROM n TO m INCLUSIVE\n        INCREMENT summation BY i\n    SET average_value TO summation DIVIDED BY (m MINUS n PLUS 1)\n    SET rounded_average TO ROUND average_value TO NEAREST INTEGER\n    SET binary_representation TO BINARY FORMAT OF rounded_average\n    RETURN binary_representation\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 1:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmprc1q7evj/solution_0.py\", line 17, in <module>\\n    check(rounded_avg)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmprc1q7evj/solution_0.py\", line 16, in check\\n    assert candidate(1, 5) == \"0b11\"\\nAssertionError\\n']\n\nPseudocode for Problem 2:\nFUNCTION add(numbers_collection)\n    SET total_sum := 0\n    SET current_index := 1\n    WHILE current_index <= LENGTH(numbers_collection) DO\n        SET current_value := numbers_collection[current_index]\n        IF (current_value MOD 2) is equal to 0 THEN\n            total_sum := total_sum + current_value\n        END IF\n        current_index := current_index + 2\n    END WHILE\n    RETURN total_sum\nEND FUNCTION\n\nModified Pseudocode for Problem 2:\n```\nFUNCTION add(list_of_integers)\n    RETURN SUM OF ELEMENTS AT positions FROM 1 TO LENGTH OF list_of_integers STEP 2 WHERE ELEMENT IS EVEN\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 2:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp3r81bxar/solution_0.py\", line 15, in <module>\\n    check(add)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp3r81bxar/solution_0.py\", line 14, in check\\n    assert candidate([4, 88]) == 88\\nAssertionError\\n']\n\nPseudocode for Problem 3:\nFUNCTION count_nums(array_of_integers)  \n    FUNCTION digits_sum(number)  \n        SET factor TO 1  \n        IF number < 0 THEN  \n            SET number TO number * (-1)  \n            SET factor TO -1  \n        END IF  \n        SET digits_string TO CONVERT number TO STRING  \n        SET digits_list TO EMPTY LIST  \n        SET index TO 1  \n        WHILE index <= LENGTH OF digits_string  \n            SET char TO digits_string AT POSITION index  \n            SET digit TO CONVERT char TO INTEGER  \n            APPEND digit TO digits_list  \n            SET index TO index + 1  \n        END WHILE  \n        SET digits_list AT INDEX 1 TO digits_list AT INDEX 1 * factor  \n        SET total TO 0  \n        SET i TO 1  \n        WHILE i <= LENGTH OF digits_list  \n\nModified Pseudocode for Problem 3:\n```\nFUNCTION count_nums(array_of_integers)\n    FUNCTION digits_sum(integer_value)\n        SET sign_multiplier TO 1\n        IF integer_value LESS THAN 0\n            SET integer_value TO integer_value MULTIPLIED BY -1\n            SET sign_multiplier TO -1\n        END IF\n        SET list_of_digits TO CONVERT integer_value TO STRING THEN TO LIST OF INTEGERS\n        MULTIPLY list_of_digits AT INDEX 0 BY sign_multiplier\n        RETURN SUM OF list_of_digits\n    END FUNCTION\n\n    SET list_of_digit_sums TO EMPTY LIST\n    FOR each element IN array_of_integers\n        APPEND digits_sum(element) TO list_of_digit_sums\n    END FOR\n\n    SET filtered_list TO FILTER elements IN list_of_digit_sums WHERE element GREATER THAN 0\n    RETURN LENGTH OF filtered_list\n\nError(s) from the decoded code for Problem 3:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpw1xtpm0i/solution_1.py\", line 47, in <module>\\n    check(count_nums)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpw1xtpm0i/solution_1.py\", line 46, in check\\n    assert candidate([-1, -2, 0]) == 0\\nAssertionError\\n']\n\nPseudocode for Problem 4:\nFUNCTION sort_array(list_of_numbers)\n    SET intermediate_list TO array_of_integers\n    SET intermediate_list TO array_of_integers\n    SET temporary_list TO intermediate_list\n    SET temporary_list TO temporary_list\n    SET index_i TO 0\n    SET index_j TO 0\n    WHILE index_i < LENGTH(array_of_integers)\n        SET index_j TO index_i + 1\n        WHILE index_j < LENGTH(array_of_integers)\n            IF temporary_list[index_i] > temporary_list[index_j]\n                SET temp_value TO temporary_list[index_i]\n                SET temporary_list[index_i] TO temporary_list[index_j]\n                SET temporary_list[index_j] TO temp_value\n            END IF\n            SET index_j TO index_j + 1\n        END WHILE\n        SET index_i TO index_i + 1\n    END WHILE\n\n\nModified Pseudocode for Problem 4:\n```\nFUNCTION sort_array(array_of_integers)\n    SET sorted_array_based_on_decimal TO SORTED array_of_integers IN ASCENDING ORDER\n    SET final_sorted_array TO SORTED sorted_array_based_on_decimal USING KEY AS\n        COUNT OF '1' CHARACTERS IN BINARY REPRESENTATION OF element EXCLUDING THE '0b' PREFIX\n    RETURN final_sorted_array\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 4:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmppyw5uzk5/solution_0.py\", line 55, in <module>\\n    check(sort_array)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmppyw5uzk5/solution_0.py\", line 54, in check\\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\\nAssertionError\\n']\n\nPseudocode for Problem 5:\nFUNCTION max_element(list_of_elements)\n    SET count TO 0\n    SET max_candidate TO list_of_elements AT INDEX 0\n    WHILE count LESS THAN LENGTH OF list_of_elements\n        SET current_item TO list_of_elements AT INDEX count\n        IF current_item GREATER THAN max_candidate THEN\n            SET max_candidate TO current_item\n        ELSE\n            NO OPERATION\n        END IF\n        SET count TO count PLUS 1\n    END WHILE\n    RETURN max_candidate\nEND FUNCTION\n\nModified Pseudocode for Problem 5:\n```\nFUNCTION max_element(list_of_elements)\n    SET maximum_element TO list_of_elements AT INDEX 0\n    FOR each element IN list_of_elements\n        IF element IS GREATER THAN maximum_element\n            SET maximum_element TO element\n        END IF\n    END FOR\n    RETURN maximum_element\nEND FUNCTION\n```\n\nPseudocode for Problem 6:\nFUNCTION is_multiply_prime(x)\n    FUNCTION is_prime(y)\n        SET index TO 2\n        WHILE index <= y - 1\n            SET remainder TO y MODULO index\n            IF remainder == 0\n                RETURN False\n            SET index TO index + 1\n        END WHILE\n        RETURN True\n    END FUNCTION\n\n    SET m TO 2\n    WHILE m <= 100\n        IF is_prime(m) == False\n            SET m TO m + 1\n            CONTINUE\n        END IF\n        SET n TO 2\n        WHILE n <= 100\n\nModified Pseudocode for Problem 6:\n```\nFUNCTION is_multiply_prime(a)\n    FUNCTION is_prime(n)\n        FOR each integer j FROM 2 TO n MINUS 1\n            IF n MODULO j EQUALS 0\n                RETURN False\n        RETURN True\n    END FUNCTION\n\n    FOR each integer i FROM 2 TO 100\n        IF NOT is_prime(i)\n            CONTINUE TO NEXT i\n        FOR each integer j FROM 2 TO 100\n            IF NOT is_prime(j)\n                CONTINUE TO NEXT j\n            FOR each integer k FROM 2 TO 100\n                IF NOT is_prime(k)\n                    CONTINUE TO NEXT k\n                IF i MULTIPLIED BY j MULTIPLIED BY k EQUALS a\n                    RETURN True\n\nPseudocode for Problem 7:\nFUNCTION fruit_distribution(string_description, total_number_of_fruits)\n    INITIALIZE collected_numbers AS empty list\n    INITIALIZE index AS 0\n    INITIALIZE tokens AS SPLIT string_description BY space\n    WHILE index LESS THAN LENGTH of tokens\n        SET current_token TO tokens[index]\n        IF current_token IS a digit\n            SET numeric_value TO CONVERT current_token TO integer\n            APPEND numeric_value TO collected_numbers\n        END IF\n        INCREMENT index BY 1\n    END WHILE\n    INITIALIZE sum_of_numbers TO 0\n    INITIALIZE position TO 0\n    WHILE position LESS THAN LENGTH of collected_numbers\n        SET sum_of_numbers TO sum_of_numbers PLUS collected_numbers[position]\n        INCREMENT position BY 1\n    END WHILE\n    SET remaining_fruits TO total_number_of_fruits MINUS sum_of_numbers\n    RETURN remaining_fruits\n\nModified Pseudocode for Problem 7:\n```\nFUNCTION fruit_distribution(string_description, total_number_of_fruits)\n    SET list_of_numbers TO empty list\n    FOR each element IN SPLIT string_description BY space\n        IF element IS digit\n            APPEND integer value of element TO list_of_numbers\n    RETURN total_number_of_fruits MINUS SUM of list_of_numbers\nEND FUNCTION\n```\n\nPseudocode for Problem 8:\nFUNCTION intersection(interval1, interval2)\n    FUNCTION is_prime(number)\n        IF number == 0 OR number == 1 THEN\n            RETURN False\n        ELSE\n            IF number == 2 THEN\n                RETURN True\n            ELSE\n                SET divisor TO 2\n                WHILE divisor < number DO\n                    IF (number MOD divisor) == 0 THEN\n                        RETURN False\n                    END IF\n                    divisor := divisor + 1\n                END WHILE\n                RETURN True\n            END IF\n        END IF\n    END FUNCTION\n\n\nModified Pseudocode for Problem 8:\n```\nFUNCTION intersection(interval1, interval2)\n    FUNCTION is_prime(number)\n        IF number IS EQUAL TO 1 OR number IS EQUAL TO 0\n            RETURN False\n        END IF\n        IF number IS EQUAL TO 2\n            RETURN True\n        END IF\n        FOR each integer i FROM 2 TO number MINUS 1\n            IF number MODULO i IS EQUAL TO 0\n                RETURN False\n            END IF\n        END FOR\n        RETURN True\n    END FUNCTION\n\n    SET left_endpoint TO MAXIMUM OF interval1[0] AND interval2[0]\n    SET right_endpoint TO MINIMUM OF interval1[1] AND interval2[1]\n    SET intersection_length TO right_endpoint MINUS left_endpoint\nScore of Passing Rate - BLEU Score for ALL the problems: 0.851942035579356"
}