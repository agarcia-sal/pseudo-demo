{
  "prompt": "Rewrite the input pseudocode into a semantically equivalent version that preserves its exact functionality, original function names, class names, and their hierarchies without any modification. Your output must be exclusively pseudocode\u2014no explanations, comments, or additional text. Produce the rewritten pseudocode so that all logical operations, control flow constructs, data manipulations, and outcomes remain fully consistent with the original, but differ as extensively as possible in syntax, coding style, control structures, variable naming, ordering of computations, and overall structure. Employ alternative control flows (e.g., replace FOR loops with WHILE loops, conditionals with SWITCH or vice versa), use different idiomatic expressions and synonyms for constructs, restructure code blocks, rename variables comprehensively and systematically, and alter formatting and phrasing liberally\u2014while ensuring the algorithm\u2019s output and behavior are unchanged. Avoid simplifications that change the computational process or output values. The goal is to maximize syntactic and stylistic dissimilarity while guaranteeing perfect logical equivalence and unambiguous correctness. Output only the resulting pseudocode without any additional output or markdown formatting.",
  "response": "Rewrite the input pseudocode into a semantically equivalent version that preserves its exact functionality, original function names, class names, and their hierarchies without any modification. Your output must be exclusively pseudocode\u2014no explanations, comments, or additional text. Produce the rewritten pseudocode so that all logical operations, control flow constructs, data manipulations, and outcomes remain fully consistent with the original, but differ as extensively as possible in syntax, coding style, control structures, variable naming, ordering of computations, and overall structure. Employ alternative control flows (e.g., replace FOR loops with WHILE loops, conditionals with SWITCH or vice versa), use different idiomatic expressions and synonyms for constructs, restructure code blocks, rename variables comprehensively and systematically, and alter formatting and phrasing liberally\u2014while ensuring the algorithm\u2019s output and behavior are unchanged. Avoid simplifications that change the computational process or output values. The goal is to maximize syntactic and stylistic dissimilarity while guaranteeing perfect logical equivalence and unambiguous correctness. Output only the resulting pseudocode without any additional output or markdown formatting.",
  "score": 0.8079927759487434,
  "feedback": "The following are 20 lines of original pseudocode of a random subset of the problems along with their modified pseudocodes.\n\nPseudocode for Problem 1:\nFUNCTION fib(num)\n    SWITCH num\n        CASE 0:\n            RETURN 0\n        CASE 1:\n            RETURN 1\n        DEFAULT:\n            SET a TO num MINUS 1\n            SET b TO num MINUS 2\n            RETURN fib(a) PLUS fib(b)\n    END SWITCH\nEND FUNCTION\n\nModified Pseudocode for Problem 1:\n```\nFUNCTION fib(integer_n)\n    IF integer_n IS EQUAL TO 0\n        RETURN 0\n    END IF\n    IF integer_n IS EQUAL TO 1\n        RETURN 1\n    END IF\n    RETURN fib(integer_n MINUS 1) PLUS fib(integer_n MINUS 2)\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 1:\n['  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp344goh53/solution_0.py\", line 5\\n    match num:\\n          ^\\nSyntaxError: invalid syntax\\n']\n\nPseudocode for Problem 2:\nFUNCTION rounded_avg(n, m)\n    IF n > m THEN\n        RETURN -1\n    ENDIF\n\n    total_sum = 0\n    counter = n\n    WHILE counter <= m DO\n        total_sum = total_sum + counter\n        counter = counter + 1\n    ENDWHILE\n\n    count_elements = (m - n) + 1\n    mean_value = total_sum / count_elements\n\n    rounded_val = ROUND(mean_value)\n\n    binary_str = TO_BINARY(rounded_val)\n\n    RETURN binary_str\n\nModified Pseudocode for Problem 2:\n```\nFUNCTION rounded_avg(n, m)\n    IF m IS LESS THAN n\n        RETURN -1\n    SET summation TO 0\n    FOR each integer i FROM n TO m INCLUSIVE\n        INCREMENT summation BY i\n    SET average_value TO summation DIVIDED BY (m MINUS n PLUS 1)\n    SET rounded_average TO ROUND average_value TO NEAREST INTEGER\n    SET binary_representation TO BINARY FORMAT OF rounded_average\n    RETURN binary_representation\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 2:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpr0_qneoh/solution_0.py\", line 22, in <module>\\n    check(rounded_avg)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpr0_qneoh/solution_0.py\", line 21, in check\\n    assert candidate(1, 5) == \"0b11\"\\nAssertionError\\n']\n\nPseudocode for Problem 3:\nFUNCTION add(input_list)\n    total_sum <- 0\n    index <- 1\n    WHILE index <= LENGTH(input_list) DO\n        current_element <- input_list[index]\n        SWITCH (current_element MOD 2)\n            CASE 0:\n                total_sum <- total_sum + current_element\n        END SWITCH\n        index <- index + 2\n    END WHILE\n    RETURN total_sum\nEND FUNCTION\n\nModified Pseudocode for Problem 3:\n```\nFUNCTION add(list_of_integers)\n    RETURN SUM OF ELEMENTS AT positions FROM 1 TO LENGTH OF list_of_integers STEP 2 WHERE ELEMENT IS EVEN\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 3:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmptp1jly8y/solution_0.py\", line 15, in <module>\\n    check(add)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmptp1jly8y/solution_0.py\", line 14, in check\\n    assert candidate([4, 88]) == 88\\nAssertionError\\n']\n\nPseudocode for Problem 4:\nFUNCTION solve(integer_N)\n    SET accumulator TO 0\n    SET digits_string TO CONVERT integer_N TO STRING\n    SET index TO 0\n    WHILE index < LENGTH OF digits_string\n        SET current_char TO CHARACTER AT POSITION index IN digits_string\n        SET numeric_value TO CONVERT current_char TO INTEGER\n        SET accumulator TO accumulator + numeric_value\n        SET index TO index + 1\n    END WHILE\n    SET full_binary TO CONVERT accumulator TO BINARY STRING\n    SET trimmed_binary TO SUBSTRING OF full_binary FROM POSITION 3 TO END\n    RETURN trimmed_binary\nEND FUNCTION\n\nModified Pseudocode for Problem 4:\n```\nFUNCTION solve(integer_N)\n    SET sum_of_digits TO 0\n    FOR each character_digit IN STRING REPRESENTATION OF integer_N\n        INCREMENT sum_of_digits BY INTEGER VALUE OF character_digit\n    SET binary_representation TO BINARY STRING OF sum_of_digits EXCLUDING THE FIRST TWO CHARACTERS\n    RETURN binary_representation\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 4:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpoqhb9d2c/solution_0.py\", line 16, in <module>\\n    check(solve)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpoqhb9d2c/solution_0.py\", line 15, in check\\n    assert candidate(150) == \"110\", \"Error\"\\nAssertionError: Error\\n']\n\nPseudocode for Problem 5:\nFUNCTION decimal_to_binary(num)\n    SET bin_repr TO CONVERT_TO_BINARY(num)\n    SET trimmed_bin TO EMPTY_STRING\n    SET idx TO 2\n    WHILE idx <= LENGTH(bin_repr)\n        SET trimmed_bin TO CONCATENATE(trimmed_bin, CHARACTER_AT(bin_repr, idx))\n        SET idx TO idx + 1\n    END WHILE\n    SET result TO CONCATENATE(\"db\", trimmed_bin, \"db\")\n    RETURN result\nEND FUNCTION\n\nModified Pseudocode for Problem 5:\n```\nFUNCTION decimal_to_binary(decimal_number)\n    RETURN CONCATENATE \"db\", SUBSTRING OF BINARY REPRESENTATION OF decimal_number FROM INDEX 2 TO END, AND \"db\"\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 5:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpv3n2cg9v/solution_0.py\", line 13, in <module>\\n    check(decimal_to_binary)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpv3n2cg9v/solution_0.py\", line 12, in check\\n    assert candidate(0) == \"db0db\"\\nAssertionError\\n']\n\nPseudocode for Problem 6:\nFUNCTION prod_signs(arr)\n    IF arr IS NOT DEFINED OR LENGTH(arr) = 0 THEN\n        RETURN None\n    END IF\n\n    DEFINE zero_found AS FALSE\n    DEFINE negatives_count AS 0\n\n    DEFINE idx AS 0\n    WHILE idx < LENGTH(arr) DO\n        IF arr[idx] = 0 THEN\n            zero_found = TRUE\n            BREAK\n        ELSE IF arr[idx] < 0 THEN\n            negatives_count = negatives_count + 1\n        END IF\n        idx = idx + 1\n    END WHILE\n\n    IF zero_found THEN\n\nModified Pseudocode for Problem 6:\n```\nFUNCTION prod_signs(array_of_integers)\n    IF array_of_integers IS EMPTY\n        RETURN None\n    END IF\n    IF array_of_integers CONTAINS 0\n        SET sign_product TO 0\n    ELSE\n        SET count_of_negative_numbers TO LENGTH OF FILTERED ELEMENTS LESS THAN 0 IN array_of_integers\n        SET sign_product TO (-1) RAISED TO THE POWER OF count_of_negative_numbers\n    END IF\n    SET sum_of_magnitudes TO SUM OF ABSOLUTE VALUES OF EACH ELEMENT IN array_of_integers\n    RETURN sign_product MULTIPLIED BY sum_of_magnitudes\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 6:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpq33uahjq/solution_0.py\", line 28, in <module>\\n    check(prod_signs)\\nNameError: name \\'prod_signs\\' is not defined\\n']\n\nPseudocode for Problem 7:\nFUNCTION incr_list(sequence)\n    SET result_sequence TO empty list\n    SET index TO 0\n    WHILE index < LENGTH(sequence) DO\n        SET current_item TO sequence[index]\n        APPEND (current_item + 1) TO result_sequence\n        SET index TO index + 1\n    END WHILE\n    RETURN result_sequence\nEND FUNCTION\n\nModified Pseudocode for Problem 7:\n```\nFUNCTION incr_list(list_of_elements)\n    RETURN new_list WHERE each element IS element PLUS 1 FOR each element IN list_of_elements\nEND FUNCTION\n```\n\nPseudocode for Problem 8:\nFUNCTION smallest_change(array_of_integers)\n    SET count_diff TO 0\n    SET length_val TO LENGTH OF array_of_integers\n    SET midpoint TO length_val / 2\n    SET iterator TO 0\n    WHILE iterator < midpoint\n        SET front_element TO array_of_integers[iterator]\n        SET rear_element TO array_of_integers[length_val - iterator - 1]\n        SWITCH front_element == rear_element\n            CASE TRUE:\n                # do nothing\n            CASE FALSE:\n                SET count_diff TO count_diff + 1\n        END SWITCH\n        SET iterator TO iterator + 1\n    END WHILE\n    RETURN count_diff\nEND FUNCTION\n\nModified Pseudocode for Problem 8:\n```\nFUNCTION smallest_change(array_of_integers)\n    SET answer TO 0\n    FOR index FROM 0 TO LENGTH OF array_of_integers DIVIDED BY 2 MINUS 1\n        IF element AT index IN array_of_integers IS NOT EQUAL TO element AT (LENGTH OF array_of_integers MINUS index MINUS 1) IN array_of_integers\n            INCREMENT answer BY 1\n    RETURN answer\nEND FUNCTION\n```\nScore of Passing Rate - BLEU Score for ALL the problems: 0.8079927759487434"
}