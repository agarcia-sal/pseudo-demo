```
FUNCTION prod_signs(sequence_of_values)
    IF NOT (sequence_of_values IS NOT EMPTY) THEN
        RETURN None
    END IF

    sign_product := 1
    found_zero_flag := False
    
    index_counter := 0
    ELEMENT_LOOP: WHILE index_counter < LENGTH OF sequence_of_values
        current_element := sequence_of_values.at(index_counter)
        IF current_element EQUALS 0 THEN
            found_zero_flag := True
            BREAK ELEMENT_LOOP
        END IF
        index_counter := index_counter + 1
    END WHILE

    IF found_zero_flag THEN
        sign_product := 0
    ELSE
        negative_counter := 0
        cursor := 0
        NEGATIVE_COUNT_LOOP: REPEAT
            IF cursor >= LENGTH OF sequence_of_values THEN
                EXIT NEGATIVE_COUNT_LOOP
            END IF
            inspected_value := sequence_of_values.at(cursor)
            IF inspected_value < 0 THEN
                negative_counter := negative_counter + 1
            END IF
            cursor := cursor + 1
        UNTIL FALSE
        power_base := -1
        exponent := negative_counter
        sign_product := 1
        counter_var := 0
        POWER_LOOP: REPEAT
            IF counter_var >= exponent THEN
                EXIT POWER_LOOP
            END IF
            sign_product := sign_product * power_base
            counter_var := counter_var + 1
        UNTIL FALSE
    END IF

    sum_magnitude := 0
    position := 0
    MAGNITUDE_SUM_LOOP: FOR position FROM 0 TO LENGTH OF sequence_of_values - 1 STEP 1
        element_value := sequence_of_values.at(position)
        absolute_value := element_value
        IF element_value < 0 THEN
            absolute_value := (-1) * element_value
        END IF
        sum_magnitude := sum_magnitude + absolute_value
    END FOR

    result := sign_product * sum_magnitude
    RETURN result
END FUNCTION
```