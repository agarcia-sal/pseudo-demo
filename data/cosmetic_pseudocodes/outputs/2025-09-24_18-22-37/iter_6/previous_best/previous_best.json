{
  "prompt": "Rewrite the given pseudocode into a functionally identical version that preserves all behavior, outputs, and algorithmic effects exactly as in the original, including the same function names, class names, and the exact class-object hierarchies. The output must be solely pseudocode text\u2014no explanations, comments, annotations, or formatting other than what is required for valid pseudocode.\n\nTo maximize structural and stylistic divergence while guaranteeing semantic equivalence, strictly apply the following transformations throughout the entire pseudocode:\n\n- Systematically rename every variable and parameter to new, consistent identifiers unrelated to originals.\n- Replace all control flow constructs with alternative equivalent forms, e.g., convert FOR loops to WHILE loops or vice versa, transform IF statements to SWITCH/CASE or nested IF/ELSE chains, employ early returns and guard clauses instead of nested blocks, or vice versa.\n- Rearrange independent statements or logically commutative computations to different orders without affecting outcome.\n- Rewrite expressions by decomposing complex operations into sequences of simpler steps or by consolidating multiple steps, ensuring no change in logic.\n- Use synonymous or alternative idiomatic phrasing for assignments, logical/comparison operators, arithmetic operations, and data access; e.g., replace \u201c=\u201d with \u201c:=\u201d or wording like \u201cis equal to\u201d with other clear equivalences.\n- Alter formatting aspects extensively (indentation style, line breaks, spacing) within valid pseudocode syntax constraints.\n- Preserve all operations, conditions, and computations exactly with no omissions, additions, or semantic shortcuts.\n- Retain original function and class signatures with exact names and hierarchy; do not change these identifiers or structural relationships.\n- Output only the rewritten pseudocode plain text exactly as pseudocode\u2014no markdown code fences or extra text.\n\nThe goal is to produce a maximally syntactically and stylistically distinct pseudocode that is provably behaviorally equivalent, suitable for thorough obfuscation and diversity in representation tasks.",
  "response": "Rewrite the given pseudocode into a functionally identical version that preserves all behavior, outputs, and algorithmic effects exactly as in the original, including the same function names, class names, and the exact class-object hierarchies. The output must be solely pseudocode text\u2014no explanations, comments, annotations, or formatting other than what is required for valid pseudocode.\n\nTo maximize structural and stylistic divergence while guaranteeing semantic equivalence, strictly apply the following transformations throughout the entire pseudocode:\n\n- Systematically rename every variable and parameter to new, consistent identifiers unrelated to originals.\n- Replace all control flow constructs with alternative equivalent forms, e.g., convert FOR loops to WHILE loops or vice versa, transform IF statements to SWITCH/CASE or nested IF/ELSE chains, employ early returns and guard clauses instead of nested blocks, or vice versa.\n- Rearrange independent statements or logically commutative computations to different orders without affecting outcome.\n- Rewrite expressions by decomposing complex operations into sequences of simpler steps or by consolidating multiple steps, ensuring no change in logic.\n- Use synonymous or alternative idiomatic phrasing for assignments, logical/comparison operators, arithmetic operations, and data access; e.g., replace \u201c=\u201d with \u201c:=\u201d or wording like \u201cis equal to\u201d with other clear equivalences.\n- Alter formatting aspects extensively (indentation style, line breaks, spacing) within valid pseudocode syntax constraints.\n- Preserve all operations, conditions, and computations exactly with no omissions, additions, or semantic shortcuts.\n- Retain original function and class signatures with exact names and hierarchy; do not change these identifiers or structural relationships.\n- Output only the rewritten pseudocode plain text exactly as pseudocode\u2014no markdown code fences or extra text.\n\nThe goal is to produce a maximally syntactically and stylistically distinct pseudocode that is provably behaviorally equivalent, suitable for thorough obfuscation and diversity in representation tasks.",
  "score": 0.839976109025414,
  "feedback": "The following are 20 lines of original pseudocode of a random subset of the problems along with their modified pseudocodes.\n\nPseudocode for Problem 1:\nFUNCTION get_row(matrix_array, key_number)\n  SET position_list := []\n  SET outer_counter := 0\n  WHILE outer_counter <= LENGTH(matrix_array) - 1\n    SET inner_counter := 0\n    WHILE inner_counter <= LENGTH(matrix_array[outer_counter]) - 1\n      SET current_value := matrix_array[outer_counter][inner_counter]\n      IF current_value == key_number THEN\n        CALL position_list.APPEND((outer_counter, inner_counter))\n      END IF\n      SET inner_counter := inner_counter + 1\n    END WHILE\n    SET outer_counter := outer_counter + 1\n  END WHILE\n\n  SET temp_list := []\n  SET temp_counter := 0\n  WHILE temp_counter <= LENGTH(position_list) - 1\n    SET temp_index := temp_counter\n    WHILE temp_index < LENGTH(position_list)\n\nModified Pseudocode for Problem 1:\n```\nFUNCTION get_row(two_dimensional_list, target_integer)\n    SET coordinates TO EMPTY LIST\n    FOR each row_index FROM 0 TO LENGTH OF two_dimensional_list MINUS 1\n        FOR each column_index FROM 0 TO LENGTH OF two_dimensional_list AT row_index MINUS 1\n            IF two_dimensional_list AT row_index AT column_index EQUALS target_integer\n                APPEND TUPLE(row_index, column_index) TO coordinates\n    SET coordinates TO coordinates SORTED BY SECOND ELEMENT IN DESCENDING ORDER\n    SET coordinates TO coordinates SORTED BY FIRST ELEMENT IN ASCENDING ORDER\n    RETURN coordinates\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 1:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpnyku15z0/solution_0.py\", line 45, in <module>\\n    check(get_row)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpnyku15z0/solution_0.py\", line 40, in check\\n    assert candidate([\\nAssertionError\\n']\n\nPseudocode for Problem 2:\nFUNCTION rounded_avg(p, q)\n    IF q < p THEN\n        RETURN -1\n    END IF\n    SET total_sum := 0\n    SET index := p\n    WHILE index <= q DO\n        total_sum := total_sum + index\n        index := index + 1\n    END WHILE\n    SET count := q - p + 1\n    SET avg := total_sum / count\n    SET rounded_val := ROUND(avg)\n    SET binary_str := TO_BINARY(rounded_val)\n    RETURN binary_str\nEND FUNCTION\n\nModified Pseudocode for Problem 2:\n```\nFUNCTION rounded_avg(n, m)\n    IF m IS LESS THAN n\n        RETURN -1\n    SET summation TO 0\n    FOR each integer i FROM n TO m INCLUSIVE\n        INCREMENT summation BY i\n    SET average_value TO summation DIVIDED BY (m MINUS n PLUS 1)\n    SET rounded_average TO ROUND average_value TO NEAREST INTEGER\n    SET binary_representation TO BINARY FORMAT OF rounded_average\n    RETURN binary_representation\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 2:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpj4e78dci/solution_0.py\", line 17, in <module>\\n    check(rounded_avg)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpj4e78dci/solution_0.py\", line 16, in check\\n    assert candidate(1, 5) == \"0b11\"\\nAssertionError\\n']\n\nPseudocode for Problem 3:\nFUNCTION sort_array(original_list)\n  SET intermediate_sorted_list TO original_list\n  SET index_counter TO 0\n  WHILE index_counter < LENGTH original_list\n    SET current_value TO original_list[index_counter]\n    SET position TO 0\n    WHILE position < index_counter AND intermediate_sorted_list[position] <= current_value\n      SET position TO position + 1\n    END WHILE\n    SET shift_index TO index_counter\n    WHILE shift_index > position\n      SET intermediate_sorted_list[shift_index] TO intermediate_sorted_list[shift_index - 1]\n      SET shift_index TO shift_index - 1\n    END WHILE\n    SET intermediate_sorted_list[position] TO current_value\n    SET index_counter TO index_counter + 1\n  END WHILE\n\n  SET length_of_list TO LENGTH intermediate_sorted_list\n  SET outer_index TO 0\n\nModified Pseudocode for Problem 3:\n```\nFUNCTION sort_array(array_of_integers)\n    SET sorted_array_based_on_decimal TO SORTED array_of_integers IN ASCENDING ORDER\n    SET final_sorted_array TO SORTED sorted_array_based_on_decimal USING KEY AS\n        COUNT OF '1' CHARACTERS IN BINARY REPRESENTATION OF element EXCLUDING THE '0b' PREFIX\n    RETURN final_sorted_array\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 3:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmplp5zbc9v/solution_0.py\", line 63, in <module>\\n    check(sort_array)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmplp5zbc9v/solution_0.py\", line 62, in check\\n    assert candidate([-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\\nAssertionError\\n']\n\nPseudocode for Problem 4:\nFUNCTION car_race_collision(integer_number_of_cars)\n    DECLARE integer_beta\n    integer_beta := 1\n    DECLARE integer_gamma\n    integer_gamma := integer_number_of_cars\n    integer_delta := 0\n    WHILE integer_delta LESS THAN 1\n        integer_beta := integer_beta * integer_gamma\n        integer_delta := integer_delta + 1\n    END WHILE\n    RETURN integer_beta\nEND FUNCTION\n\nModified Pseudocode for Problem 4:\n```\nFUNCTION car_race_collision(integer_number_of_cars)\n    RETURN integer_number_of_cars RAISED TO THE POWER OF 2\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 4:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp_7cqx72q/solution_0.py\", line 12, in <module>\\n    check(car_race_collision)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp_7cqx72q/solution_0.py\", line 11, in check\\n    assert candidate(2) == 4\\nAssertionError\\n']\n\nPseudocode for Problem 5:\nFUNCTION concatenate(array_of_texts)\n    SET index_counter := 1\n    SET combined_text := \"\"\n    WHILE index_counter <= LENGTH(array_of_texts)\n        SET current_string := array_of_texts[index_counter]\n        SET combined_text := combined_text + current_string\n        SET index_counter := index_counter + 1\n    END WHILE\n    RETURN combined_text\nEND FUNCTION\n\nModified Pseudocode for Problem 5:\n```\nFUNCTION concatenate(list_of_strings)\n    RETURN concatenation OF all elements IN list_of_strings\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 5:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp4j7ryli6/solution_1.py\", line 14, in <module>\\n    check(concatenate)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp4j7ryli6/solution_1.py\", line 13, in check\\n    assert candidate([\\'x\\', \\'y\\', \\'z\\']) == \\'xyz\\'\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp4j7ryli6/solution_1.py\", line 8, in concatenate\\n    current_string: str = array_of_texts[index_counter]\\nIndexError: list index out of range\\n']\n\nPseudocode for Problem 6:\nFUNCTION starts_one_ends(integer_x)\n    IF integer_x IS NOT 1 THEN\n        SET exponent_val TO integer_x MINUS 2\n        SET power_result TO 10\n        SET counter TO 1\n        WHILE counter LESS THAN exponent_val DO\n            power_result := power_result MULTIPLIED BY 10\n            counter := counter PLUS 1\n        END WHILE\n        RETURN 18 MULTIPLIED BY power_result\n    ELSE\n        RETURN 1\n    END IF\nEND FUNCTION\n\nModified Pseudocode for Problem 6:\n```\nFUNCTION starts_one_ends(integer_n)\n    IF integer_n EQUALS 1\n        RETURN 1\n    END IF\n    RETURN 18 MULTIPLIED BY (10 RAISED TO THE POWER OF (integer_n MINUS 2))\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 6:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpyyaro3v9/solution_0.py\", line 15, in <module>\\n    check(starts_one_ends)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpyyaro3v9/solution_0.py\", line 14, in check\\n    assert candidate(2) == 18\\nAssertionError\\n']\n\nPseudocode for Problem 7:\nFUNCTION solve(integer_N)\n    LET accumulator := 0\n    LET digit_list := CONVERT integer_N TO STRING\n    LET index := 0\n    WHILE index IS LESS THAN LENGTH OF digit_list\n        LET current_char := digit_list[index]\n        LET numeric_value := CONVERT current_char TO INTEGER\n        accumulator := accumulator + numeric_value\n        index := index + 1\n    END WHILE\n    LET full_binary_string := CONVERT accumulator TO BINARY STRING\n    LET result_str := SUBSTRING full_binary_string FROM POSITION 3 TO END\n    RETURN result_str\nEND FUNCTION\n\nModified Pseudocode for Problem 7:\n```\nFUNCTION solve(integer_N)\n    SET sum_of_digits TO 0\n    FOR each character_digit IN STRING REPRESENTATION OF integer_N\n        INCREMENT sum_of_digits BY INTEGER VALUE OF character_digit\n    SET binary_representation TO BINARY STRING OF sum_of_digits EXCLUDING THE FIRST TWO CHARACTERS\n    RETURN binary_representation\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 7:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpcpbfrhbq/solution_0.py\", line 16, in <module>\\n    check(solve)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpcpbfrhbq/solution_0.py\", line 15, in check\\n    assert candidate(150) == \"110\", \"Error\"\\nAssertionError: Error\\n']\n\nPseudocode for Problem 8:\nFUNCTION rescale_to_unit(list_of_numbers)\n    SET idx TO 0\n    SET length TO LENGTH OF list_of_numbers\n    SET current_min TO list_of_numbers[0]\n    SET current_max TO list_of_numbers[0]\n\n    WHILE idx LESS THAN length\n        IF list_of_numbers[idx] LESS THAN current_min THEN\n            current_min := list_of_numbers[idx]\n        ELSE\n            IF list_of_numbers[idx] GREATER THAN current_max THEN\n                current_max := list_of_numbers[idx]\n            END IF\n        END IF\n        idx := idx + 1\n    END WHILE\n\n    SET output_list TO EMPTY LIST\n    SET pos TO 0\n\n\nModified Pseudocode for Problem 8:\n```\nFUNCTION rescale_to_unit(list_of_numbers)\n    SET minimum_number TO MINIMUM VALUE IN list_of_numbers\n    SET maximum_number TO MAXIMUM VALUE IN list_of_numbers\n    RETURN LIST OF (each_number MINUS minimum_number) DIVIDED BY (maximum_number MINUS minimum_number) FOR each_number IN list_of_numbers\nEND FUNCTION\n```\nScore of Passing Rate - BLEU Score for ALL the problems: 0.839976109025414"
}