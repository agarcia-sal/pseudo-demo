```
FUNCTION find_closest_elements(collection_of_values)
    SET best_pair_result TO None
    SET smallest_gap TO None
    SET outer_idx TO 0

    WHILE outer_idx < LENGTH(collection_of_values)
        SET current_outer_value TO collection_of_values.at(outer_idx)
        SET inner_idx TO 0

        WHILE inner_idx < LENGTH(collection_of_values)
            SET current_inner_value TO collection_of_values.at(inner_idx)

            SWITCH TRUE
                CASE outer_idx EQUAL TO inner_idx:
                    BREAK
                CASE smallest_gap IS None:
                    SET gap_measure TO current_outer_value MINUS current_inner_value
                    SET gap_measure TO gap_measure IF gap_measure >= 0 ELSE -gap_measure
                    SET smallest_gap TO gap_measure
                    SET best_pair_result TO (current_outer_value, current_inner_value)
                    CALL best_pair_result = (MIN(best_pair_result[0], best_pair_result[1]), MAX(best_pair_result[0], best_pair_result[1]))
                    BREAK
                DEFAULT:
                    SET computed_gap TO current_inner_value MINUS current_outer_value
                    SET computed_gap TO computed_gap IF computed_gap >= 0 ELSE -computed_gap
                    IF computed_gap < smallest_gap
                        SET smallest_gap TO computed_gap
                        SET best_pair_result TO (current_outer_value, current_inner_value)
                        CALL best_pair_result = (MIN(best_pair_result[0], best_pair_result[1]), MAX(best_pair_result[0], best_pair_result[1]))
                    END IF
            END SWITCH

            INCREMENT inner_idx BY 1
        END WHILE
        INCREMENT outer_idx BY 1
    END WHILE

    RETURN best_pair_result
END FUNCTION
```