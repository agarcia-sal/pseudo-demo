{
  "prompt": "Rewrite the input pseudocode into a new version that is behaviorally indistinguishable from the original: it must replicate all outputs, side effects, control flow, logic, and intermediate computations exactly, under every possible input, with zero difference in semantics. Preserve every function name, class name, and the full class-object hierarchy intact \u2014 do not rename or reorder them.\n\nYour output must be solely valid pseudocode text with no explanations, comments, annotations, markdown formatting, or any extraneous content.\n\nTo maximize syntactic, structural, and stylistic divergence while maintaining perfect functional equivalence, apply *all* of the following transformations comprehensively and consistently throughout the pseudocode, mixing them intelligently to increase complexity of difference:\n\n1. **Systematic renaming of all local variables and parameters:**  \n   Generate fresh, unrelated names for each variable and parameter, keeping naming consistent everywhere they appear, but strictly exclude any global identifiers like function/class names.\n\n2. **Robust control flow reshaping:**  \n   - Transform loops:  \n     *Convert* FOR-loops into WHILE-loops with equivalent logic and *vice versa*, using entry and exit conditions, loop increments, or iterators creatively.  \n   - Modify conditionals: interchange IF-ELSE chains with SWITCH-CASE; flatten nested conditions into guard clauses or introduce nested conditions to deepen logic; reorder logically independent branches.  \n   - Use early returns or combine them into single exit points as long as no semantics change occurs.\n\n3. **Reordering of independent statements and computations:**  \n   Identify expressions and statements with no interdependencies and reorder them arbitrarily to alter flow order without affecting semantics.\n\n4. **Expression transformation:**  \n   - Expand complex expressions into multiple simpler intermediate assignments or consolidate several simple assignments into compound expressions using temporary variables.  \n   - Replace arithmetic and logical operators with alternative synonyms and formulations (e.g., \u201cplus\u201d, \u201cincrement by\u201d, \u201cnot equal to\u201d instead of \u201c!=\u201d, \u201c\u2227\u201d instead of \u201cAND\u201d), consistently, including data access syntax variations (e.g., array[index] \u2194 array.at(index) if defined).  \n   - Change numeric literals\u2019 representation if valid (e.g., `0b101` \u2194 `5`) only if behaviorally safe and exact.\n\n5. **Data structure and iteration idioms variation:**  \n   Swap index-based loops with element-based iterations and vice versa; traverse data structures in different logically equivalent ways; reorder independent data accesses within safe bounds.\n\n6. **Preservation constraints:**  \n   - Do *not* rename or reorder function names, class names, or their hierarchical positions.  \n   - Maintain all loop and conditional boundaries and method signatures exactly.  \n   - Avoid any semantic simplification or shortcutting that alters the algorithm\u2019s stepwise behavior, including avoiding replacing explicit multiple steps with built-in or library shortcuts.\n\n7. **Whitespace and formatting variety:**  \n   Randomize indentation styles, line breaks, grouping, and spacing within valid pseudocode formatting, including inlining trivial statements or expanding single-line statements into multi-line forms.\n\n8. **Normalization and consistent aliasing:**  \n   When your transformation introduces new temporary variables or helper constructs, ensure their usage is consistent, and no variable is reused ambiguously.\n\nYour resulting pseudocode should be structurally, lexically, and stylistically as different as possible from the input, but behaviorally provably equivalent in every aspect.\n\nOutput only the rewritten pseudocode text, nothing else.",
  "response": "Rewrite the input pseudocode into a new version that is behaviorally indistinguishable from the original: it must replicate all outputs, side effects, control flow, logic, and intermediate computations exactly, under every possible input, with zero difference in semantics. Preserve every function name, class name, and the full class-object hierarchy intact \u2014 do not rename or reorder them.\n\nYour output must be solely valid pseudocode text with no explanations, comments, annotations, markdown formatting, or any extraneous content.\n\nTo maximize syntactic, structural, and stylistic divergence while maintaining perfect functional equivalence, apply *all* of the following transformations comprehensively and consistently throughout the pseudocode, mixing them intelligently to increase complexity of difference:\n\n1. **Systematic renaming of all local variables and parameters:**  \n   Generate fresh, unrelated names for each variable and parameter, keeping naming consistent everywhere they appear, but strictly exclude any global identifiers like function/class names.\n\n2. **Robust control flow reshaping:**  \n   - Transform loops:  \n     *Convert* FOR-loops into WHILE-loops with equivalent logic and *vice versa*, using entry and exit conditions, loop increments, or iterators creatively.  \n   - Modify conditionals: interchange IF-ELSE chains with SWITCH-CASE; flatten nested conditions into guard clauses or introduce nested conditions to deepen logic; reorder logically independent branches.  \n   - Use early returns or combine them into single exit points as long as no semantics change occurs.\n\n3. **Reordering of independent statements and computations:**  \n   Identify expressions and statements with no interdependencies and reorder them arbitrarily to alter flow order without affecting semantics.\n\n4. **Expression transformation:**  \n   - Expand complex expressions into multiple simpler intermediate assignments or consolidate several simple assignments into compound expressions using temporary variables.  \n   - Replace arithmetic and logical operators with alternative synonyms and formulations (e.g., \u201cplus\u201d, \u201cincrement by\u201d, \u201cnot equal to\u201d instead of \u201c!=\u201d, \u201c\u2227\u201d instead of \u201cAND\u201d), consistently, including data access syntax variations (e.g., array[index] \u2194 array.at(index) if defined).  \n   - Change numeric literals\u2019 representation if valid (e.g., `0b101` \u2194 `5`) only if behaviorally safe and exact.\n\n5. **Data structure and iteration idioms variation:**  \n   Swap index-based loops with element-based iterations and vice versa; traverse data structures in different logically equivalent ways; reorder independent data accesses within safe bounds.\n\n6. **Preservation constraints:**  \n   - Do *not* rename or reorder function names, class names, or their hierarchical positions.  \n   - Maintain all loop and conditional boundaries and method signatures exactly.  \n   - Avoid any semantic simplification or shortcutting that alters the algorithm\u2019s stepwise behavior, including avoiding replacing explicit multiple steps with built-in or library shortcuts.\n\n7. **Whitespace and formatting variety:**  \n   Randomize indentation styles, line breaks, grouping, and spacing within valid pseudocode formatting, including inlining trivial statements or expanding single-line statements into multi-line forms.\n\n8. **Normalization and consistent aliasing:**  \n   When your transformation introduces new temporary variables or helper constructs, ensure their usage is consistent, and no variable is reused ambiguously.\n\nYour resulting pseudocode should be structurally, lexically, and stylistically as different as possible from the input, but behaviorally provably equivalent in every aspect.\n\nOutput only the rewritten pseudocode text, nothing else.",
  "score": 0.8583075894453074,
  "feedback": "The following are 20 lines of original pseudocode of a random subset of the problems along with their modified pseudocodes.\n\nPseudocode for Problem 1:\nFUNCTION minPath(grid, p)\n   SET q TO LENGTH OF grid\n   SET r TO q TIMES q PLUS 1\n   SET s TO 0\n   WHILE s LESS THAN q\n     SET t TO 0\n     WHILE t LESS THAN q\n       SWITCH grid.at(s).at(t)\n         CASE 1:\n           SET u TO EMPTY LIST\n           IF s GREATER THAN 0 THEN\n             APPEND grid.at(s MINUS 1).at(t) TO u\n           END IF\n           IF t GREATER THAN 0 THEN\n             APPEND grid.at(s).at(t MINUS 1) TO u\n           END IF\n           IF s LESS THAN q MINUS 1 THEN\n             APPEND grid.at(s PLUS 1).at(t) TO u\n           END IF\n           IF t LESS THAN q MINUS 1 THEN\n\nModified Pseudocode for Problem 1:\n```\nFUNCTION minPath(grid, k)\n    SET n TO LENGTH OF grid\n    SET val TO n TIMES n PLUS 1\n    FOR i FROM 0 TO n MINUS 1\n        FOR j FROM 0 TO n MINUS 1\n            IF grid AT i AND j EQUALS 1\n                SET temporary_list TO EMPTY LIST\n                IF i NOT EQUAL TO 0\n                    APPEND grid AT i MINUS 1 AND j TO temporary_list\n                END IF\n                IF j NOT EQUAL TO 0\n                    APPEND grid AT i AND j MINUS 1 TO temporary_list\n                END IF\n                IF i NOT EQUAL TO n MINUS 1\n                    APPEND grid AT i PLUS 1 AND j TO temporary_list\n                END IF\n                IF j NOT EQUAL TO n MINUS 1\n                    APPEND grid AT i AND j PLUS 1 TO temporary_list\n                END IF\n\nError(s) from the decoded code for Problem 1:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp_vjz49xy/solution_3.py\", line 50, in <module>\\n    check(minPath)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp_vjz49xy/solution_3.py\", line 49, in check\\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7) == [1, 10, 1, 10, 1, 10, 1]\\nAssertionError\\n']\n\nPseudocode for Problem 2:\nFUNCTION choose_num(alpha, beta)  \n    IF alpha EQUALS beta  \n        RETURN -1  \n    END IF  \n    IF beta MODULO 2 EQUALS 0  \n        RETURN beta  \n    END IF  \n    IF alpha GREATER THAN beta  \n        RETURN -1  \n    END IF  \n    VAR epsilon = beta PLUS -1  \n    RETURN epsilon  \nEND FUNCTION\n\nModified Pseudocode for Problem 2:\n```\nFUNCTION choose_num(x, y)\n    IF x GREATER THAN y\n        RETURN -1\n    END IF\n    IF y MODULO 2 EQUALS 0\n        RETURN y\n    END IF\n    IF x EQUALS y\n        RETURN -1\n    END IF\n    RETURN y MINUS 1\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 2:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpdkfky6pk/solution_1.py\", line 13, in <module>\\n    check(choose_num)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpdkfky6pk/solution_1.py\", line 12, in check\\n    assert candidate(13, 12) == -1\\nAssertionError\\n']\n\nPseudocode for Problem 3:\nFUNCTION strange_sort_list(array_of_numbers)\n   SET output_array TO []\n   SET toggle TO False\n   WHILE (array_of_numbers.length > 0)\n      SET toggle TO NOT toggle\n      SWITCH toggle\n         CASE False:\n            SET lowest_value TO array_of_numbers.at(0)\n            SET index_of_lowest TO 0\n            SET counter_i TO 1\n            WHILE counter_i < array_of_numbers.length\n               IF array_of_numbers.at(counter_i) < lowest_value\n                  SET lowest_value TO array_of_numbers.at(counter_i)\n                  SET index_of_lowest TO counter_i\n               END IF\n               SET counter_i TO counter_i + 1\n            END WHILE\n            output_array.append(lowest_value)\n            array_of_numbers.remove_at(index_of_lowest)\n            BREAK\n\nModified Pseudocode for Problem 3:\n```\nFUNCTION strange_sort_list(list_of_integers)\n    SET result_list TO empty list\n    SET selection_flag TO True\n    WHILE list_of_integers IS NOT empty\n        IF selection_flag IS True\n            APPEND minimum VALUE IN list_of_integers TO result_list\n        ELSE\n            APPEND maximum VALUE IN list_of_integers TO result_list\n        END IF\n        REMOVE last APPENDED VALUE FROM list_of_integers\n        SET selection_flag TO negation OF selection_flag\n    END WHILE\n    RETURN result_list\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 3:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpcbobccf8/solution_0.py\", line 30, in <module>\\n    check(strange_sort_list)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpcbobccf8/solution_0.py\", line 29, in check\\n    assert candidate([1, 2, 3, 4]) == [1, 4, 2, 3]\\nAssertionError\\n']\n\nPseudocode for Problem 4:\nFUNCTION add(collection_of_numbers)\n  SET accumulator TO 0\n  SET current_index TO 1\n  SET max_index TO LENGTH OF collection_of_numbers\n  \n  WHILE current_index \u2264 max_index DO\n      SET element_value TO collection_of_numbers.at(current_index)\n      IF (element_value MOD 2) = 0 THEN\n          SET accumulator TO accumulator PLUS element_value\n      END IF\n      SET current_index TO current_index PLUS 2\n  END WHILE\n  \n  RETURN accumulator\nEND FUNCTION\n\nModified Pseudocode for Problem 4:\n```\nFUNCTION add(list_of_integers)\n    RETURN SUM OF ELEMENTS AT positions FROM 1 TO LENGTH OF list_of_integers STEP 2 WHERE ELEMENT IS EVEN\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 4:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpn_elfqc8/solution_0.py\", line 19, in <module>\\n    check(add)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpn_elfqc8/solution_0.py\", line 18, in check\\n    assert candidate([4, 88]) == 88\\nAssertionError\\n']\n\nPseudocode for Problem 5:\nFUNCTION triples_sum_to_zero(sequence_of_numbers)  \n    SET primary_pointer = 0  \n    WHILE primary_pointer LESS THAN (LENGTH OF sequence_of_numbers MINUS 1)  \n        SET secondary_pointer = primary_pointer PLUS 1  \n        WHILE secondary_pointer LESS THAN (LENGTH OF sequence_of_numbers MINUS 1)  \n            SET tertiary_pointer = secondary_pointer PLUS 1  \n            WHILE tertiary_pointer LESS THAN (LENGTH OF sequence_of_numbers MINUS 1)  \n                SET first_value = sequence_of_numbers.at(primary_pointer)  \n                SET second_value = sequence_of_numbers.at(secondary_pointer)  \n                SET third_value = sequence_of_numbers.at(tertiary_pointer)  \n                SET sum_of_three = first_value PLUS second_value PLUS third_value  \n                IF sum_of_three EQUALS 0 THEN  \n                    RETURN True  \n                END IF  \n                SET tertiary_pointer = tertiary_pointer PLUS 1  \n            END WHILE  \n            INCREMENT secondary_pointer BY 1  \n        END WHILE  \n        SET primary_pointer = primary_pointer PLUS 1  \n    END WHILE  \n\nModified Pseudocode for Problem 5:\n```\nFUNCTION triples_sum_to_zero(list_of_integers)\n    FOR index_i FROM 0 TO LENGTH OF list_of_integers MINUS 1\n        FOR index_j FROM index_i PLUS 1 TO LENGTH OF list_of_integers MINUS 1\n            FOR index_k FROM index_j PLUS 1 TO LENGTH OF list_of_integers MINUS 1\n                IF list_of_integers AT index_i PLUS list_of_integers AT index_j PLUS list_of_integers AT index_k EQUALS 0\n                    RETURN True\n    RETURN False\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 5:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp5m69pdp5/solution_2.py\", line 26, in <module>\\n    check(triples_sum_to_zero)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp5m69pdp5/solution_2.py\", line 25, in check\\n    assert candidate([1, 3, -2, 1]) == True\\nAssertionError\\n']\n\nPseudocode for Problem 6:\nFUNCTION is_prime(value)  \n  IF NOT (value GREATER THAN OR EQUAL TO 2) THEN  \n    RETURN False  \n  END IF  \n\n  SET index = 2  \n  WHILE index LESS THAN (value MINUS 1) DO  \n    SET remainder_check = value MODULO index  \n    IF remainder_check EQUALS 0 THEN  \n      RETURN False  \n    END IF  \n    SET index = index PLUS 1  \n  END WHILE  \n\n  RETURN True  \nEND FUNCTION\n\nModified Pseudocode for Problem 6:\n```\nFUNCTION is_prime(number)\n    IF number LESS THAN 2\n        RETURN False\n    END IF\n    FOR each divisor FROM 2 TO number MINUS 2\n        IF number MODULO divisor EQUALS 0\n            RETURN False\n        END IF\n    END FOR\n    RETURN True\nEND FUNCTION\n```\n\nPseudocode for Problem 7:\nFUNCTION parse_nested_parens(parentheses_string)\n  FUNCTION parse_paren_group(group_string)\n    SET depth_counter TO 0\n    SET max_reached_depth TO 0\n    SET index_tracker TO 0\n    WHILE index_tracker LESS THAN LENGTH(group_string)\n      SET current_char TO group_string.at(index_tracker)\n      IF current_char EQUALS '(' THEN\n        SET depth_counter TO depth_counter PLUS 1\n        IF depth_counter GREATER THAN max_reached_depth THEN\n          SET max_reached_depth TO depth_counter\n        END IF\n      ELSE\n        SET depth_counter TO depth_counter MINUS 1\n      END IF\n      SET index_tracker TO index_tracker PLUS 1\n    END WHILE\n    RETURN max_reached_depth\n  END FUNCTION\n\n\nModified Pseudocode for Problem 7:\n```\nFUNCTION parse_nested_parens(parentheses_string)\n    FUNCTION parse_paren_group(group_string)\n        SET current_depth TO 0\n        SET maximum_depth TO 0\n        FOR each character IN group_string\n            IF character IS '('\n                INCREMENT current_depth BY 1\n                SET maximum_depth TO MAXIMUM OF current_depth AND maximum_depth\n            ELSE\n                DECREMENT current_depth BY 1\n            END IF\n        END FOR\n        RETURN maximum_depth\n    END FUNCTION\n\n    SET groups TO SPLIT parentheses_string BY SPACE\n    RETURN LIST OF parse_paren_group(group) FOR EACH group IN groups IF group IS NOT EMPTY\nEND FUNCTION\n```\n\nPseudocode for Problem 8:\nFUNCTION is_bored(human_input)\n    IMPORT regular_expression_module AS re_module\n\n    SET fragments TO re_module.SPLIT(human_input, pattern='[.?!]\\s*')\n\n    SET tally TO 0\n    SET idx TO 0\n    WHILE idx LESS THAN LENGTH OF fragments\n        SET current_piece TO fragments.AT(idx)\n        SET snippet TO current_piece.SUBSTRING(0, 2)\n        IF snippet EQUALS 'I ' THEN\n            tally INCREMENT BY 1\n        END IF\n        idx INCREMENT BY 1\n    END WHILE\n\n    RETURN tally\nEND FUNCTION\n\nModified Pseudocode for Problem 8:\n```\nFUNCTION is_bored(input_string)\n    IMPORT regular_expression_module AS re\n    SET list_of_sentences TO re.SPLIT(input_string, pattern='[.?!]\\s*')\n    SET boredom_count TO SUM OF (FOR each sentence IN list_of_sentences RETURN sentence SUBSTRING FROM index 0 TO 2 EQUALS 'I ')\n    RETURN boredom_count\nEND FUNCTION\n```\nScore of Passing Rate - BLEU Score for ALL the problems: 0.8583075894453074"
}