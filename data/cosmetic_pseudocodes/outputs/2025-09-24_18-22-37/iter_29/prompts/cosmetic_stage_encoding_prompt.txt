Rewrite the input pseudocode into a fully functionally equivalent version that differs maximally in lexical, syntactic, structural, and stylistic aspects while strictly preserving all semantics, behaviors, side effects, outputs, function signatures, class names, class hierarchies, method names, and object boundaries exactly as in the original pseudocode.

To ensure maximal transformation, your rewritten pseudocode must:

- Retain all global function and class names, including their exact signatures and defined class-object hierarchies, without any renaming or structural reordering.

- Rename **only** all local variables and parameters to fresh, unrelated identifiers, applying consistent renaming throughout each scope.

- Reconstruct control flow by arbitrarily mixing and applying any combination of the following without altering meaning:
  - Transform all FOR loops into WHILE loops and vice versa.
  - Convert IF-ELSE chains into SWITCH-CASE constructs, nested guards, or early returns; conversely, transform SWITCH-CASE into IF-ELSE cascades.
  - Reorder logically independent branches and reorder or flatten/nest conditionals arbitrarily.
  - Replace loops with equivalent recursion where meaningful and syntactically valid, or vice versa.
  - Introduce and eliminate early returns or consolidate multiple returns.
  - Add or remove explicit "else" blocks when logically permissible.

- Arbitrarily reorder any sequence of independent statements, expressions, or computations, while ensuring the final behavior and outputs remain identical.

- Decompose complex expressions into multiple simpler sequential assignments using temporary variables, or conversely compress sequences of assignments or calculations into single compound expressions or ternary operators where valid.

- Substitute operators and comparison forms freely with logically equivalent variations, including but not limited to:
  - “!=” ↔ “not equal to”, “<” ↔ “≥” with inverted logic, logical AND ↔ ∧, OR ↔ ∨, XOR with equivalent expressions.
  - Change numeric literals’ representations (e.g., decimal ↔ hexadecimal, explicit casts, or numeric expressions yielding the same value).
  - Replace array or collection access syntax with alternate valid forms if allowed by the pseudocode syntax (e.g., `array[index]` ↔ `array.at(index)`).

- Vary iteration idioms and data structure traversals extensively:
  - Switch between index-based, element-based, or iterator-based loops in any order or direction (forward, backward, random-access where safe).
  - Change traversal orders, reorder independent data accesses and visits, and combine or split loop bodies correspondingly.

- Introduce new temporary variables, helper assignments, or small helper constructs as necessary, ensuring clear and unambiguous usage consistent with the pseudocode style.

- Randomize formatting completely:
  - Use variable indentation styles, inconsistent spacing, line breaks, statement grouping, and line ordering.
  - Vary use of braces, block delimiters, and keywords as per valid pseudocode syntax.

- Strictly avoid all semantic shortcuts, algorithmic refactorings, or simplifications that alter stepwise behavior, computational complexity, or logic flow (for example, do NOT replace explicit loops with built-in shortcuts, do NOT simplify algorithms, do NOT replace algorithms with closed-form expressions even if logically equivalent).

Output ONLY the transformed pseudocode text preserving all original inputs’ exact functionality.  
Do NOT output explanations, comments, delimiters, extra text, or anything other than the rewritten pseudocode.

The goal is to generate pseudocode that is functionally identical yet as syntactically, lexically, structurally, and stylistically distinct as possible, maximizing code diversity while guaranteeing behavioral equivalence and matching function/class signatures and hierarchy precisely.