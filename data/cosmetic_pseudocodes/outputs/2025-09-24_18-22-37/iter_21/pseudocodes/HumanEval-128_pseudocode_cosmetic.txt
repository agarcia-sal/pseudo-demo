FUNCTION prod_signs(bag_of_nums)
    REPEAT
        IF LENGTH(bag_of_nums) = 0 THEN
            RETURN None
        END IF
        EXIT
    UNTIL FALSE

    DECLARE flag_zero_present AS BOOLEAN
    flag_zero_present ← FALSE

    DECLARE idx AS INTEGER ← 0
    LOOP_WHILE idx < LENGTH(bag_of_nums)
        IF bag_of_nums.at(idx) = 0 THEN
            flag_zero_present ← TRUE
            BREAK
        END IF
        idx ← idx + 1
    END_LOOP

    DECLARE result_sign AS INTEGER

    IF flag_zero_present = TRUE THEN
        result_sign ← 0
    ELSE
        DECLARE neg_count AS INTEGER ← 0
        DECLARE pos AS INTEGER ← 0
        WHILE pos < LENGTH(bag_of_nums)
            IF bag_of_nums.at(pos) < 0 THEN
                neg_count ← neg_count + 1
            END IF
            pos ← pos + 1
        END_WHILE
        result_sign ← 1
        DECLARE counter AS INTEGER ← 0
        WHILE counter < neg_count
            result_sign ← result_sign * (-1)
            counter ← counter + 1
        END_WHILE
    END IF

    DECLARE total_magnitude AS INTEGER ← 0
    FOR_each val IN bag_of_nums DO
        total_magnitude ← total_magnitude + ABS(val)
    END_FOR

    RETURN result_sign * total_magnitude
END FUNCTION