{
  "prompt": "Rewrite the given pseudocode into a version that is functionally identical but differs drastically in terms of syntax, phrasing, control flow, variable naming, and structural style. Preserve exactly all original function names, class names, and their object/class hierarchy without alteration. Avoid any explanatory text or commentary in the output; provide only the rewritten pseudocode. Aim to maximize syntactic and stylistic divergence while ensuring unambiguous equivalence in logic and output.",
  "response": "Rewrite the given pseudocode into a version that is functionally identical but differs drastically in terms of syntax, phrasing, control flow, variable naming, and structural style. Preserve exactly all original function names, class names, and their object/class hierarchy without alteration. Avoid any explanatory text or commentary in the output; provide only the rewritten pseudocode. Aim to maximize syntactic and stylistic divergence while ensuring unambiguous equivalence in logic and output.",
  "score": 0.743826548114672,
  "feedback": "The following are 20 lines of original pseudocode of a random subset of the problems along with their modified pseudocodes.\n\nPseudocode for Problem 1:\n```\nFUNCTION car_race_collision(count_of_cars AS INTEGER)\n    SET collision_result TO 1\n    FOR index FROM 1 TO count_of_cars\n        collision_result = collision_result * count_of_cars\n    END FOR\n    RETURN collision_result\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 1:\n```\nFUNCTION car_race_collision(integer_number_of_cars)\n    RETURN integer_number_of_cars RAISED TO THE POWER OF 2\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 1:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmppupprn_9/solution_1.py\", line 9, in <module>\\n    check(car_race_collision)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmppupprn_9/solution_1.py\", line 8, in check\\n    assert candidate(3) == 9\\nAssertionError\\n']\n\nPseudocode for Problem 2:\n```\nFUNCTION rounded_avg(n, m)\n    IF NOT (n <= m) THEN\n        RETURN -1\n    LET total = 0\n    LET count = m - n + 1\n    LET index = n\n    WHILE index <= m DO\n        total = total + index\n        index = index + 1\n    END WHILE\n    LET avg = total / count\n    LET rounded = ROUND(avg)\n    LET result_bin = TO_BINARY(rounded)\n    RETURN result_bin\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 2:\n```\nFUNCTION rounded_avg(n, m)\n    IF m IS LESS THAN n\n        RETURN -1\n    SET summation TO 0\n    FOR each integer i FROM n TO m INCLUSIVE\n        INCREMENT summation BY i\n    SET average_value TO summation DIVIDED BY (m MINUS n PLUS 1)\n    SET rounded_average TO ROUND average_value TO NEAREST INTEGER\n    SET binary_representation TO BINARY FORMAT OF rounded_average\n    RETURN binary_representation\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 2:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp2up278g1/solution_0.py\", line 19, in <module>\\n    check(rounded_avg)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp2up278g1/solution_0.py\", line 18, in check\\n    assert candidate(1, 5) == \"0b11\"\\nAssertionError\\n']\n\nPseudocode for Problem 3:\n```\nFUNCTION words_string(input_string)\n    IF LENGTH(input_string) = 0 THEN\n        RETURN []\n    END IF\n\n    DECLARE temp_container AS LIST = []\n\n    INDEX i = 0\n    WHILE i < LENGTH(input_string) DO\n        LET current_char = input_string[i]\n        IF current_char = ',' THEN\n            temp_container.ADD(' ')\n        ELSE\n            temp_container.ADD(current_char)\n        END IF\n        i = i + 1\n    END WHILE\n\n    LET merged_text = \"\"\n\nModified Pseudocode for Problem 3:\n```\nFUNCTION words_string(input_string)\n    IF input_string IS EMPTY\n        RETURN empty list\n    END IF\n\n    SET character_list TO empty list\n\n    FOR each character IN input_string\n        IF character IS EQUAL TO comma\n            APPEND space TO character_list\n        ELSE\n            APPEND character TO character_list\n        END IF\n    END FOR\n\n    SET joined_string TO concatenation of all characters in character_list\n    RETURN list of words obtained by splitting joined_string on whitespace\nEND FUNCTION\n```\n\nError(s) from the decoded code for Problem 3:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpmd6k9pxj/solution_0.py\", line 23, in <module>\\n    check(words_string)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpmd6k9pxj/solution_0.py\", line 22, in check\\n    assert candidate(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\\nAssertionError\\n']\n\nPseudocode for Problem 4:\n```\nFUNCTION is_palindrome(input_string)\n    RETURN (input_string == REVERSE(input_string))\nEND FUNCTION\n\nFUNCTION make_palindrome(input_string)\n    IF LENGTH(input_string) == 0 THEN\n        RETURN \"\"\n    END IF\n\n    VARIABLE index <- 0\n\n    REPEAT\n        IF is_palindrome(SUBSTRING(input_string, index, LENGTH(input_string))) THEN\n            BREAK\n        END IF\n        index <- index + 1\n    UNTIL FALSE\n\n    VARIABLE prefix <- SUBSTRING(input_string, 0, index)\n\nModified Pseudocode for Problem 4:\n```\nFUNCTION is_palindrome(input_string)\n    RETURN input_string EQUALS REVERSE OF input_string\nEND FUNCTION\n\nFUNCTION make_palindrome(input_string)\n    IF input_string IS EMPTY\n        RETURN EMPTY STRING\n    END IF\n\n    SET beginning_of_palindromic_suffix TO 0\n\n    WHILE is_palindrome(SUBSTRING OF input_string FROM beginning_of_palindromic_suffix TO END) IS FALSE\n        INCREMENT beginning_of_palindromic_suffix BY 1\n    END WHILE\n\n    RETURN input_string CONCATENATED WITH REVERSE OF SUBSTRING OF input_string FROM START TO beginning_of_palindromic_suffix\nEND FUNCTION\n```\n\nPseudocode for Problem 5:\n```\nFUNCTION sort_array(array_of_integers)\n    LET ascending_sorted = array_of_integers\n    ascending_sorted = array_of_integers SORTED BY value FROM SMALLEST TO LARGEST\n    LET result = SORT ascending_sorted BY\n        FUNCTION(elem)\n            LET binary_string = TO_BINARY_STRING(elem)\n            LET number_of_ones = LENGTH_OF_ALL_CHARACTERS_EQUALS(binary_string, '1')\n            RETURN number_of_ones\n        END FUNCTION\n    RETURN result\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 5:\n```\nFUNCTION sort_array(array_of_integers)\n    SET sorted_array_based_on_decimal TO SORTED array_of_integers IN ASCENDING ORDER\n    SET final_sorted_array TO SORTED sorted_array_based_on_decimal USING KEY AS\n        COUNT OF '1' CHARACTERS IN BINARY REPRESENTATION OF element EXCLUDING THE '0b' PREFIX\n    RETURN final_sorted_array\nEND FUNCTION\n```\n\nPseudocode for Problem 6:\n```\nFUNCTION get_closest_vowel(word)\n    DECLARE vowels_set AS {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"}\n    IF word.LENGTH < 3 THEN\n        RETURN \"\"\n    END IF\n\n    DECLARE pos AS word.LENGTH - 2\n    WHILE pos >= 1\n        DECLARE current_char AS word[pos]\n        IF current_char IN vowels_set THEN\n            DECLARE before_char AS word[pos - 1]\n            DECLARE after_char AS word[pos + 1]\n            IF NOT (before_char IN vowels_set) AND NOT (after_char IN vowels_set) THEN\n                RETURN current_char\n            END IF\n        END IF\n        pos = pos - 1\n    END WHILE\n\n\nModified Pseudocode for Problem 6:\n```\nFUNCTION get_closest_vowel(word)\n    IF LENGTH OF word IS LESS THAN 3\n        RETURN empty string\n    END IF\n\n    SET vowels TO SET OF {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"O\", \"U\", \"I\"}\n\n    FOR index FROM LENGTH OF word MINUS 2 DOWNTO 1 STEP -1\n        IF word AT position index IS IN vowels\n            IF word AT position index PLUS 1 IS NOT IN vowels AND word AT position index MINUS 1 IS NOT IN vowels\n                RETURN word AT position index\n            END IF\n        END IF\n    END FOR\n\n    RETURN empty string\nEND FUNCTION\n```\n\nPseudocode for Problem 7:\n```\nFUNCTION fibfib(n)\n    SWITCH n\n        CASE 0:\n            RETURN 0\n        CASE 1:\n            RETURN 0\n        CASE 2:\n            RETURN 1\n        DEFAULT:\n            LET a = fibfib(n - 1)\n            LET b = fibfib(n - 2)\n            LET c = fibfib(n - 3)\n            RETURN a + b + c\n    END SWITCH\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 7:\n```\nFUNCTION fibfib(integer_n)\n    IF integer_n EQUALS 0\n        RETURN 0\n    END IF\n    IF integer_n EQUALS 1\n        RETURN 0\n    END IF\n    IF integer_n EQUALS 2\n        RETURN 1\n    END IF\n    RETURN fibfib(integer_n MINUS 1) PLUS fibfib(integer_n MINUS 2) PLUS fibfib(integer_n MINUS 3)\nEND FUNCTION\n```\n\nPseudocode for Problem 8:\n```\nFUNCTION circular_shift(integer_x, integer_shift)\n    LET str_num BE STRING(integer_x)\n    LET n BE LENGTH(str_num)\n    IF integer_shift > n THEN\n        RETURN REVERSE(str_num)\n    END IF\n    LET split_point BE n - integer_shift\n    LET part_one BE SUBSTR(str_num, split_point, n - split_point)\n    LET part_two BE SUBSTR(str_num, 0, split_point)\n    RETURN CONCATENATE(part_one, part_two)\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 8:\n```\nFUNCTION circular_shift(integer_x, integer_shift)\n    SET string_representation TO CONVERT integer_x TO STRING\n    IF integer_shift GREATER THAN LENGTH OF string_representation\n        RETURN REVERSE OF string_representation\n    ELSE\n        RETURN SUBSTRING OF string_representation FROM (LENGTH OF string_representation MINUS integer_shift) TO END CONCATENATED WITH SUBSTRING OF string_representation FROM START TO (LENGTH OF string_representation MINUS integer_shift)\nEND FUNCTION\n```\nScore of Passing Rate - BLEU Score for ALL the problems: 0.743826548114672"
}