{
  "prompt": "Given an input pseudocode snippet, rewrite it to produce a version that faithfully preserves **all original functionality, data flow, and external behavior**, including returning identical outputs and maintaining all function names, class names, method signatures, and their hierarchical placement exactly as in the original pseudocode. Your rewritten pseudocode must appear as a completely fresh, non-trivially transformed implementation, achieving **maximal divergence** in all of the following dimensions without altering correctness:\n\n- Systematically replace **all variable names, parameters, and temporary identifiers** with new semantically plausible but distinctly different names.\n\n- Transform all control flow structures by replacing one construct with a semantically equivalent but structurally different alternative, for example:\n  - Convert all `for` loops to `while` loops, recursion, or functional-style iteration constructs.\n  - Substitute nested `if`-`else` blocks with early exits, guard clauses, switch/case equivalents, or inverted logic using De Morgan\u2019s laws.\n  - Unroll or regroup loops and conditionals where possible without changing logic.\n\n- Reorder independent computations and combine or split statements, expressions, and intermediate calculations while preserving exact evaluation results.\n\n- Rewrite every expression to a logically equivalent form using alternative arithmetic, Boolean identities, operand order swapping, negations, and equivalent operators.\n\n- Alter data structure traversals, for instance:\n  - Replace index-based iteration with iterators or element-based loops.\n  - Use different navigation methods for collections (e.g., queues, stacks, recursion).\n\n- Completely reformat the pseudocode\u2019s appearance: change indentation styles, whitespace, line breaks, grouping of statements, and comment style or placement (if any comments exist).\n\n- Avoid introducing any new functionality, changing API, or modifying the order and structure of classes, functions, and method signatures.\n\n- Ensure no semantic changes occur to I/O behavior, return values, or side effects.\n\nYour output must consist **solely** of the rewritten pseudocode snippet, with **no explanation, commentary, or annotations**.\n\n**Strict constraints:**\n\n- Retain **all original function names** verbatim.\n\n- Keep **all original class names and their nesting (hierarchical structure)** identical.\n\n- Preserve **method signatures exactly** (names, parameter names, order, and method placement).\n\n- Maintain **all existing return statements and output structure** unchanged.\n\nAim for the generated pseudocode to look like an independently authored algorithm that performs the same task flawlessly but shares as little lexical, syntactic, and structural similarity with the original pseudocode as possible.",
  "response": "Given an input pseudocode snippet, rewrite it to produce a version that faithfully preserves **all original functionality, data flow, and external behavior**, including returning identical outputs and maintaining all function names, class names, method signatures, and their hierarchical placement exactly as in the original pseudocode. Your rewritten pseudocode must appear as a completely fresh, non-trivially transformed implementation, achieving **maximal divergence** in all of the following dimensions without altering correctness:\n\n- Systematically replace **all variable names, parameters, and temporary identifiers** with new semantically plausible but distinctly different names.\n\n- Transform all control flow structures by replacing one construct with a semantically equivalent but structurally different alternative, for example:\n  - Convert all `for` loops to `while` loops, recursion, or functional-style iteration constructs.\n  - Substitute nested `if`-`else` blocks with early exits, guard clauses, switch/case equivalents, or inverted logic using De Morgan\u2019s laws.\n  - Unroll or regroup loops and conditionals where possible without changing logic.\n\n- Reorder independent computations and combine or split statements, expressions, and intermediate calculations while preserving exact evaluation results.\n\n- Rewrite every expression to a logically equivalent form using alternative arithmetic, Boolean identities, operand order swapping, negations, and equivalent operators.\n\n- Alter data structure traversals, for instance:\n  - Replace index-based iteration with iterators or element-based loops.\n  - Use different navigation methods for collections (e.g., queues, stacks, recursion).\n\n- Completely reformat the pseudocode\u2019s appearance: change indentation styles, whitespace, line breaks, grouping of statements, and comment style or placement (if any comments exist).\n\n- Avoid introducing any new functionality, changing API, or modifying the order and structure of classes, functions, and method signatures.\n\n- Ensure no semantic changes occur to I/O behavior, return values, or side effects.\n\nYour output must consist **solely** of the rewritten pseudocode snippet, with **no explanation, commentary, or annotations**.\n\n**Strict constraints:**\n\n- Retain **all original function names** verbatim.\n\n- Keep **all original class names and their nesting (hierarchical structure)** identical.\n\n- Preserve **method signatures exactly** (names, parameter names, order, and method placement).\n\n- Maintain **all existing return statements and output structure** unchanged.\n\nAim for the generated pseudocode to look like an independently authored algorithm that performs the same task flawlessly but shares as little lexical, syntactic, and structural similarity with the original pseudocode as possible.",
  "score": -0.2151131708105519,
  "feedback": "The following are 20 lines of original pseudocode of a random subset of the problems along with their modified pseudocodes.\n\nPseudocode for Problem 1:\n```\nFUNCTION encode_cyclic(input_string)\n    INITIALIZE segments AS empty array\n    SET counter TO 0\n    WHILE counter * 3 < LENGTH(input_string)\n        DEFINE start_index AS counter * 3\n        DEFINE end_index AS start_index + 3\n        IF end_index > LENGTH(input_string)\n            SET end_index TO LENGTH(input_string)\n        APPEND SUBSTRING(input_string, start_index, end_index) TO segments\n        INCREMENT counter BY 1\n    INITIALIZE transformed_segments AS empty array\n    FOR EACH segment IN segments\n        IF LENGTH(segment) IS NOT 3\n            APPEND segment TO transformed_segments\n            CONTINUE TO NEXT iteration\n        SET rearranged TO CONCAT(SUBSTRING(segment, 2, 3), SUBSTRING(segment, 1, 1))\n        APPEND rearranged TO transformed_segments\n    RETURN JOIN(transformed_segments, \"\")\nEND FUNCTION\n\nModified Pseudocode for Problem 1:\n```\nFUNCTION encode_cyclic(input_string)\n    SET groups TO empty list\n    FOR each index FROM 0 TO (LENGTH OF input_string + 2) INTEGER DIVIDED BY 3 MINUS 1\n        ADD SUBSTRING OF input_string FROM (3 TIMES index) TO MINIMUM OF ((3 TIMES index PLUS 3), LENGTH OF input_string) TO groups\n    SET groups TO empty list\n    FOR each group IN groups\n        IF LENGTH OF group EQUALS 3\n            ADD CONCATENATION OF SUBSTRING OF group FROM SECOND CHARACTER TO END AND FIRST CHARACTER OF group TO groups\n        ELSE\n            ADD group TO groups\n    RETURN CONCATENATION OF ALL ELEMENTS IN groups\nEND FUNCTION\n\nFUNCTION decode_cyclic(input_string)\n    RETURN encode_cyclic(encode_cyclic(input_string))\nEND FUNCTION\n```\n\nPseudocode for Problem 2:\n```\nFUNCTION exchange(list_one, list_two)\n  LET tally_odd = 0\n  LET tally_even = 0\n  \n  LET iterator_one = 0\n  WHILE iterator_one < LENGTH(list_one) DO\n    LET current_item = list_one[iterator_one]\n    LET is_odd = NOT ( (current_item + 1) MOD 2 = 0 )\n    IF is_odd THEN\n      tally_odd = tally_odd + 1\n    END IF\n    iterator_one = iterator_one + 1\n  END WHILE\n\n  LET iterator_two = 0\n  REPEAT\n    IF iterator_two >= LENGTH(list_two) THEN BREAK END IF\n    LET current_unit = list_two[iterator_two]\n    IF (current_unit MOD 2) = 0 THEN\n\nModified Pseudocode for Problem 2:\n```\nFUNCTION exchange(list_one, list_two)\n    SET odd_count TO 0\n    SET even_count TO 0\n    FOR each element IN list_one\n        IF element MODULO 2 IS EQUAL TO 1\n            INCREMENT odd_count BY 1\n    FOR each element IN list_two\n        IF element MODULO 2 IS EQUAL TO 0\n            INCREMENT even_count BY 1\n    IF even_count IS GREATER THAN OR EQUAL TO odd_count\n        RETURN \"YES\"\n    RETURN \"NO\"\nEND FUNCTION\n```\n\nPseudocode for Problem 3:\n```\nFUNCTION words_string(input_string)\n    \n    IF NOT (input_string <> \"\") THEN\n        RETURN []\n    END IF\n\n    characters_accumulator <- []\n\n    idx <- 0\n    WHILE idx < LENGTH(input_string)\n        curr_char <- input_string[idx]\n        IF curr_char <> \",\" THEN\n            characters_accumulator.APPEND(curr_char)\n        ELSE\n            characters_accumulator.APPEND(\" \")\n        END IF\n        idx <- idx + 1\n    END WHILE\n\n\nModified Pseudocode for Problem 3:\n```\nFUNCTION words_string(input_string)\n    IF input_string IS EMPTY\n        RETURN empty list\n    END IF\n\n    SET character_list TO empty list\n\n    FOR each character IN input_string\n        IF character IS EQUAL TO comma\n            APPEND space TO character_list\n        ELSE\n            APPEND character TO character_list\n        END IF\n    END FOR\n\n    SET joined_string TO concatenation of all characters in character_list\n    RETURN list of words obtained by splitting joined_string on whitespace\nEND FUNCTION\n```\n\nPseudocode for Problem 4:\n```\nFUNCTION find_closest_elements(list_of_numbers)\n  SET best_match TO None\n  SET smallest_gap TO None\n\n  SET outer_idx TO 0\n  WHILE outer_idx < LENGTH(list_of_numbers) - 1\n    SET current_num TO list_of_numbers[outer_idx]\n\n    SET inner_idx TO 0\n    WHILE inner_idx < LENGTH(list_of_numbers) - 1\n      SET comparison_num TO list_of_numbers[inner_idx]\n\n      IF outer_idx <> inner_idx THEN\n        IF smallest_gap IS None THEN\n          SET smallest_gap TO ABS(current_num - comparison_num)\n          SET best_match TO (MIN(current_num, comparison_num), MAX(current_num, comparison_num))\n        ELSE\n          SET gap_candidate TO ABS(comparison_num - current_num)\n          IF gap_candidate < smallest_gap THEN\n\nModified Pseudocode for Problem 4:\n```\nFUNCTION find_closest_elements(list_of_numbers)\n    SET closest_pair TO None\n    SET distance TO None\n\n    FOR index IN RANGE FROM 0 TO LENGTH OF list_of_numbers MINUS 1\n        SET element TO list_of_numbers AT index\n        FOR index2 IN RANGE FROM 0 TO LENGTH OF list_of_numbers MINUS 1\n            SET element2 TO list_of_numbers AT index2\n            IF index IS NOT EQUAL TO index2\n                IF distance IS None\n                    SET distance TO ABSOLUTE VALUE OF (element MINUS element2)\n                    SET closest_pair TO TUPLE OF SORTED LIST OF [element, element2]\n                ELSE\n                    SET new_distance TO ABSOLUTE VALUE OF (element MINUS element2)\n                    IF new_distance IS LESS THAN distance\n                        SET distance TO new_distance\n                        SET closest_pair TO TUPLE OF SORTED LIST OF [element, element2]\n                    END IF\n                END IF\n\nPseudocode for Problem 5:\n```\nFUNCTION add(list_of_integers)\n  LET total = 0\n  LET idx = 1\n  WHILE idx <= LENGTH(list_of_integers)\n    LET current_value = list_of_integers[idx]\n    IF current_value MOD 2 = 0 THEN\n      total = total + current_value\n    END IF\n    idx = idx + 2\n  END WHILE\n  RETURN total\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 5:\n```\nFUNCTION add(list_of_integers)\n    RETURN SUM OF ELEMENTS AT positions FROM 1 TO LENGTH OF list_of_integers STEP 2 WHERE ELEMENT IS EVEN\nEND FUNCTION\n```\n\nPseudocode for Problem 6:\n```\nFUNCTION add(alpha, beta)\n  SET total TO 0\n  SET index TO 0\n  WHILE index < 1 DO\n    SET total TO alpha + beta\n    SET index TO index + 1\n  END WHILE\n  RETURN total\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 6:\n```\nFUNCTION add(x, y)\n    RETURN x PLUS y\nEND FUNCTION\n```\n\nPseudocode for Problem 7:\n```\nFUNCTION encode_shift(input_string)\n    SET result_string TO EMPTY STRING\n    SET iterator TO 0\n    WHILE iterator < LENGTH OF input_string\n        SET current_char TO input_string[iterator]\n        SET base_value TO ASCII VALUE OF \"a\"\n        SET ascii_equivalent TO ( ( (ASCII VALUE OF current_char + 5) - base_value ) MOD 26 ) + base_value\n        SET encoded_char TO CHARACTER REPRESENTED BY ascii_equivalent\n        APPEND encoded_char TO result_string\n        INCREMENT iterator BY 1\n    END WHILE\n    RETURN result_string\nEND FUNCTION\n\nFUNCTION decode_shift(input_string)\n    SET output TO EMPTY STRING\n    SET index TO 0\n    WHILE index < LENGTH OF input_string\n        SET char_element TO input_string[index]\n\nModified Pseudocode for Problem 7:\n```\nFUNCTION encode_shift(input_string)\n    RETURN CONCATENATION OF CHARACTER FOR EACH character IN input_string WHERE\n        CHARACTER IS COMPUTED BY\n            CONVERT character TO ASCII VALUE\n            ADD 5 TO ASCII VALUE\n            SUBTRACT ASCII VALUE OF \"a\"\n            COMPUTE RESULT MODULO 26\n            ADD ASCII VALUE OF \"a\"\n            CONVERT RESULT BACK TO CHARACTER\nEND FUNCTION\n\nFUNCTION decode_shift(input_string)\n    RETURN CONCATENATION OF CHARACTER FOR EACH character IN input_string WHERE\n        CHARACTER IS COMPUTED BY\n            CONVERT character TO ASCII VALUE\n            SUBTRACT 5 FROM ASCII VALUE\n            SUBTRACT ASCII VALUE OF \"a\"\n            COMPUTE RESULT MODULO 26\n            ADD ASCII VALUE OF \"a\"\n\nPseudocode for Problem 8:\n```\nFUNCTION rounded_avg(integer_n, integer_m)\n    IF NOT (integer_m >= integer_n)\n        RETURN -1\n    SET total_sum TO 0\n    SET current_num TO integer_n\n    WHILE current_num <= integer_m\n        total_sum = total_sum + current_num\n        current_num = current_num + 1\n    SET count_elements TO (integer_m - integer_n) + 1\n    SET mean_val TO total_sum / count_elements\n    SET approx_val TO FLOOR(mean_val + 0.5)\n    RETURN TO_BINARY_STRING(approx_val)\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 8:\n```\nFUNCTION rounded_avg(integer_n, integer_m)\n    IF integer_m LESS THAN integer_n\n        RETURN -1\n    SET summation TO 0\n    FOR each integer_i FROM integer_n TO integer_m INCLUSIVE\n        INCREMENT summation BY integer_i\n    SET average_value TO summation DIVIDED BY (integer_m MINUS integer_n PLUS 1)\n    SET rounded_average TO ROUND average_value TO NEAREST INTEGER\n    RETURN BINARY REPRESENTATION OF rounded_average\nEND FUNCTION\n```\nScore of -1*(BLEU Score) for ALL the problems: -0.2151131708105519",
  "iter": 8
}