{
  "prompt": "Given the input pseudocode, produce a rewritten version that preserves **all original functionality exactly**, with **no additions, removals, or changes** to function names, class names, or their structure (including methods and nesting). Your goal is to **maximize the difference from the original pseudocode** by extensively transforming all other aspects, including:\n\n- Variable and temporary identifier names (use completely different, meaningful names).\n- Control flow constructs (e.g., convert between loops, recursion, conditionals, switch/case, guard clauses, etc.).\n- Expression forms and operations (rewrite arithmetic and logical expressions using alternative but equivalent logic).\n- Statement order and sequencing where semantics allow.\n- Code formatting, indentation style, and whitespace.\n- Data structure usage and iteration methods.\n- Use of helper variables and intermediate computations (you may refactor and reorder computations inside functions).\n  \n**Do NOT** change the calling signatures, function/class names, or the overall class/object layout.\n\n**Output only the transformed pseudocode, without any commentary, explanation, or extra text.**",
  "response": "Given the input pseudocode, produce a rewritten version that preserves **all original functionality exactly**, with **no additions, removals, or changes** to function names, class names, or their structure (including methods and nesting). Your goal is to **maximize the difference from the original pseudocode** by extensively transforming all other aspects, including:\n\n- Variable and temporary identifier names (use completely different, meaningful names).\n- Control flow constructs (e.g., convert between loops, recursion, conditionals, switch/case, guard clauses, etc.).\n- Expression forms and operations (rewrite arithmetic and logical expressions using alternative but equivalent logic).\n- Statement order and sequencing where semantics allow.\n- Code formatting, indentation style, and whitespace.\n- Data structure usage and iteration methods.\n- Use of helper variables and intermediate computations (you may refactor and reorder computations inside functions).\n  \n**Do NOT** change the calling signatures, function/class names, or the overall class/object layout.\n\n**Output only the transformed pseudocode, without any commentary, explanation, or extra text.**",
  "score": -0.22782044059926876,
  "feedback": "The following are 20 lines of original pseudocode of a random subset of the problems along with their modified pseudocodes.\n\nPseudocode for Problem 1:\n```\nFUNCTION search(list_of_integers)\n  SET counts TO ARRAY FILLED WITH 0, LENGTH (MAXIMUM VALUE IN list_of_integers) + 1\n  FOR i FROM 0 TO LENGTH(list_of_integers) - 1\n    LET current_val = list_of_integers[i]\n    LET current_count = counts[current_val]\n    LET updated_count = 1 + current_count\n    SET counts[current_val] TO updated_count\n  LET result = -1\n  LET position = LENGTH(counts) - 1\n  WHILE position >= 1\n    LET freq = counts[position]\n    IF freq >= position THEN\n      SET result TO position\n    DECREMENT position BY 1\n  END WHILE\n  RETURN result\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 1:\n```\nFUNCTION search(list_of_integers)\n    SET frequency_list TO list_of_zeros WITH LENGTH max_value_in list_of_integers PLUS 1\n    FOR each integer IN list_of_integers\n        INCREMENT frequency_list AT POSITION integer BY 1\n    SET answer TO -1\n    FOR each index FROM 1 TO LENGTH OF frequency_list MINUS 1\n        IF frequency_list AT POSITION index IS GREATER THAN OR EQUAL TO index\n            SET answer TO index\n    RETURN answer\nEND FUNCTION\n```\n\nPseudocode for Problem 2:\n```\nFUNCTION median(list_of_elements)\n  SET ordered_values TO COPY list_of_elements\n  SORT ordered_values IN ASCENDING ORDER\n  SET total_count TO LENGTH OF ordered_values\n  SET midpoint TO total_count DIV 2\n  IF (total_count - 1) MOD 2 != 0 THEN\n    RETURN ordered_values[midpoint]\n  ELSE\n    SET left_mid TO ordered_values[midpoint - 1]\n    SET right_mid TO ordered_values[midpoint]\n    RETURN (left_mid + right_mid) * 0.5\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 2:\n```\nFUNCTION median(list_of_elements)\n    SET list_of_elements TO SORTED COPY OF list_of_elements\n    IF LENGTH OF list_of_elements MODULO 2 EQUALS 1\n        RETURN ELEMENT AT INDEX LENGTH OF list_of_elements DIVIDED BY 2 IN list_of_elements\n    ELSE\n        RETURN (ELEMENT AT INDEX (LENGTH OF list_of_elements DIVIDED BY 2) MINUS 1 IN list_of_elements PLUS ELEMENT AT INDEX LENGTH OF list_of_elements DIVIDED BY 2 IN list_of_elements) DIVIDED BY 2.0\nEND FUNCTION\n```\n\nPseudocode for Problem 3:\n```\nFUNCTION prod_signs(array_of_integers)\n  IF NOT (array_of_integers HAS ITEMS)\n    RETURN None\n  END IF\n\n  SET result_sign TO NULL\n  SET contains_zero_flag TO False\n\n  FOR element IN array_of_integers\n    IF element == 0\n      contains_zero_flag = True\n      BREAK\n    END IF\n  END FOR\n\n  IF contains_zero_flag\n    result_sign = 0\n  ELSE\n    SET negative_quantity TO 0\n\nModified Pseudocode for Problem 3:\n```\nFUNCTION prod_signs(array_of_integers)\n    IF array_of_integers IS EMPTY\n        RETURN None\n    END IF\n    IF array_of_integers CONTAINS 0\n        SET sign_product TO 0\n    ELSE\n        SET count_of_negative_numbers TO LENGTH OF FILTERED ELEMENTS LESS THAN 0 IN array_of_integers\n        SET sign_product TO (-1) RAISED TO THE POWER OF count_of_negative_numbers\n    END IF\n    SET sum_of_magnitudes TO SUM OF ABSOLUTE VALUES OF EACH ELEMENT IN array_of_integers\n    RETURN sign_product MULTIPLIED BY sum_of_magnitudes\nEND FUNCTION\n```\n\nPseudocode for Problem 4:\n```\nFUNCTION encode_cyclic(input_string)\n  LET segment_collection BE an empty sequence\n  LET total_segments BE ((LENGTH OF input_string) + 2) DIV 3\n  LET counter BE 0\n  WHILE counter < total_segments\n    LET start_pos BE 3 * counter\n    LET end_pos BE start_pos + 3\n    IF end_pos > LENGTH OF input_string\n      SET end_pos TO LENGTH OF input_string\n    ENDIF\n    APPEND SUBSTRING(input_string, start_pos, end_pos) TO segment_collection\n    INCREMENT counter BY 1\n  ENDWHILE\n\n  LET transformed_segments BE empty array\n  FOR EACH segment IN segment_collection\n    IF LENGTH OF segment IS 3 THEN\n      LET rotated_segment BE CONCAT(SUBSTRING(segment, 1, 3), SUBSTRING(segment, 0, 1))\n      APPEND rotated_segment TO transformed_segments\n\nModified Pseudocode for Problem 4:\n```\nFUNCTION encode_cyclic(input_string)\n    SET groups TO empty list\n    FOR each index FROM 0 TO (LENGTH OF input_string + 2) INTEGER DIVIDED BY 3 MINUS 1\n        ADD SUBSTRING OF input_string FROM (3 TIMES index) TO MINIMUM OF ((3 TIMES index PLUS 3), LENGTH OF input_string) TO groups\n    SET groups TO empty list\n    FOR each group IN groups\n        IF LENGTH OF group EQUALS 3\n            ADD CONCATENATION OF SUBSTRING OF group FROM SECOND CHARACTER TO END AND FIRST CHARACTER OF group TO groups\n        ELSE\n            ADD group TO groups\n    RETURN CONCATENATION OF ALL ELEMENTS IN groups\nEND FUNCTION\n\nFUNCTION decode_cyclic(input_string)\n    RETURN encode_cyclic(encode_cyclic(input_string))\nEND FUNCTION\n```\n\nPseudocode for Problem 5:\n```\nFUNCTION rounded_avg(integer_n, integer_m)\n    IF NOT (integer_m >= integer_n)\n        RETURN -1\n    SET total_sum TO 0\n    SET current_num TO integer_n\n    WHILE current_num <= integer_m\n        total_sum = total_sum + current_num\n        current_num = current_num + 1\n    SET count_elements TO (integer_m - integer_n) + 1\n    SET mean_val TO total_sum / count_elements\n    SET closest_int TO FLOOR(mean_val + 0.5)\n    RETURN CONVERT closest_int TO BINARY STRING\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 5:\n```\nFUNCTION rounded_avg(integer_n, integer_m)\n    IF integer_m LESS THAN integer_n\n        RETURN -1\n    SET summation TO 0\n    FOR each integer_i FROM integer_n TO integer_m INCLUSIVE\n        INCREMENT summation BY integer_i\n    SET average_value TO summation DIVIDED BY (integer_m MINUS integer_n PLUS 1)\n    SET rounded_average TO ROUND average_value TO NEAREST INTEGER\n    RETURN BINARY REPRESENTATION OF rounded_average\nEND FUNCTION\n```\n\nPseudocode for Problem 6:\n```\nFUNCTION monotonic(sequence)\n    IF NOT (sequence > SORT(sequence)) AND NOT (sequence < SORT(sequence, DESCENDING))\n        RETURN True\n    ELSE\n        RETURN False\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 6:\n```\nFUNCTION monotonic(list_of_elements)\n    IF list_of_elements EQUALS SORTED(list_of_elements) OR list_of_elements EQUALS SORTED(list_of_elements, WITH_ORDER_REVERSED)\n        RETURN True\n    RETURN False\nEND FUNCTION\n```\n\nPseudocode for Problem 7:\n```\nFUNCTION add(list_of_integers)\n    SET total_sum TO 0\n    SET index TO 1\n    WHILE index <= LENGTH(list_of_integers)\n        SET value TO list_of_integers[index]\n        IF (value MOD 2) = 0 THEN\n            SET total_sum TO total_sum + value\n        END IF\n        SET index TO index + 2\n    END WHILE\n    RETURN total_sum\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 7:\n```\nFUNCTION add(list_of_integers)\n    RETURN SUM OF ELEMENTS AT positions FROM 1 TO LENGTH OF list_of_integers STEP 2 WHERE ELEMENT IS EVEN\nEND FUNCTION\n```\n\nPseudocode for Problem 8:\n```\nFUNCTION change_base(integer_x, integer_base)\n  SET accumulated_string TO \"\"\n  IF integer_x <= 0 THEN\n    RETURN accumulated_string\n  END IF\n  REPEAT\n    SET digit_value TO integer_x - (integer_x / integer_base) * integer_base\n    SET accumulated_string TO TO_STRING(digit_value) + accumulated_string\n    SET integer_x TO (integer_x - digit_value) / integer_base\n  UNTIL integer_x = 0\n  RETURN accumulated_string\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 8:\n```\nFUNCTION change_base(integer_x, integer_base)\n    SET string_result TO empty string\n    WHILE integer_x GREATER THAN 0\n        SET string_result TO STRING OF (integer_x MODULO integer_base) CONCATENATED WITH string_result\n        SET integer_x TO integer_x DIVIDED BY integer_base USING INTEGER DIVISION\n    RETURN string_result\nEND FUNCTION\n```\nScore of -1*(BLEU Score) for ALL the problems: -0.22782044059926876",
  "iter": 2
}