{
  "prompt": "Given an input pseudocode snippet, rewrite it to produce an output pseudocode that strictly preserves **all original functional behavior and logic** without any additions, removals, or alterations to function names, class names, method signatures, or their nested structure. Your rewritten version must be as syntactically and structurally **distinct** as possible from the input, employing comprehensive transformations including but not limited to:\n\n- Fully renaming **variables, temporary identifiers, and parameters** to semantically meaningful but entirely different names.\n- Converting one style of control flow to fundamentally different constructs (e.g., replacing `for` loops with equivalent `while` loops or recursion, flattening nested conditionals into guard clauses or switch/case statements, unrolling or regrouping loops, etc.).\n- Rearranging computations, extracting or combining intermediate expressions, and changing calculation sequences internally as long as output logic remains the same.\n- Rewriting all expressions using logically equivalent alternatives, including employing De Morgan\u2019s laws, alternative arithmetic or logical identities, and different ordering of operands where allowed.\n- Altering the formatting style thoroughly: indentation, spacing, line breaks, statement grouping, and comment removal/addition (if any comments exist).\n- Changing the approach used for traversing data structures, replacing explicit index manipulation with iterators, or vice versa.\n- Refactoring statement order and combining or splitting statements where semantic equivalence holds.\n- Avoid changing the external API: keep all function and class signatures, returned values, and the overall class/object layout exactly as in the input.\n\nYour output must be **only** the rewritten pseudocode, with no explanatory text, commentary, or annotations.\n\n**Strictly do NOT modify:**  \n- Function names  \n- Class names and their hierarchical placement  \n- Method signatures (names, parameters, order) and nesting  \n- External behavior or outputs  \n\nThe goal is maximal syntactic, lexical, and structural divergence from the original pseudocode while maintaining exactly the same computed results and external API. Your rewritten pseudocode should look and feel like a completely different implementation that preserves the original contract perfectly.",
  "response": "Given an input pseudocode snippet, rewrite it to produce an output pseudocode that strictly preserves **all original functional behavior and logic** without any additions, removals, or alterations to function names, class names, method signatures, or their nested structure. Your rewritten version must be as syntactically and structurally **distinct** as possible from the input, employing comprehensive transformations including but not limited to:\n\n- Fully renaming **variables, temporary identifiers, and parameters** to semantically meaningful but entirely different names.\n- Converting one style of control flow to fundamentally different constructs (e.g., replacing `for` loops with equivalent `while` loops or recursion, flattening nested conditionals into guard clauses or switch/case statements, unrolling or regrouping loops, etc.).\n- Rearranging computations, extracting or combining intermediate expressions, and changing calculation sequences internally as long as output logic remains the same.\n- Rewriting all expressions using logically equivalent alternatives, including employing De Morgan\u2019s laws, alternative arithmetic or logical identities, and different ordering of operands where allowed.\n- Altering the formatting style thoroughly: indentation, spacing, line breaks, statement grouping, and comment removal/addition (if any comments exist).\n- Changing the approach used for traversing data structures, replacing explicit index manipulation with iterators, or vice versa.\n- Refactoring statement order and combining or splitting statements where semantic equivalence holds.\n- Avoid changing the external API: keep all function and class signatures, returned values, and the overall class/object layout exactly as in the input.\n\nYour output must be **only** the rewritten pseudocode, with no explanatory text, commentary, or annotations.\n\n**Strictly do NOT modify:**  \n- Function names  \n- Class names and their hierarchical placement  \n- Method signatures (names, parameters, order) and nesting  \n- External behavior or outputs  \n\nThe goal is maximal syntactic, lexical, and structural divergence from the original pseudocode while maintaining exactly the same computed results and external API. Your rewritten pseudocode should look and feel like a completely different implementation that preserves the original contract perfectly.",
  "score": -0.21721256360769867,
  "feedback": "The following are 20 lines of original pseudocode of a random subset of the problems along with their modified pseudocodes.\n\nPseudocode for Problem 1:\n```\nFUNCTION add(list_of_integers)\n    total_sum <- 0\n    position <- 1\n    WHILE position <= LENGTH(list_of_integers) DO\n        current_value <- list_of_integers[position]\n        IF (current_value MOD 2) = 0 THEN\n            total_sum <- total_sum + current_value\n        END IF\n        position <- position + 2\n    END WHILE\n    RETURN total_sum\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 1:\n```\nFUNCTION add(list_of_integers)\n    RETURN SUM OF ELEMENTS AT positions FROM 1 TO LENGTH OF list_of_integers STEP 2 WHERE ELEMENT IS EVEN\nEND FUNCTION\n```\n\nPseudocode for Problem 2:\n```\nFUNCTION solve(integer_N)\n    SET accumulator TO 0\n    SET digits_string TO CONVERT integer_N TO STRING\n    SET index TO 0\n    WHILE index < LENGTH OF digits_string DO\n        SET current_char TO digits_string[index]\n        SET numeric_value TO current_char - '0'\n        SET accumulator TO accumulator + numeric_value\n        SET index TO index + 1\n    END WHILE\n    SET full_binary TO CONVERT accumulator TO BINARY STRING\n    SET trimmed_binary TO SUBSTRING full_binary FROM POSITION 3 TO END\n    RETURN trimmed_binary\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 2:\n```\nFUNCTION solve(integer_N)\n    SET sum_of_digits TO 0\n    FOR each character_digit IN STRING REPRESENTATION OF integer_N\n        INCREMENT sum_of_digits BY INTEGER VALUE OF character_digit\n    SET binary_representation TO BINARY STRING OF sum_of_digits EXCLUDING THE FIRST TWO CHARACTERS\n    RETURN binary_representation\nEND FUNCTION\n```\n\nPseudocode for Problem 3:\n```\nFUNCTION get_row(two_dimensional_list, target_integer)\n    INITIALIZE found_positions AS AN EMPTY COLLECTION\n    SET row_cursor TO 0\n    WHILE row_cursor < SIZE OF two_dimensional_list\n        SET col_cursor TO 0\n        WHILE col_cursor < SIZE OF two_dimensional_list AT row_cursor\n            IF NOT (two_dimensional_list AT row_cursor AT col_cursor != target_integer)\n                ADD (row_cursor, col_cursor) TO found_positions\n            INCREMENT col_cursor BY 1\n        INCREMENT row_cursor BY 1\n    SET temp_first_sort TO found_positions SORTED BY ELEMENT AT INDEX 0 IN ASCENDING ORDER\n    SET final_sort TO temp_first_sort SORTED BY ELEMENT AT INDEX 1 IN DESCENDING ORDER\n    RETURN final_sort\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 3:\n```\nFUNCTION get_row(two_dimensional_list, target_integer)\n    SET coordinates TO EMPTY LIST\n    FOR each row_index FROM 0 TO LENGTH OF two_dimensional_list MINUS 1\n        FOR each column_index FROM 0 TO LENGTH OF two_dimensional_list AT row_index MINUS 1\n            IF two_dimensional_list AT row_index AT column_index EQUALS target_integer\n                APPEND TUPLE(row_index, column_index) TO coordinates\n    SET coordinates TO coordinates SORTED BY SECOND ELEMENT IN DESCENDING ORDER\n    SET coordinates TO coordinates SORTED BY FIRST ELEMENT IN ASCENDING ORDER\n    RETURN coordinates\nEND FUNCTION\n```\n\nPseudocode for Problem 4:\n```\nFUNCTION fizz_buzz(integer_n)\n    INITIALIZE collected_values AS an empty collection\n    SET index_pointer TO 0\n    WHILE index_pointer < integer_n DO\n        IF NOT (index_pointer MOD 11) AND NOT (index_pointer MOD 13) THEN\n            // no action needed in this case\n        ELSE IF (index_pointer MOD 11) = 0 OR (index_pointer MOD 13) = 0 THEN\n            ADD index_pointer TO collected_values\n        END IF\n        SET index_pointer TO index_pointer + 1\n    END WHILE\n\n    INITIALIZE assembled_text AS a blank sequence\n    ITERATE each element OVER collected_values AS item\n        assembled_text = assembled_text + STRING_OF(item)\n    END ITERATE\n\n    SET sevens_counter TO 0\n    SET position TO 0\n\nModified Pseudocode for Problem 4:\n```\nFUNCTION fizz_buzz(integer_n)\n    SET list_of_numbers TO empty list\n    FOR each integer_i IN range FROM 0 TO integer_n EXCLUSIVE\n        IF integer_i MODULO 11 EQUALS 0 OR integer_i MODULO 13 EQUALS 0\n            APPEND integer_i TO list_of_numbers\n        END IF\n    END FOR\n    SET concatenated_string TO empty string\n    FOR each number IN list_of_numbers\n        CONCATENATE string representation of number TO concatenated_string\n    END FOR\n    SET count_of_sevens TO 0\n    FOR each character_c IN concatenated_string\n        INCREMENT count_of_sevens BY (character_c EQUALS '7')\n    END FOR\n    RETURN count_of_sevens\nEND FUNCTION\n```\n\nPseudocode for Problem 5:\n```\nFUNCTION find_closest_elements(numbers_array)\n    INITIALIZE best_pair TO None\n    INITIALIZE minimal_diff TO None\n    INITIALIZE outer_idx TO 0\n\n    WHILE outer_idx < LENGTH OF numbers_array MINUS 1\n        LET current_val TO numbers_array AT outer_idx\n        INITIALIZE inner_idx TO 0\n\n        WHILE inner_idx < LENGTH OF numbers_array MINUS 1\n            LET comparison_val TO numbers_array AT inner_idx\n\n            IF NOT (outer_idx = inner_idx) THEN\n                LET current_diff TO (current_val - comparison_val)\n                IF current_diff < 0 THEN\n                    SET current_diff TO -current_diff\n                END IF\n\n                IF minimal_diff IS None THEN\n\nModified Pseudocode for Problem 5:\n```\nFUNCTION find_closest_elements(list_of_numbers)\n    SET closest_pair TO None\n    SET distance TO None\n\n    FOR index IN RANGE FROM 0 TO LENGTH OF list_of_numbers MINUS 1\n        SET element TO list_of_numbers AT index\n        FOR index2 IN RANGE FROM 0 TO LENGTH OF list_of_numbers MINUS 1\n            SET element2 TO list_of_numbers AT index2\n            IF index IS NOT EQUAL TO index2\n                IF distance IS None\n                    SET distance TO ABSOLUTE VALUE OF (element MINUS element2)\n                    SET closest_pair TO TUPLE OF SORTED LIST OF [element, element2]\n                ELSE\n                    SET new_distance TO ABSOLUTE VALUE OF (element MINUS element2)\n                    IF new_distance IS LESS THAN distance\n                        SET distance TO new_distance\n                        SET closest_pair TO TUPLE OF SORTED LIST OF [element, element2]\n                    END IF\n                END IF\n\nPseudocode for Problem 6:\n```\nFUNCTION rounded_avg(integer_n, integer_m)\n    IF NOT (integer_m >= integer_n)\n        RETURN -1\n    SET total_sum TO 0\n    SET cursor TO integer_n\n    WHILE cursor <= integer_m\n        total_sum = total_sum + cursor\n        cursor = cursor + 1\n    SET count_elements TO integer_m - integer_n + 1\n    SET mean_val TO total_sum / count_elements\n    SET nearest_int TO ROUND(mean_val)\n    RETURN CONVERT nearest_int TO BINARY STRING\nEND FUNCTION\n```\n\nModified Pseudocode for Problem 6:\n```\nFUNCTION rounded_avg(integer_n, integer_m)\n    IF integer_m LESS THAN integer_n\n        RETURN -1\n    SET summation TO 0\n    FOR each integer_i FROM integer_n TO integer_m INCLUSIVE\n        INCREMENT summation BY integer_i\n    SET average_value TO summation DIVIDED BY (integer_m MINUS integer_n PLUS 1)\n    SET rounded_average TO ROUND average_value TO NEAREST INTEGER\n    RETURN BINARY REPRESENTATION OF rounded_average\nEND FUNCTION\n```\n\nPseudocode for Problem 7:\n```\nFUNCTION prod_signs(array_of_integers)\n    IF NOT EXISTS element IN array_of_integers THEN\n        RETURN None\n    END IF\n\n    DECLARE product_sign\n    DECLARE negatives_qty\n\n    DECLARE zero_found AS FALSE\n    DECLARE position AS 0\n\n    WHILE NOT zero_found AND position < LENGTH(array_of_integers)\n        IF array_of_integers[position] = 0 THEN\n            zero_found = TRUE\n        ELSE\n            position = position + 1\n        END IF\n    END WHILE\n\n\nModified Pseudocode for Problem 7:\n```\nFUNCTION prod_signs(array_of_integers)\n    IF array_of_integers IS EMPTY\n        RETURN None\n    END IF\n    IF array_of_integers CONTAINS 0\n        SET sign_product TO 0\n    ELSE\n        SET count_of_negative_numbers TO LENGTH OF FILTERED ELEMENTS LESS THAN 0 IN array_of_integers\n        SET sign_product TO (-1) RAISED TO THE POWER OF count_of_negative_numbers\n    END IF\n    SET sum_of_magnitudes TO SUM OF ABSOLUTE VALUES OF EACH ELEMENT IN array_of_integers\n    RETURN sign_product MULTIPLIED BY sum_of_magnitudes\nEND FUNCTION\n```\n\nPseudocode for Problem 8:\n```\nFUNCTION encode_cyclic(input_string)\n    INITIALIZE segments AS an empty array\n    SET total_groups TO ( (LENGTH(input_string) + 2) DIV 3 )\n    SET counter TO 0\n    WHILE counter < total_groups\n        SET start_pos TO 3 * counter\n        SET end_pos TO start_pos + 3\n        IF end_pos > LENGTH(input_string)\n            SET end_pos TO LENGTH(input_string)\n        END IF\n        APPEND SUBSTRING(input_string, start_pos, end_pos) TO segments\n        INCREMENT counter BY 1\n    END WHILE\n\n    INITIALIZE transformed_segments AS empty list\n\n    FOR EACH part IN segments\n        IF part.LENGTH == 3 THEN\n            SET rotated_part TO part[1 to end] + part[0]\n\nModified Pseudocode for Problem 8:\n```\nFUNCTION encode_cyclic(input_string)\n    SET groups TO empty list\n    FOR each index FROM 0 TO (LENGTH OF input_string + 2) INTEGER DIVIDED BY 3 MINUS 1\n        ADD SUBSTRING OF input_string FROM (3 TIMES index) TO MINIMUM OF ((3 TIMES index PLUS 3), LENGTH OF input_string) TO groups\n    SET groups TO empty list\n    FOR each group IN groups\n        IF LENGTH OF group EQUALS 3\n            ADD CONCATENATION OF SUBSTRING OF group FROM SECOND CHARACTER TO END AND FIRST CHARACTER OF group TO groups\n        ELSE\n            ADD group TO groups\n    RETURN CONCATENATION OF ALL ELEMENTS IN groups\nEND FUNCTION\n\nFUNCTION decode_cyclic(input_string)\n    RETURN encode_cyclic(encode_cyclic(input_string))\nEND FUNCTION\n```\nScore of -1*(BLEU Score) for ALL the problems: -0.21721256360769867",
  "iter": 4
}