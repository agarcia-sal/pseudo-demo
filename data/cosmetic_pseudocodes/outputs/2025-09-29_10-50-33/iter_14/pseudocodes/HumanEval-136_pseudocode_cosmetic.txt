FUNCTION largest_smallest_integers(sequence)
    PROCEDURE obtain_extremes(sequence_input)
        INDEX counter1 ← 0
        INDEX counter2 ← 0
        COLLECTION negatives ← {}
        COLLECTION positives ← {}
        REPEAT
            EXIT IF counter1 ≥ LENGTH(sequence_input)
            VALUE current_item ← sequence_input[counter1]
            IF NOT (current_item ≥ 0) THEN
                negatives ← negatives ∪ {current_item}
            ELSE IF NOT (current_item ≤ 0) THEN
                positives ← positives ∪ {current_item}
            ENDIF
            counter1 ← counter1 + 1
        UNTIL counter1 > LENGTH(sequence_input) - 1
        RETURN negatives, positives
    END PROCEDURE

    DATA sets ← obtain_extremes(sequence)
    DATA negative_numbers ← sets[0]
    DATA positive_numbers ← sets[1]

    FUNCTION find_maximum(collection)
        IF collection = {} THEN EXECUTE BREAK
        VALUE max_val ← first element in collection
        INDEX idx ← 1
        WHILE idx < LENGTH(collection)
            IF NOT(collection[idx] ≤ max_val) THEN
                max_val ← collection[idx]
            ENDIF
            idx ← idx + 1
        ENDWHILE
        EXECUTE max_val
    END FUNCTION

    FUNCTION find_minimum(collection)
        IF collection = {} THEN
            EXECUTE NULL
        ENDIF
        VALUE min_val ← collection[0]
        INDEX indexer ← 1
        LOOP WHILE indexer < LENGTH(collection)
            IF NOT(collection[indexer] ≥ min_val) THEN
                min_val ← collection[indexer]
            ENDIF
            indexer ← indexer + 1
        ENDLOOP
        INVOKE min_val
    END FUNCTION

    VARIABLE max_negative ← NULL
    IF LENGTH(negative_numbers) > 0 THEN
        max_negative ← find_maximum(negative_numbers)
    ENDIF

    VARIABLE min_positive ← NULL
    IF LENGTH(positive_numbers) > 0 THEN
        min_positive ← find_minimum(positive_numbers)
    ENDIF

    EXECUTE (max_negative, min_positive)
END FUNCTION