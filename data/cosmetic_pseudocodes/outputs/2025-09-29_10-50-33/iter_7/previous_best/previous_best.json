{
  "prompt": "Given original pseudocode as input, output a functionally identical pseudocode version that is radically transformed in syntax, style, and structure to maximize difference from the original, while strictly observing these constraints:\n\n- **Preserve identically all function names, class names, and their exact hierarchical class/object placements and structures. No change or reordering at these levels is allowed.**\n\n- **The output must be solely the rewritten pseudocode without any explanations, commentary, or delimiters.**\n\nImplement maximally diverse transformations including but not limited to:\n\n1. **Control flow rewrites:** convert loops to recursion or alternative loop types; replace IF-ELSE chains with guard clauses, switch-like constructs, or logical expressions; invert or restructure conditionals using logically equivalent forms.\n\n2. **Variable renaming:** generate novel, meaningful variable and parameter names that share no tokens with originals; rename all temporary, iterator, accumulator identifiers distinctively; keep function/class names exact but rename everything else.\n\n3. **Statement and expression reordering:** reorder independent statements and reorder condition checks to logically equivalent variants without changing semantics; refactor expressions by expanding/shrinking, distributing/combining operators, and substituting equivalent arithmetic or boolean identities.\n\n4. **Keyword, operator, and syntax paraphrasing:** substitute control keywords with synonyms, alternate phrasings, or uncommon keywords consistent with pseudocode conventions; e.g., USE instead of PERFORM, OTHERWISE in place of ELSE; replace operators with equivalent forms; swap between notation styles where unambiguous.\n\n5. **Structural and formatting variation:** adopt diverse indentation styles, mixed inline and multiline statements, modified blank line distributions; change comment style or remove comments entirely; use varied data access syntax such as bracket vs. dot notation where allowed; alter ordering of parameters in calls when semantics allow.\n\n6. **Data structure and call modifications:** replace implicit indexing with explicit indexing or vice versa; use alternative data traversal methods; reorder function arguments when semantically safe; express literals or containers in equivalent but different syntactic forms.\n\nExplicitly forbid:\n\n- Any modification of logic, behavior, output values, or interfaces.\n\n- Any changes to function and class identifiers or their nesting.\n\n- Any reuse of original variable or parameter names except for mandated function/class names.\n\nYour goal is to produce a pseudocode output that is logically and hierarchically identical to the input but that appears as a *completely rewritten program* from a syntactic, stylistic, and structural viewpoint, surpassing previous attempts at maximizing syntactic distance.\n\nDo not provide any explanation or metadata; output only the transformed pseudocode text.",
  "response": "Given original pseudocode as input, output a functionally identical pseudocode version that is radically transformed in syntax, style, and structure to maximize difference from the original, while strictly observing these constraints:\n\n- **Preserve identically all function names, class names, and their exact hierarchical class/object placements and structures. No change or reordering at these levels is allowed.**\n\n- **The output must be solely the rewritten pseudocode without any explanations, commentary, or delimiters.**\n\nImplement maximally diverse transformations including but not limited to:\n\n1. **Control flow rewrites:** convert loops to recursion or alternative loop types; replace IF-ELSE chains with guard clauses, switch-like constructs, or logical expressions; invert or restructure conditionals using logically equivalent forms.\n\n2. **Variable renaming:** generate novel, meaningful variable and parameter names that share no tokens with originals; rename all temporary, iterator, accumulator identifiers distinctively; keep function/class names exact but rename everything else.\n\n3. **Statement and expression reordering:** reorder independent statements and reorder condition checks to logically equivalent variants without changing semantics; refactor expressions by expanding/shrinking, distributing/combining operators, and substituting equivalent arithmetic or boolean identities.\n\n4. **Keyword, operator, and syntax paraphrasing:** substitute control keywords with synonyms, alternate phrasings, or uncommon keywords consistent with pseudocode conventions; e.g., USE instead of PERFORM, OTHERWISE in place of ELSE; replace operators with equivalent forms; swap between notation styles where unambiguous.\n\n5. **Structural and formatting variation:** adopt diverse indentation styles, mixed inline and multiline statements, modified blank line distributions; change comment style or remove comments entirely; use varied data access syntax such as bracket vs. dot notation where allowed; alter ordering of parameters in calls when semantics allow.\n\n6. **Data structure and call modifications:** replace implicit indexing with explicit indexing or vice versa; use alternative data traversal methods; reorder function arguments when semantically safe; express literals or containers in equivalent but different syntactic forms.\n\nExplicitly forbid:\n\n- Any modification of logic, behavior, output values, or interfaces.\n\n- Any changes to function and class identifiers or their nesting.\n\n- Any reuse of original variable or parameter names except for mandated function/class names.\n\nYour goal is to produce a pseudocode output that is logically and hierarchically identical to the input but that appears as a *completely rewritten program* from a syntactic, stylistic, and structural viewpoint, surpassing previous attempts at maximizing syntactic distance.\n\nDo not provide any explanation or metadata; output only the transformed pseudocode text.",
  "score": -0.1068483824067658,
  "feedback": "The following are 20 lines of original pseudocode of a random subset of the problems along with their modified pseudocodes.\n\nPseudocode for Problem 1:\nFUNCTION Strongest_Extension(class_name, extensions)\n    FUNCTION Evaluate_Significance(token)\n        USE uppercase_chars AS FILTER(token, EACH c -> c MATCHES '[A-Z]')\n        USE lowercase_chars AS FILTER(token, EACH c -> c MATCHES '[a-z]')\n        RETURN LENGTH(uppercase_chars) - LENGTH(lowercase_chars)\n    END FUNCTION\n\n    SET peak_extension TO extensions[1]\n    SET peak_score TO Evaluate_Significance(peak_extension)\n\n    PROCEDURE Scan_List(index)\n        EXIT WHEN index > LENGTH(extensions)\n        SET candidate TO extensions[index]\n        SET candidate_score TO Evaluate_Significance(candidate)\n        IF candidate_score <= peak_score THEN\n            USE NONE\n        OTHERWISE\n            peak_extension := candidate\n            peak_score := candidate_score\n        END IF\n\nModified Pseudocode for Problem 1:\n```\nFUNCTION Strongest_Extension(class_name, extensions)\n    SET strong TO extensions AT INDEX 0\n    SET my_val TO COUNT OF LETTERS IN extensions AT INDEX 0 THAT ARE UPPERCASE MINUS COUNT OF LETTERS IN extensions AT INDEX 0 THAT ARE LOWERCASE\n    FOR each s IN extensions\n        SET val TO COUNT OF LETTERS IN s THAT ARE UPPERCASE MINUS COUNT OF LETTERS IN s THAT ARE LOWERCASE\n        IF val GREATER THAN my_val\n            SET strong TO s\n            SET my_val TO val\n        END IF\n    END FOR\n    SET ans TO CONCATENATION OF class_name, \".\", strong\n    RETURN ans\nEND FUNCTION\n```\n\nPseudocode for Problem 2:\nFUNCTION specialFilter(list_of_numbers)\n    DEFINE count_accumulator(accum_count, num_list, current_index)\n        WHEN current_index >= LENGTH OF num_list RETURN accum_count\n\n        LET element = num_list[current_index]\n        LET odd_set = {9, 3, 1, 7, 5}\n        LET sprite = TO_STRING(element)\n        LET head_digit = TO_INTEGER(sprite[0])\n        LET tail_digit = TO_INTEGER(sprite[ LENGTH OF sprite - 1 ])\n\n        IF NOT (element > 10) THEN \n            RETURN count_accumulator(accum_count, num_list, current_index + 1)\n        END WHEN\n\n        IF head_digit NOT IN odd_set THEN \n            RETURN count_accumulator(accum_count, num_list, current_index + 1)\n        END WHEN\n\n        IF tail_digit NOT IN odd_set THEN \n            RETURN count_accumulator(accum_count, num_list, current_index + 1)\n\nModified Pseudocode for Problem 2:\n```\nFUNCTION specialFilter(list_of_numbers)\n    SET count TO 0\n    FOR each number IN list_of_numbers\n        IF number IS GREATER THAN 10\n            SET odd_digits TO (1, 3, 5, 7, 9)\n            SET number_as_string TO STRING REPRESENTATION OF number\n            IF INTEGER VALUE OF FIRST CHARACTER OF number_as_string IS IN odd_digits AND INTEGER VALUE OF LAST CHARACTER OF number_as_string IS IN odd_digits\n                INCREMENT count BY 1\n            END IF\n        END IF\n    END FOR\n    RETURN count\nEND FUNCTION\n```\n\nPseudocode for Problem 3:\nFUNCTION get_max_triples(parameter_count)\n    DECLARE series_tracker AS NEW SEQUENCE\n    PROCEDURE build_series(current_number)\n        IF current_number GREATER THAN parameter_count THEN RETURN\n        ADD ((current_number \u00d7 current_number) - current_number + 1) TO series_tracker\n        INVOKE build_series WITH current_number + 1\n    END PROCEDURE\n    INVOKE build_series WITH 1\n\n    DECLARE triple_collection AS NEW SEQUENCE\n    PROCEDURE enumerate_triples(first_index, second_index, third_index)\n        IF first_index GREATER OR EQUAL TO parameter_count - 2 THEN RETURN\n        IF third_index GREATER OR EQUAL TO parameter_count THEN\n            IF second_index GREATER OR EQUAL TO parameter_count - 1 THEN\n                INVOKE enumerate_triples WITH first_index + 1, first_index + 2, first_index + 3\n            ELSE\n                INVOKE enumerate_triples WITH first_index, second_index + 1, second_index + 2\n            END IF\n            RETURN\n        END IF\n\nModified Pseudocode for Problem 3:\n```\nFUNCTION get_max_triples(integer_n)\n    SET list_A TO EMPTY LIST\n    FOR integer_i FROM 1 TO integer_n INCLUSIVE\n        APPEND (integer_i * integer_i MINUS integer_i PLUS 1) TO list_A\n    SET list_ans TO EMPTY LIST\n    FOR integer_i FROM 0 TO integer_n MINUS 1\n        FOR integer_j FROM integer_i PLUS 1 TO integer_n MINUS 1\n            FOR integer_k FROM integer_j PLUS 1 TO integer_n MINUS 1\n                IF (list_A[integer_i] PLUS list_A[integer_j] PLUS list_A[integer_k]) MODULO 3 EQUALS 0\n                    APPEND (list_A[integer_i], list_A[integer_j], list_A[integer_k]) TO list_ans\n    RETURN LENGTH OF list_ans\nEND FUNCTION\n```\n\nPseudocode for Problem 4:\nFUNCTION bf(celestialA, celestialB)\n    CONST orbits := (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n\n    WHEN celestialA IN orbits AND celestialB IN orbits AND celestialA IS NEQ celestialB\n        LET indexA BE FIND_INDEX(orbits, celestialA)\n        LET indexB BE FIND_INDEX(orbits, celestialB)\n\n        SWITCH TRUE DO\n            CASE indexA < indexB:\n                YIELD SLICE(orbits, indexA + 1, indexB)\n            OTHERWISE:\n                YIELD SLICE(orbits, indexB + 1, indexA)\n        END SWITCH\n    OTHERWISE:\n        YIELD ()\nEND FUNCTION\n\nModified Pseudocode for Problem 4:\n```\nFUNCTION bf(planet1, planet2)\n    SET planet_names TO TUPLE (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    IF planet1 NOT IN planet_names OR planet2 NOT IN planet_names OR planet1 EQUALS planet2\n        RETURN EMPTY TUPLE\n    END IF\n    SET planet1_index TO POSITION OF planet1 IN planet_names\n    SET planet2_index TO POSITION OF planet2 IN planet_names\n    IF planet1_index LESS THAN planet2_index\n        RETURN SUBTUPLE OF planet_names FROM planet1_index + 1 UP TO BUT NOT INCLUDING planet2_index\n    ELSE\n        RETURN SUBTUPLE OF planet_names FROM planet2_index + 1 UP TO BUT NOT INCLUDING planet1_index\n    END IF\nEND FUNCTION\n```\n\nPseudocode for Problem 5:\nFUNCTION eat(amount, required, balance)\n  SWITCH TRUE\n    CASE required <= balance:\n      USE return WITH [amount + required, balance - required]\n    OTHERWISE:\n      USE return WITH [amount + balance, 0]\nEND FUNCTION\n\nModified Pseudocode for Problem 5:\n```\nFUNCTION eat(number, need, remaining)\n    IF need IS LESS THAN OR EQUAL TO remaining\n        RETURN LIST OF [number PLUS need, remaining MINUS need]\n    ELSE\n        RETURN LIST OF [number PLUS remaining, 0]\nEND FUNCTION\n```\n\nPseudocode for Problem 6:\nFUNCTION x_or_y(count, alpha, beta)\n    DEFINE PROCEDURE check_divisor(divisor)\n        IF divisor GREATER_THAN_OR_EQUAL TO count THEN\n            RETURN alpha\n        IF (count REMAINDER divisor) EQUALS 0 THEN\n            RETURN beta\n        RETURN check_divisor(divisor + 1)\n    RETURN beta IF count EQUALS 1 OTHERWISE check_divisor(2)\n\nModified Pseudocode for Problem 6:\n```\nFUNCTION x_or_y(n, x, y)\n    IF n IS EQUAL TO 1\n        RETURN y\n    FOR each integer i FROM 2 TO n MINUS 1\n        IF n MODULO i IS EQUAL TO 0\n            RETURN y\n            BREAK LOOP\n    ELSE\n        RETURN x\nEND FUNCTION\n```\n\nPseudocode for Problem 7:\nFUNCTION check_if_last_char_is_a_letter(input_string)  \n    DEFINE function is_ascii_alpha(character)  \n        RETURN (ASCII(character) >= 97) AND (ASCII(character) <= 122)  \n    END DEFINE  \n  \n    LET words_array GETS input_string SPLIT BY \" \"  \n    LET final_token GETS words_array[ LENGTH(words_array) - 1 ]  \n  \n    GUARD LENGTH(final_token) <> 1 OTHERWISE  \n        IF is_ascii_alpha( TO_LOWER(final_token) ) THEN\n            RETURN True\n        ELSE\n            RETURN False\n        END IF  \n    END GUARD  \n  \n    RETURN False\nEND FUNCTION\n\nModified Pseudocode for Problem 7:\n```\nFUNCTION check_if_last_char_is_a_letter(text)\n    SET last_element TO SPLIT text BY SPACE AND TAKE LAST ELEMENT\n    IF LENGTH OF last_element EQUALS 1 AND ASCII CODE OF LOWERCASE last_element IS BETWEEN 97 AND 122 INCLUSIVE\n        RETURN True\n    ELSE\n        RETURN False\nEND FUNCTION\n```\n\nPseudocode for Problem 8:\nFUNCTION do_algebra(commands_array, values_array)\n  LET formula_text BE CONVERT_TO_STRING(values_array[0])\n  \n  PROCEDURE append_terms(index)\n    IF index >= LENGTH(commands_array) THEN EXIT\n    LET current_command BE commands_array[index]\n    LET current_value BE values_array[index]\n    formula_text = formula_text + current_command + CONVERT_TO_STRING(current_value)\n    append_terms(index + 1)\n  END PROCEDURE\n  \n  append_terms(1)\n  \n  RETURN INTERPRET_AS_EXPRESSION(formula_text)\nEND FUNCTION\n\nModified Pseudocode for Problem 8:\n```\nFUNCTION do_algebra(list_of_operators, list_of_operands)\n    SET expression_string TO STRING REPRESENTATION OF FIRST ELEMENT IN list_of_operands\n    FOR each operator_symbol, operand_value IN ZIP OF list_of_operators AND list_of_operands STARTING FROM SECOND ELEMENT\n        CONCATENATE operator_symbol AND STRING REPRESENTATION OF operand_value TO expression_string\n    END FOR\n    RETURN EVALUATION OF expression_string AS AN ALGEBRAIC EXPRESSION\nEND FUNCTION\n```\nScore of -1*(BLEU Score) for ALL the problems: -0.1068483824067658",
  "iter": 6
}