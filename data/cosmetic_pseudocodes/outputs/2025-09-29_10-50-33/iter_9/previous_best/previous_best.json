{
  "prompt": "Given any input pseudocode, produce a semantically equivalent pseudocode that is radically rewritten to maximize syntactic, stylistic, and structural divergence from the original, strictly enforcing these rules:\n\n- **Retain all original function and class names verbatim, preserving their exact nesting and inheritance hierarchies; no changes or reorderings of these identifiers or their hierarchical structures are allowed.**\n\n- **Output should be precisely the transformed pseudocode alone, with no explanations, comments, delimiters, or metadata.**\n\nApply pervasive, creative, and diverse rewrites at all other levels, including but not limited to:\n\n1. **Control Flow Remodeling:** Replace iterative loops with recursion or alternative iteration constructs (e.g., WHILE, DO-WHILE, recursion, or tail calls); convert IF-ELSE chains into switch-case analogues, guard clauses, ternary patterns, or boolean short-circuit expressions; invert, distribute, or restructure conditionals through logically equivalent boolean algebra transformations.\n\n2. **Systematic Renaming:** Invent brand-new, meaningful, and contextually plausible variable and parameter names completely disjoint from the original tokens; rename all local identifiers, temporaries, loop counters, accumulators, and intermediate data holders; only the original function and class names must remain unchanged.\n\n3. **Statement and Expression Reorganization:** Reorder independent statements and reorder or regroup conditionals and boolean tests while preserving semantics; extensively refactor expressions by expanding or factoring, pushing negations inward/outward, applying arithmetic and logical identities, and converting between equivalent operator sets (e.g., \u2264 to \u00ac >, +0 to identity, De Morgan\u2019s laws).\n\n4. **Keyword and Syntax Diversification:** Substitute standard control keywords with less common synonyms or pseudocode-style variants consistent with general pseudocode conventions (e.g., REPEAT\u2026UNTIL, EXECUTE, INVOKE, BREAK instead of RETURN where semantically fitting); replace infix with prefix expressions or vice versa where unambiguous; swap dot notation and bracket notation for data access where valid; employ varied parameter passing styles (positional to named, reorder arguments if behaviorally safe).\n\n5. **Structural and Formatting Variability:** Alter indentation schemes, line breaks, and inline/multiline mixing; optionally remove or transform comments into alternate styles or omit entirely; rearrange blank lines and spacing to produce distinct visual structure while retaining logical blocks.\n\n6. **Data Structure and Access Transformation:** Swap implicit iteration mechanisms for explicit indexing and vice versa; use alternate traversal strategies (e.g., unrolling, mapping, filtering with lambdas, explicit iterator patterns); represent literals and containers in semantically equivalent but syntactically different forms (e.g., sets as lists or tuples); reorder function call arguments wherever safely permissible.\n\nStrictly prohibit:\n\n- Any modification to program semantics, logic, output, side effects, or interface signatures.\n\n- Any alteration of function or class identifiers or their exact nesting relationships.\n\n- Any reuse or retention of original variable or parameter names\u2014except for function and class names\u2014as this undermines maximal syntactic difference.\n\nYour produced pseudocode must preserve the complete hierarchical class/object-function organization and produce a reimagined, syntactically distant version of the input that would appear as an independently authored program fulfilling the same role.\n\nOutput ONLY the transformed pseudocode text.",
  "response": "Given any input pseudocode, produce a semantically equivalent pseudocode that is radically rewritten to maximize syntactic, stylistic, and structural divergence from the original, strictly enforcing these rules:\n\n- **Retain all original function and class names verbatim, preserving their exact nesting and inheritance hierarchies; no changes or reorderings of these identifiers or their hierarchical structures are allowed.**\n\n- **Output should be precisely the transformed pseudocode alone, with no explanations, comments, delimiters, or metadata.**\n\nApply pervasive, creative, and diverse rewrites at all other levels, including but not limited to:\n\n1. **Control Flow Remodeling:** Replace iterative loops with recursion or alternative iteration constructs (e.g., WHILE, DO-WHILE, recursion, or tail calls); convert IF-ELSE chains into switch-case analogues, guard clauses, ternary patterns, or boolean short-circuit expressions; invert, distribute, or restructure conditionals through logically equivalent boolean algebra transformations.\n\n2. **Systematic Renaming:** Invent brand-new, meaningful, and contextually plausible variable and parameter names completely disjoint from the original tokens; rename all local identifiers, temporaries, loop counters, accumulators, and intermediate data holders; only the original function and class names must remain unchanged.\n\n3. **Statement and Expression Reorganization:** Reorder independent statements and reorder or regroup conditionals and boolean tests while preserving semantics; extensively refactor expressions by expanding or factoring, pushing negations inward/outward, applying arithmetic and logical identities, and converting between equivalent operator sets (e.g., \u2264 to \u00ac >, +0 to identity, De Morgan\u2019s laws).\n\n4. **Keyword and Syntax Diversification:** Substitute standard control keywords with less common synonyms or pseudocode-style variants consistent with general pseudocode conventions (e.g., REPEAT\u2026UNTIL, EXECUTE, INVOKE, BREAK instead of RETURN where semantically fitting); replace infix with prefix expressions or vice versa where unambiguous; swap dot notation and bracket notation for data access where valid; employ varied parameter passing styles (positional to named, reorder arguments if behaviorally safe).\n\n5. **Structural and Formatting Variability:** Alter indentation schemes, line breaks, and inline/multiline mixing; optionally remove or transform comments into alternate styles or omit entirely; rearrange blank lines and spacing to produce distinct visual structure while retaining logical blocks.\n\n6. **Data Structure and Access Transformation:** Swap implicit iteration mechanisms for explicit indexing and vice versa; use alternate traversal strategies (e.g., unrolling, mapping, filtering with lambdas, explicit iterator patterns); represent literals and containers in semantically equivalent but syntactically different forms (e.g., sets as lists or tuples); reorder function call arguments wherever safely permissible.\n\nStrictly prohibit:\n\n- Any modification to program semantics, logic, output, side effects, or interface signatures.\n\n- Any alteration of function or class identifiers or their exact nesting relationships.\n\n- Any reuse or retention of original variable or parameter names\u2014except for function and class names\u2014as this undermines maximal syntactic difference.\n\nYour produced pseudocode must preserve the complete hierarchical class/object-function organization and produce a reimagined, syntactically distant version of the input that would appear as an independently authored program fulfilling the same role.\n\nOutput ONLY the transformed pseudocode text.",
  "score": -0.09160107044729252,
  "feedback": "The following are 20 lines of original pseudocode of a random subset of the problems along with their modified pseudocodes.\n\nPseudocode for Problem 1:\nFUNCTION get_max_triples(n: integer)\n  PROCEDURE build_sequence(index: integer, acc: list)\n    IF index > n THEN\n      EXECUTE acc\n    ELSE\n      INVOKE build_sequence(index + 1, acc + [(index * index) - index + 1])\n    ENDIF\n  END PROCEDURE\n\n  PROCEDURE find_valid_combinations(a_seq: list, left: integer, mid: integer, right: integer, collected: list)\n    IF left >= n - 2 THEN\n      EXECUTE LENGTH(collected)\n    ELSIF mid >= n - 1 THEN\n      INVOKE find_valid_combinations(a_seq, left + 1, left + 2, left + 3, collected)\n    ELSIF right >= n THEN\n      INVOKE find_valid_combinations(a_seq, left, mid + 1, mid + 2, collected)\n    ELSE\n      SET total_sum TO a_seq[left] + a_seq[mid] + a_seq[right]\n      SET updated_collected TO (total_sum MOD 3 = 0) ? collected + [(a_seq[left], a_seq[mid], a_seq[right])] : collected\n      INVOKE find_valid_combinations(a_seq, left, mid, right + 1, updated_collected)\n\nModified Pseudocode for Problem 1:\n```\nFUNCTION get_max_triples(integer_n)\n    SET list_A TO EMPTY LIST\n    FOR integer_i FROM 1 TO integer_n INCLUSIVE\n        APPEND (integer_i * integer_i MINUS integer_i PLUS 1) TO list_A\n    SET list_ans TO EMPTY LIST\n    FOR integer_i FROM 0 TO integer_n MINUS 1\n        FOR integer_j FROM integer_i PLUS 1 TO integer_n MINUS 1\n            FOR integer_k FROM integer_j PLUS 1 TO integer_n MINUS 1\n                IF (list_A[integer_i] PLUS list_A[integer_j] PLUS list_A[integer_k]) MODULO 3 EQUALS 0\n                    APPEND (list_A[integer_i], list_A[integer_j], list_A[integer_k]) TO list_ans\n    RETURN LENGTH OF list_ans\nEND FUNCTION\n```\n\nPseudocode for Problem 2:\nFUNCTION do_algebra(an_operator_collection, an_operand_sequence)\n  DEFINE compose_expression(index = 1, accumulated_text = TO_STRING(an_operand_sequence[0]))\n    IF index >= LENGTH OF an_operand_sequence THEN\n      EXECUTE EVALUATE(accumulated_text)\n    ELSE\n      DEFINE next_text = accumulated_text + an_operator_collection[index - 1] + TO_STRING(an_operand_sequence[index])\n      INVOKE compose_expression(index + 1, next_text)\n    END IF\n  END DEFINE\n\n  INVOKE compose_expression()\nEND FUNCTION\n\nModified Pseudocode for Problem 2:\n```\nFUNCTION do_algebra(list_of_operators, list_of_operands)\n    SET expression_string TO STRING REPRESENTATION OF FIRST ELEMENT IN list_of_operands\n    FOR each operator_symbol, operand_value IN ZIP OF list_of_operators AND list_of_operands STARTING FROM SECOND ELEMENT\n        CONCATENATE operator_symbol AND STRING REPRESENTATION OF operand_value TO expression_string\n    END FOR\n    RETURN EVALUATION OF expression_string AS AN ALGEBRAIC EXPRESSION\nEND FUNCTION\n```\n\nPseudocode for Problem 3:\nFUNCTION order_by_points(sequence_of_values)\n  FUNCTION digits_sum(value)\n    EXECUTE abs_adjustment WITH (input_num = value, multiplier = 1)\n\n    FUNCTION abs_adjustment(input_num, multiplier)\n      WHEN NOT (input_num < 0)\n        PASS\n      OTHERWISE\n        input_num = 0 - input_num\n        multiplier = 0 - multiplier\n      END WHEN\n      EXECUTE digits_extraction WITH (num = input_num, sign = multiplier)\n    END FUNCTION\n\n    FUNCTION digits_extraction(num, sign)\n      DECLARE digits_array AS EMPTY LIST\n      DECLARE temp_num = num\n\n      WHILE temp_num > 0\n        APPEND (temp_num MOD 10) TO digits_array\n\nModified Pseudocode for Problem 3:\n```\nFUNCTION order_by_points(list_of_numbers)\n    FUNCTION digits_sum(number)\n        SET sign_indicator TO 1\n        IF number IS LESS THAN 0\n            SET number TO NEGATIVE number\n            SET sign_indicator TO -1\n        END IF\n        SET digits_list TO CONVERT number TO LIST OF INTEGERS REPRESENTING EACH DIGIT\n        MULTIPLY digits_list FIRST ELEMENT BY sign_indicator\n        RETURN SUM OF digits_list\n    END FUNCTION\n    RETURN list_of_numbers SORTED BY KEY digits_sum\nEND FUNCTION\n```\n\nPseudocode for Problem 4:\nFUNCTION simplify(dividend_str, divisor_str)\n    EXECUTE FUNCTION parseFraction WITH fraction = dividend_str GIVE top_val, bottom_val\n    EXECUTE FUNCTION parseFraction WITH fraction = divisor_str GIVE top_factor, bottom_factor\n\n    EXECUTE FUNCTION parseFraction(fraction)\n        SPLIT fraction INTO parts USING \"/\"\n        RETURN INTEGER(parts[1]) AND INTEGER(parts[2])\n    END FUNCTION\n\n    SET numerator_product TO top_val * top_factor\n    SET denominator_product TO bottom_val * bottom_factor\n\n    EXECUTE FUNCTION isIntegerDivision(num, den)\n        SET division_result TO num / den\n        IF (division_result - FLOOR(division_result)) = 0 THEN RETURN True\n        OTHERWISE RETURN False\n    END FUNCTION\n\n    IF NOT NOT isIntegerDivision(numerator_product, denominator_product)\n        INVOKE BREAK WITH True\n\nModified Pseudocode for Problem 4:\n```\nFUNCTION simplify(fraction_x, fraction_n)\n    SPLIT fraction_x BY \"/\" INTO numerator_x, denominator_x\n    SPLIT fraction_n BY \"/\" INTO numerator_n, denominator_n\n    SET product_numerator TO INTEGER VALUE OF numerator_x MULTIPLIED BY INTEGER VALUE OF numerator_n\n    SET product_denominator TO INTEGER VALUE OF denominator_x MULTIPLIED BY INTEGER VALUE OF denominator_n\n    IF product_numerator DIVIDED BY product_denominator EQUALS INTEGER VALUE OF (product_numerator DIVIDED BY product_denominator)\n        RETURN True\n    END IF\n    RETURN False\nEND FUNCTION\n```\n\nPseudocode for Problem 5:\nFUNCTION right_angle_triangle(alpha, beta, gamma)\n    EXECUTE\n        IF (NOT (alpha * alpha > beta * beta + gamma * gamma)) AND \n           (NOT (beta * beta > alpha * alpha + gamma * gamma)) THEN \n            IF (NOT (gamma * gamma > alpha * alpha + beta * beta)) THEN \n                INVOKE BREAK true\n            ENDIF\n        ENDIF\n        INVOKE BREAK false\n    END EXECUTE\nEND FUNCTION\n\nModified Pseudocode for Problem 5:\n```\nFUNCTION right_angle_triangle(a, b, c)\n    RETURN (a MULTIPLIED BY a EQUALS b MULTIPLIED BY b PLUS c MULTIPLIED BY c)\n        OR (b MULTIPLIED BY b EQUALS a MULTIPLIED BY a PLUS c MULTIPLIED BY c)\n        OR (c MULTIPLIED BY c EQUALS a MULTIPLIED BY a PLUS b MULTIPLIED BY b)\nEND FUNCTION\n```\n\nPseudocode for Problem 6:\nFUNCTION eat(amount, desire, supply)\n    EXECUTE CASE WHEN desire > supply THEN\n        BREAK [supply + amount, 0]\n    ELSE\n        BREAK [desire + amount, supply - desire]\n    END CASE\nEND FUNCTION\n\nModified Pseudocode for Problem 6:\n```\nFUNCTION eat(number, need, remaining)\n    IF need IS LESS THAN OR EQUAL TO remaining\n        RETURN LIST OF [number PLUS need, remaining MINUS need]\n    ELSE\n        RETURN LIST OF [number PLUS remaining, 0]\nEND FUNCTION\n```\n\nPseudocode for Problem 7:\nFUNCTION x_or_y(value, alpha, beta)\n    PROCEDURE analyze_divisor(current, limit, fallback)\n        IF current > limit THEN EXECUTE STOP\n        (current MODULO value = 0) AND DO\n            BREAK EXECUTION fallback\n        OTHERWISE\n            INVOKE analyze_divisor(current + 1, limit, fallback)\n    END PROCEDURE\n    \n    IF value = 1 THEN\n        BREAK EXECUTION beta\n    ELSE\n        EXECUTE analyze_divisor(2, value - 1, beta)\n        RETURN alpha\n    END IF\nEND FUNCTION\n\nModified Pseudocode for Problem 7:\n```\nFUNCTION x_or_y(n, x, y)\n    IF n IS EQUAL TO 1\n        RETURN y\n    FOR each integer i FROM 2 TO n MINUS 1\n        IF n MODULO i IS EQUAL TO 0\n            RETURN y\n            BREAK LOOP\n    ELSE\n        RETURN x\nEND FUNCTION\n```\n\nPseudocode for Problem 8:\nFUNCTION solve(sourceText)\n  DEFINE toggleCaseAt(position, textArray)\n    IF (NOT ((textArray[position] >= 'a' AND textArray[position] <= 'z') OR (textArray[position] >= 'A' AND textArray[position] <= 'Z')))\n      EXECUTE\n        RETURN\n      END EXECUTE\n    ELSE\n      textArray[position] <- IF (textArray[position] >= 'a' AND textArray[position] <= 'z') THEN TO_UPPER(textArray[position]) ELSE TO_LOWER(textArray[position])\n    END IF\n  END DEFINE\n\n  FLAG_SWITCH <- FALSE\n  charsList <- SPLIT_TO_ARRAY(sourceText)\n  \n  PROCEDURE processAtPosition(pos)\n    IF pos >= LENGTH(charsList)\n      BREAK\n    END IF\n\n    CONDITIONAL isAlpha <- (('a' <= charsList[pos]) AND (charsList[pos] <= 'z')) OR (('A' <= charsList[pos]) AND (charsList[pos] <= 'Z'))\n\nModified Pseudocode for Problem 8:\n```\nFUNCTION solve(string_input)\n    SET flag TO 0\n    SET index TO 0\n    SET new_string_list TO LIST OF CHARACTERS IN string_input\n    FOR each character IN string_input\n        IF character IS ALPHABETICAL LETTER\n            SET new_string_list[index] TO character WITH CASE REVERSED\n            SET flag TO 1\n        END IF\n        INCREMENT index BY 1\n    END FOR\n    SET string_result TO EMPTY STRING\n    FOR each character IN new_string_list\n        CONCATENATE character TO string_result\n    END FOR\n    IF flag EQUALS 0\n        RETURN string_result REVERSED\n    END IF\n    RETURN string_result\nScore of -1*(BLEU Score) for ALL the problems: -0.09160107044729252",
  "iter": 8
}