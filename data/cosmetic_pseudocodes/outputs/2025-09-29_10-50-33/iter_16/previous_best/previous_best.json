{
  "prompt": "Given any input pseudocode, transform it into a semantically equivalent pseudocode version that is profoundly and systematically reimagined to maximize syntactic, stylistic, and structural distance from the original pseudocode, abiding by these strict directives:\n\n- Preserve **all original function and class names identically**, maintaining their full nesting, scope, and inheritance structure exactly; these identifiers and their hierarchical arrangements must not be renamed, reordered, or modified in any way.\n\n- Output **only the transformed pseudocode text** with no additional explanation, comments, delimiters, or metadata.\n\nApply extensive, multifaceted rewriting at every other level\u2014employing a wide, varied palette of transformations including but not limited to:\n\n1. **Control Flow Restructuring:** Replace all loops with alternative constructs (e.g., convert FOR loops to WHILE, DO-WHILE, or recursion); transform IF-ELSE chains into switch/case analogies, guard conditions, ternary operators, or boolean short-circuit patterns; invert and distribute conditions using boolean algebra equivalences (De Morgan\u2019s, double negation, distributive laws); split or merge conditionals strategically to produce novel branching structures that retain logic but differ substantially in flow and readability.\n\n2. **Systematic Identifier Renaming:** Rename every local variable, parameter, temporary, accumulator, iterator, and intermediate container to freshly coined, meaningful names wholly distinct and unrelated to the original identifiers; generate plausible but novel token names ensuring zero overlap with original local variables; **only function and class names remain unchanged**. Vary not only identifiers but also parameter naming and argument passing styles (positional vs named) when semantics allow.\n\n3. **Statement & Expression Transformation:** Decompose, reorder, and regroup independent statements and sub-expressions freely, as long as semantic equivalence is conserved; rewrite arithmetic and logical expressions by expanding/factoring, pushing or pulling negations, applying equivalences (e.g., replace \u201ca \u2264 b\u201d with \u201cNOT (a > b)\u201d), convert between prefix, infix, and postfix notation as appropriate; reorder function arguments where it causes no side effects; convert attribute access between dot and bracket notations where valid.\n\n4. **Keyword and Syntax Variation:** Substitute canonical control keywords with valid but less common synonyms or custom pseudocode constructs consistent with the domain (e.g., EXECUTE, INVOKE, REPEAT\u2026UNTIL, BREAK instead of RETURN); introduce alternative parameter passing styles (explicit named arguments, tuples, destructured parameters) where applicable; use mixed indentation, line breaking, and inline/multiline statements to alter code appearance dramatically.\n\n5. **Structural, Formatting, and Organizing Changes:** Vary indentation depth and style (tabs, spaces, mixed), adjust spacing and line breaks liberally, reorder logically independent blocks or statements, optionally inline short functions or break long expressions across lines; preserve original hierarchical organization of classes and functions, but diversify internal structural layout and flow presentation.\n\n6. **Data Structure and Access Reformulation:** Alter container types and representation (e.g., convert sets to lists or tuples), switch implicit iteration to explicit indexing and vice versa; employ alternate traversal strategies such as iterator patterns, filtering with lambdas, loop unrolling; remap literal representations and constants to equivalent but syntactically distinct forms (e.g., \u201c0\u201d as \u201cFALSE\u201d where semantically valid).\n\nStrictly enforce:\n\n- No alteration of program semantics, functional behavior, output, side effects, or interface signatures beyond the local variable renaming and flow restructuring allowed.\n\n- No modification, renaming, reordering, or restructuring of function or class identifiers or their exact containment hierarchies.\n\n- Zero retention or reuse of original local variable or parameter names\u2014complete obliteration of original tokens except function and class identifiers.\n\nYour output must maintain the same function/class architecture while presenting a pseudocode version so syntactically detached and stylistically novel that it appears as an entirely independently authored but semantically identical program.\n\nOutput nothing besides the transformed pseudocode itself.",
  "response": "Given any input pseudocode, transform it into a semantically equivalent pseudocode version that is profoundly and systematically reimagined to maximize syntactic, stylistic, and structural distance from the original pseudocode, abiding by these strict directives:\n\n- Preserve **all original function and class names identically**, maintaining their full nesting, scope, and inheritance structure exactly; these identifiers and their hierarchical arrangements must not be renamed, reordered, or modified in any way.\n\n- Output **only the transformed pseudocode text** with no additional explanation, comments, delimiters, or metadata.\n\nApply extensive, multifaceted rewriting at every other level\u2014employing a wide, varied palette of transformations including but not limited to:\n\n1. **Control Flow Restructuring:** Replace all loops with alternative constructs (e.g., convert FOR loops to WHILE, DO-WHILE, or recursion); transform IF-ELSE chains into switch/case analogies, guard conditions, ternary operators, or boolean short-circuit patterns; invert and distribute conditions using boolean algebra equivalences (De Morgan\u2019s, double negation, distributive laws); split or merge conditionals strategically to produce novel branching structures that retain logic but differ substantially in flow and readability.\n\n2. **Systematic Identifier Renaming:** Rename every local variable, parameter, temporary, accumulator, iterator, and intermediate container to freshly coined, meaningful names wholly distinct and unrelated to the original identifiers; generate plausible but novel token names ensuring zero overlap with original local variables; **only function and class names remain unchanged**. Vary not only identifiers but also parameter naming and argument passing styles (positional vs named) when semantics allow.\n\n3. **Statement & Expression Transformation:** Decompose, reorder, and regroup independent statements and sub-expressions freely, as long as semantic equivalence is conserved; rewrite arithmetic and logical expressions by expanding/factoring, pushing or pulling negations, applying equivalences (e.g., replace \u201ca \u2264 b\u201d with \u201cNOT (a > b)\u201d), convert between prefix, infix, and postfix notation as appropriate; reorder function arguments where it causes no side effects; convert attribute access between dot and bracket notations where valid.\n\n4. **Keyword and Syntax Variation:** Substitute canonical control keywords with valid but less common synonyms or custom pseudocode constructs consistent with the domain (e.g., EXECUTE, INVOKE, REPEAT\u2026UNTIL, BREAK instead of RETURN); introduce alternative parameter passing styles (explicit named arguments, tuples, destructured parameters) where applicable; use mixed indentation, line breaking, and inline/multiline statements to alter code appearance dramatically.\n\n5. **Structural, Formatting, and Organizing Changes:** Vary indentation depth and style (tabs, spaces, mixed), adjust spacing and line breaks liberally, reorder logically independent blocks or statements, optionally inline short functions or break long expressions across lines; preserve original hierarchical organization of classes and functions, but diversify internal structural layout and flow presentation.\n\n6. **Data Structure and Access Reformulation:** Alter container types and representation (e.g., convert sets to lists or tuples), switch implicit iteration to explicit indexing and vice versa; employ alternate traversal strategies such as iterator patterns, filtering with lambdas, loop unrolling; remap literal representations and constants to equivalent but syntactically distinct forms (e.g., \u201c0\u201d as \u201cFALSE\u201d where semantically valid).\n\nStrictly enforce:\n\n- No alteration of program semantics, functional behavior, output, side effects, or interface signatures beyond the local variable renaming and flow restructuring allowed.\n\n- No modification, renaming, reordering, or restructuring of function or class identifiers or their exact containment hierarchies.\n\n- Zero retention or reuse of original local variable or parameter names\u2014complete obliteration of original tokens except function and class identifiers.\n\nYour output must maintain the same function/class architecture while presenting a pseudocode version so syntactically detached and stylistically novel that it appears as an entirely independently authored but semantically identical program.\n\nOutput nothing besides the transformed pseudocode itself.",
  "score": -0.07934956895998933,
  "feedback": "The following are 20 lines of original pseudocode of a random subset of the problems along with their modified pseudocodes.\n\nPseudocode for Problem 1:\nFUNCTION generate_integers(first_number, second_number)\n\titer_pos \u2190 lower_cap \u2190 higher_cap \u2190 ZERO_PLACEHOLDER\n\tlowest_limit \u2190 (2 > (first_number < second_number ? first_number : second_number)) ? 2 : (first_number < second_number ? first_number : second_number)\n\thighest_limit \u2190 (8 < (first_number > second_number ? first_number : second_number)) ? 8 : (first_number > second_number ? first_number : second_number)\n\t\n\tcollected_values \u2190 EMPTY_SEQUENCE\n\titer_pos \u2190 lowest_limit\n\tREPEAT\n\t\tEXIT_LOOP IF iter_pos > highest_limit\n\t\t( iter_pos % 2 == 0 ) AND (collected_values \u2190 collected_values + (iter_pos,))\n\t\titer_pos \u2190 iter_pos + 1\n\tCONTINUE\n\tRETURN collected_values\nEND FUNCTION\n\nModified Pseudocode for Problem 1:\n```\nFUNCTION generate_integers(integer_a, integer_b)\n    SET lower_bound TO MAXIMUM OF 2 AND MINIMUM OF integer_a AND integer_b\n    SET upper_bound TO MINIMUM OF 8 AND MAXIMUM OF integer_a AND integer_b\n    RETURN LIST OF each integer_i FOR integer_i IN RANGE FROM lower_bound TO upper_bound INCLUSIVE WHERE integer_i MODULO 2 EQUALS 0\nEND FUNCTION\n```\n\nPseudocode for Problem 2:\nFUNCTION eat(amountTotal, requirement, leftoverAmount)\n\tREPEAT\n\t\tIF NOT (requirement > leftoverAmount)\n\t\t\tEXECUTE\n\t\t\t\taccumulator := amountTotal + requirement\n\t\t\t\tdifference := leftoverAmount - requirement\n\t\t\t\tEXIT accumulator, difference\n\t\tEND IF\n\t\t\n\t\tEXECUTE\n\t\t\taccumulator := amountTotal + leftoverAmount\n\t\t\tdifference := FALSE\n\t\t\tEXIT accumulator, difference\n\n\tUNTIL TRUE\nEND FUNCTION\n\nModified Pseudocode for Problem 2:\n```\nFUNCTION eat(number, need, remaining)\n    IF need IS LESS THAN OR EQUAL TO remaining\n        RETURN LIST OF [number PLUS need, remaining MINUS need]\n    ELSE\n        RETURN LIST OF [number PLUS remaining, 0]\nEND FUNCTION\n```\n\nPseudocode for Problem 3:\nFUNCTION bf( argAlpha,  argBeta )\n  LET celestialSet := ( \"Mercury\", \"Venus\",  \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\" )\n  \n  IF NOT ( argAlpha IN celestialSet ) THEN \n    EXECUTE RETURN ( ) \n  ELSE IF NOT ( argBeta IN celestialSet ) THEN \n    EXECUTE RETURN ( )\n  ELSE\n    IF (argAlpha = argBeta) THEN \n      EXECUTE RETURN ( )\n    END IF\n  END IF\n  \n  LET alphaPos := 0\n  LET indexFinder := 0\n  WHILE indexFinder < #celestialSet DO\n    IF celestialSet[ indexFinder ] = argAlpha THEN\n      alphaPos := indexFinder\n      BREAK\n    END IF\n\nModified Pseudocode for Problem 3:\n```\nFUNCTION bf(planet1, planet2)\n    SET planet_names TO TUPLE (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\")\n    IF planet1 NOT IN planet_names OR planet2 NOT IN planet_names OR planet1 EQUALS planet2\n        RETURN EMPTY TUPLE\n    END IF\n    SET planet1_index TO POSITION OF planet1 IN planet_names\n    SET planet2_index TO POSITION OF planet2 IN planet_names\n    IF planet1_index LESS THAN planet2_index\n        RETURN SUBTUPLE OF planet_names FROM planet1_index + 1 UP TO BUT NOT INCLUDING planet2_index\n    ELSE\n        RETURN SUBTUPLE OF planet_names FROM planet2_index + 1 UP TO BUT NOT INCLUDING planet1_index\n    END IF\nEND FUNCTION\n```\n\nPseudocode for Problem 4:\nFUNCTION do_algebra(ops_collection, nums_collection)\n\texpression_accumulator := CAST_TO_STRING(nums_collection[0])\n\tindex_counter := 1\n\trepeat_loop:\n\t\tIF NOT (index_counter < LENGTH(ops_collection) + 1) THEN\n\t\t\tGOTO loop_exit\n\t\tEND IF\n\t\tcurrent_operator = ops_collection[index_counter - 1]\n\t\tcurrent_operand = nums_collection[index_counter]\n\t\texpression_accumulator = CONCATENATE(expression_accumulator, CAST_TO_STRING(current_operand))\n\t\texpression_accumulator = CONCATENATE(expression_accumulator, current_operator)\n\t\tindex_counter = index_counter + 1\n\t\tGOTO repeat_loop\n\tloop_exit:\n\tfinal_expression := EVALUATE(expression_accumulator)\n\tBREAK final_expression\nEND FUNCTION\n\nModified Pseudocode for Problem 4:\n```\nFUNCTION do_algebra(list_of_operators, list_of_operands)\n    SET expression_string TO STRING REPRESENTATION OF FIRST ELEMENT IN list_of_operands\n    FOR each operator_symbol, operand_value IN ZIP OF list_of_operators AND list_of_operands STARTING FROM SECOND ELEMENT\n        CONCATENATE operator_symbol AND STRING REPRESENTATION OF operand_value TO expression_string\n    END FOR\n    RETURN EVALUATION OF expression_string AS AN ALGEBRAIC EXPRESSION\nEND FUNCTION\n```\n\nPseudocode for Problem 5:\nFUNCTION check_if_last_char_is_a_letter(input_str)\n\t  DECLARE index_tracker = 0\n\t  DECLARE word_collection = []\n\t  \n\t  WHILE index_tracker < LEN(input_str)\n\t\t\t  DECLARE temp_char = input_str[index_tracker]\n\t\t\t  IF temp_char != ' '\n\t\t\t\t  word_collection APPEND temp_char TO (word_collection[-1] IF LEN(word_collection) > 0 ELSE '')\n\t\t\t  ELSE\n\t\t\t\t  IF LEN(word_collection) == 0 OR word_collection[-1] == ''\n\t\t\t\t\t  word_collection APPEND ''\n\t\t\t\t  END IF\n\t\t\t  END IF\n\t\t\t  index_tracker = index_tracker + 1\n\t  END WHILE\n\t\n\t  DECLARE extracted_word = ''\n\t  IF LEN(word_collection) != 0\n\t\t\t  extracted_word = word_collection[LEN(word_collection) - 1]\n\t  END IF\n\nModified Pseudocode for Problem 5:\n```\nFUNCTION check_if_last_char_is_a_letter(text)\n    SET last_element TO SPLIT text BY SPACE AND TAKE LAST ELEMENT\n    IF LENGTH OF last_element EQUALS 1 AND ASCII CODE OF LOWERCASE last_element IS BETWEEN 97 AND 122 INCLUSIVE\n        RETURN True\n    ELSE\n        RETURN False\nEND FUNCTION\n```\n\nPseudocode for Problem 6:\nFUNCTION right_angle_triangle(beta, gamma, delta)  \n    EXECUTE  \n        temp1 := (NOT (beta * beta > gamma * gamma + delta * delta)) AND (NOT (beta * beta < gamma * gamma + delta * delta))  \n        temp2 := (NOT (gamma * gamma > beta * beta + delta * delta)) AND (NOT (gamma * gamma < beta * beta + delta * delta))  \n        temp3 := (NOT (delta * delta > beta * beta + gamma * gamma)) AND (NOT (delta * delta < beta * beta + gamma * gamma))  \n        boolean resultFlag := temp1 OR temp2 OR temp3  \n    RETURN resultFlag  \nEND FUNCTION\n\nModified Pseudocode for Problem 6:\n```\nFUNCTION right_angle_triangle(a, b, c)\n    RETURN (a MULTIPLIED BY a EQUALS b MULTIPLIED BY b PLUS c MULTIPLIED BY c)\n        OR (b MULTIPLIED BY b EQUALS a MULTIPLIED BY a PLUS c MULTIPLIED BY c)\n        OR (c MULTIPLIED BY c EQUALS a MULTIPLIED BY a PLUS b MULTIPLIED BY b)\nEND FUNCTION\n```\n\nPseudocode for Problem 7:\nFUNCTION string_to_md5(inputString)   \n    IMPORT hashlib AS cryptModule   \n    DECLARE outputChecksum   \n    IF NOT (inputString == EMPTY) THEN   \n        DECLARE asciiEncoded = inputString[ASCII_ENCODING]   \n        DECLARE hashObject = cryptModule.md5(asciiEncoded)   \n        outputChecksum = hashObject[TO_HEX]()   \n    ELSE\n        outputChecksum = NONE   \n    ENDIF   \n    EXECUTE OUTPUT outputChecksum\nEND FUNCTION\n\nModified Pseudocode for Problem 7:\n```\nFUNCTION string_to_md5(text)\n    IMPORT hashlib MODULE\n    IF text IS NOT EMPTY\n        RETURN md5 HASH OF text ENCODED AS ASCII IN HEXADECIMAL STRING FORM\n    ELSE\n        RETURN None\nEND FUNCTION\n```\n\nPseudocode for Problem 8:\nFUNCTION find_max(words_collection)  \n\tINDEX_COUNTER \u2190 0  \n\tMAXIMIZED_WORD_CONTAINER \u2190 []  \n\tWHILE INDEX_COUNTER < LENGTH(words_collection) DO  \n\t\tCURRENT_ENTRY \u2190 words_collection[INDEX_COUNTER]  \n\t\tUNIQUE_CHARS_LIST \u2190 []  \n\t\tPOSITION_TRACKER \u2190 0  \n\t\tREPEAT  \n\t\t\tCHARACTER_TO_CHECK \u2190 CURRENT_ENTRY[POSITION_TRACKER]  \n\t\t\tIF NOT (CHARACTER_TO_CHECK IN UNIQUE_CHARS_LIST) THEN  \n\t\t\t\tAPPEND CHARACTER_TO_CHECK TO UNIQUE_CHARS_LIST  \n\t\t\tEND IF  \n\t\t\tPOSITION_TRACKER \u2190 POSITION_TRACKER + 1  \n\t\tUNTIL POSITION_TRACKER \u2265 LENGTH(CURRENT_ENTRY)  \n\t\tAPPEND (NEGATIVE LENGTH(UNIQUE_CHARS_LIST), CURRENT_ENTRY) TO MAXIMIZED_WORD_CONTAINER  \n\t\tINDEX_COUNTER \u2190 INDEX_COUNTER + 1  \n\tEND WHILE  \n  \n\tII \u2190 0  \n\tREPEAT  \n\nModified Pseudocode for Problem 8:\n```\nFUNCTION find_max(list_of_words)\n    SORT list_of_words BY\n        NEGATIVE LENGTH OF SET OF CHARACTERS IN each word,\n        THEN BY each word IN LEXICOGRAPHICAL ORDER\n    RETURN FIRST ELEMENT OF THE SORTED LIST\nEND FUNCTION\n```\nScore of -1*(BLEU Score) for ALL the problems: -0.07934956895998933",
  "iter": 15
}