{
  "prompt": "Given original pseudocode as input, produce a semantically equivalent pseudocode version that maximizes syntactic and stylistic divergence while strictly preserving all original function names, class names, and their exact hierarchical class/object structures. Achieve maximal difference by systematically applying all of the following transformations wherever applicable:\n\n- Replace control flow constructs with alternative, equivalent forms (e.g., convert FOR loops to WHILE loops or recursion, switch IF-ELSE branches to guard clauses or ternary-like expressions).\n- Invent new, meaningful variable names without reusing any original variable identifiers; rename loop indices, temporaries, accumulators, and parameters distinctly.\n- Reorder independent statements, reorder condition checks logically without affecting behavior, and reframe expressions using equivalent operators or algebraic identities.\n- Substitute control keywords with synonyms or spelling variants (e.g., USE rather than PERFORM, OBTAIN instead of GET, OTHERWISE for ELSE).\n- Transform expressions by expanding or condensing complex expressions, replacing syntactic sugar with explicit constructs, or rewriting conditions as equivalent compound predicates.\n- Adopt alternate formatting conventions: vary indentation style and levels, introduce or remove blank lines, switch between inline and multiline statements, change comment style or remove comments altogether.\n- Use different data structure access notation or explicit indexing where implicit was used, change ordering of parameters in built-in calls if order is immaterial.\n- Avoid any reuse of exact variable names or literal strings except for the mandated function and class identifiers.\n- Do not add any explanation or commentary; output solely the rewritten pseudocode text without delimiting markdown or quotes.\n\nUnder no circumstances modify logic, output behavior, or external interfaces. Follow these instructions rigorously to ensure maximal syntactic difference but perfect functional equivalence, maintaining structural fidelity of function and class naming and placement.",
  "response": "Given original pseudocode as input, produce a semantically equivalent pseudocode version that maximizes syntactic and stylistic divergence while strictly preserving all original function names, class names, and their exact hierarchical class/object structures. Achieve maximal difference by systematically applying all of the following transformations wherever applicable:\n\n- Replace control flow constructs with alternative, equivalent forms (e.g., convert FOR loops to WHILE loops or recursion, switch IF-ELSE branches to guard clauses or ternary-like expressions).\n- Invent new, meaningful variable names without reusing any original variable identifiers; rename loop indices, temporaries, accumulators, and parameters distinctly.\n- Reorder independent statements, reorder condition checks logically without affecting behavior, and reframe expressions using equivalent operators or algebraic identities.\n- Substitute control keywords with synonyms or spelling variants (e.g., USE rather than PERFORM, OBTAIN instead of GET, OTHERWISE for ELSE).\n- Transform expressions by expanding or condensing complex expressions, replacing syntactic sugar with explicit constructs, or rewriting conditions as equivalent compound predicates.\n- Adopt alternate formatting conventions: vary indentation style and levels, introduce or remove blank lines, switch between inline and multiline statements, change comment style or remove comments altogether.\n- Use different data structure access notation or explicit indexing where implicit was used, change ordering of parameters in built-in calls if order is immaterial.\n- Avoid any reuse of exact variable names or literal strings except for the mandated function and class identifiers.\n- Do not add any explanation or commentary; output solely the rewritten pseudocode text without delimiting markdown or quotes.\n\nUnder no circumstances modify logic, output behavior, or external interfaces. Follow these instructions rigorously to ensure maximal syntactic difference but perfect functional equivalence, maintaining structural fidelity of function and class naming and placement.",
  "score": -0.10729742581004628,
  "feedback": "The following are 20 lines of original pseudocode of a random subset of the problems along with their modified pseudocodes.\n\nPseudocode for Problem 1:\nFUNCTION generate_integers(param_x, param_y)\n  SET start_val TO MIN( MAX(2, MIN(param_x, param_y)), 8 )\n  SET end_val TO MAX( MIN(8, MAX(param_x, param_y)), 2 )\n  \n  SET result_collection TO EMPTY LIST\n  SET iterator_k TO start_val\n\n  WHILE iterator_k <= end_val DO\n    IF (iterator_k MOD 2) - 0 = 0 THEN\n      ADD iterator_k TO result_collection\n    OTHERWISE\n      # do nothing\n    ENDIF\n    SET iterator_k TO iterator_k + 1\n  ENDWHILE\n\nRETURN result_collection\nEND FUNCTION\n\nModified Pseudocode for Problem 1:\n```\nFUNCTION generate_integers(integer_a, integer_b)\n    SET lower_bound TO MAXIMUM OF 2 AND MINIMUM OF integer_a AND integer_b\n    SET upper_bound TO MINIMUM OF 8 AND MAXIMUM OF integer_a AND integer_b\n    RETURN LIST OF each integer_i FOR integer_i IN RANGE FROM lower_bound TO upper_bound INCLUSIVE WHERE integer_i MODULO 2 EQUALS 0\nEND FUNCTION\n```\n\nPseudocode for Problem 2:\nFUNCTION order_by_points(collection_of_values)\n  FUNCTION digits_sum(value)\n    SET polarity TO 1\n    WHILE value < 0 DO\n      SET value TO 0 - value\n      SET polarity TO 0 - polarity\n      BREAK\n    END WHILE\n    SET digits_array TO EMPTY LIST\n    SET temp_value TO value\n    WHILE temp_value > 0 USE\n      APPEND (temp_value MOD 10) TO digits_array\n      SET temp_value TO temp_value DIV 10\n    OTHERWISE\n      IF temp_value = 0 THEN\n        APPEND 0 TO digits_array\n      END IF\n    END WHILE\n    SET digits_array[ LENGTH(digits_array) - LENGTH(digits_array) ] TO digits_array[0] * polarity\n    SET total_sum TO 0\n\nModified Pseudocode for Problem 2:\n```\nFUNCTION order_by_points(list_of_numbers)\n    FUNCTION digits_sum(number)\n        SET sign_indicator TO 1\n        IF number IS LESS THAN 0\n            SET number TO NEGATIVE number\n            SET sign_indicator TO -1\n        END IF\n        SET digits_list TO CONVERT number TO LIST OF INTEGERS REPRESENTING EACH DIGIT\n        MULTIPLY digits_list FIRST ELEMENT BY sign_indicator\n        RETURN SUM OF digits_list\n    END FUNCTION\n    RETURN list_of_numbers SORTED BY KEY digits_sum\nEND FUNCTION\n```\n\nPseudocode for Problem 3:\nFUNCTION sorted_list_sum(sequence_of_texts)\n  DECLARE pivot INDEX = 0\n  DECLARE filtered_collection AS EMPTY LIST\n\n  WHILE pivot < LENGTH(sequence_of_texts) DO\n    OBTAIN current_entry FROM sequence_of_texts AT pivot\n\n    IF NOT ( (LENGTH(current_entry) MOD 2) != 0 ) THEN\n      USE filtered_collection ADD current_entry\n    OTHERWISE\n      NO-OP\n    ENDIF\n\n    SET pivot TO pivot + 1\n  ENDWHILE\n\n  USE sequence_of_texts SORT ALPHABETICALLY ASCENDING\n\n  RETURN filtered_collection SORTED BY LENGTH IN ASCENDING ORDER\nEND FUNCTION\n\nModified Pseudocode for Problem 3:\n```\nFUNCTION sorted_list_sum(list_of_strings)\n    CALL sort ON list_of_strings IN ASCENDING ALPHABETICAL ORDER\n    SET new_list TO EMPTY LIST\n    FOR each string_element IN list_of_strings\n        IF LENGTH OF string_element MODULO 2 EQUALS 0\n            APPEND string_element TO new_list\n    RETURN new_list SORTED BY LENGTH IN ASCENDING ORDER\nEND FUNCTION\n```\n\nPseudocode for Problem 4:\nFUNCTION sum_squares(array_of_numbers)\n  INITIALIZE temp_collection AS an empty list\n\n  SET cursor TO 0\n  WHILE cursor < LENGTH(array_of_numbers) \n    IF (cursor MOD 3) \u2260 0 THEN\n      IF (cursor MOD 4) = 0 THEN\n        USE temp_collection.ADD( (array_of_numbers[cursor]) * (array_of_numbers[cursor]) * (array_of_numbers[cursor]) )\n      OTHERWISE\n        USE temp_collection.ADD(array_of_numbers[cursor])\n    OTHERWISE\n      USE temp_collection.ADD((array_of_numbers[cursor]) ^ 2)\n    SET cursor TO cursor + 1\n\n  DECLARE accumulator AS 0\n  SET idx TO 0\n  WHILE idx < LENGTH(temp_collection)\n    accumulator \u2190 accumulator + temp_collection[idx]\n    idx \u2190 idx + 1\n\n\nModified Pseudocode for Problem 4:\n```\nFUNCTION sum_squares(list_of_integers)\n    SET result_list TO empty list\n    FOR index FROM 0 TO LENGTH OF list_of_integers MINUS 1\n        IF index MODULO 3 EQUALS 0\n            APPEND list_of_integers AT index RAISED TO THE POWER OF 2 TO result_list\n        ELSE IF index MODULO 4 EQUALS 0 AND index MODULO 3 NOT EQUAL TO 0\n            APPEND list_of_integers AT index RAISED TO THE POWER OF 3 TO result_list\n        ELSE\n            APPEND list_of_integers AT index TO result_list\n    RETURN SUM OF ELEMENTS IN result_list\nEND FUNCTION\n```\n\nPseudocode for Problem 5:\nFUNCTION compare_one(alpha, beta)\n    tempAlpha := alpha\n    tempBeta := beta\n\n    USE guard NOT (TYPEOF(tempAlpha) IS string) OTHERWISE\n        tempAlpha := REPLACE(tempAlpha, ',', '.')\n\n    USE guard NOT (TYPEOF(tempBeta) IS string) OTHERWISE\n        tempBeta := REPLACE(tempBeta, ',', '.')\n\n    VALUE alphaFloat := TO_FLOAT(tempAlpha)\n    VALUE betaFloat := TO_FLOAT(tempBeta)\n\n    IF alphaFloat = betaFloat THEN\n        RETURN None\n    END IF\n\n    USE guard NOT (alphaFloat > betaFloat) OTHERWISE\n        RETURN beta\n\n\nModified Pseudocode for Problem 5:\n```\nFUNCTION compare_one(a, b)\n    SET temp_a TO a\n    SET temp_b TO b\n    IF temp_a IS OF TYPE string\n        REPLACE ALL OCCURRENCES OF ',' WITH '.' IN temp_a\n    END IF\n    IF temp_b IS OF TYPE string\n        REPLACE ALL OCCURRENCES OF ',' WITH '.' IN temp_b\n    END IF\n    IF CONVERT temp_a TO float EQUALS CONVERT temp_b TO float\n        RETURN None\n    END IF\n    IF CONVERT temp_a TO float IS GREATER THAN CONVERT temp_b TO float\n        RETURN a\n    ELSE\n        RETURN b\n    END IF\nEND FUNCTION\n```\n\nPseudocode for Problem 6:\nFUNCTION can_arrange(collection)\n  BEGIN\n    marker \u2190 -1\n    cursor \u2190 1\n\n    LOOP\n      BREAK IF cursor \u2265 LENGTH OF collection\n\n      IF collection[cursor] < collection[cursor - 1] THEN\n        marker \u2190 cursor\n      END IF\n\n      cursor \u2190 cursor + 1\n    END LOOP\n\n    RETURN marker\n  END\nEND FUNCTION\n\nModified Pseudocode for Problem 6:\n```\nFUNCTION can_arrange(array)\n    SET index TO -1\n    SET iterator TO 1\n    WHILE iterator LESS THAN LENGTH OF array\n        IF element AT position iterator IN array LESS THAN element AT position (iterator MINUS 1) IN array\n            SET index TO iterator\n        INCREMENT iterator BY 1\n    RETURN index\nEND FUNCTION\n```\n\nPseudocode for Problem 7:\nFUNCTION eat(amount, requirement, leftovers)\n    IF requirement > leftovers THEN\n        RETURN [ amount + leftovers, 0 ]\n    OTHERWISE\n        RETURN [ requirement + amount, leftovers - requirement ]\n    END IF\nEND FUNCTION\n\nModified Pseudocode for Problem 7:\n```\nFUNCTION eat(number, need, remaining)\n    IF need IS LESS THAN OR EQUAL TO remaining\n        RETURN LIST OF [number PLUS need, remaining MINUS need]\n    ELSE\n        RETURN LIST OF [number PLUS remaining, 0]\nEND FUNCTION\n```\n\nPseudocode for Problem 8:\nFUNCTION solve(textual_data)\n  flag_marker \u2190 false\n  pointer \u2190 0\n  characters_array \u2190 []\n  \n  USE WHILE pointer < LENGTH(textual_data) DO\n    current_char \u2190 textual_data[pointer]\n    \n    OTHERWISE current_char IS NOT AN ALPHABETICAL LETTER:\n      characters_array.APPEND(current_char)\n      pointer \u2190 pointer + 1\n      CONTINUE\n      \n    characters_array.APPEND(\n      IF (current_char \u2265 'a' AND current_char \u2264 'z') THEN\n        CHARACTER_TO_UPPER(current_char)\n      OTHERWISE\n        CHARACTER_TO_LOWER(current_char)\n    )\n    \n\nModified Pseudocode for Problem 8:\n```\nFUNCTION solve(string_input)\n    SET flag TO 0\n    SET index TO 0\n    SET new_string_list TO LIST OF CHARACTERS IN string_input\n    FOR each character IN string_input\n        IF character IS ALPHABETICAL LETTER\n            SET new_string_list[index] TO character WITH CASE REVERSED\n            SET flag TO 1\n        END IF\n        INCREMENT index BY 1\n    END FOR\n    SET string_result TO EMPTY STRING\n    FOR each character IN new_string_list\n        CONCATENATE character TO string_result\n    END FOR\n    IF flag EQUALS 0\n        RETURN string_result REVERSED\n    END IF\n    RETURN string_result\nScore of -1*(BLEU Score) for ALL the problems: -0.10729742581004628",
  "iter": 3
}