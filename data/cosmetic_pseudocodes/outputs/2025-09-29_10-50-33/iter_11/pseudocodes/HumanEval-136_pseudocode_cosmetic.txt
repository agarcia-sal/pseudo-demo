FUNCTION largest_smallest_integers(numbers_collection)  
	counters_index ← 0  
	negatives_collection ← EMPTY LIST  
	positives_collection ← EMPTY LIST  
	WHILE counters_index < LENGTH(numbers_collection) DO  
		element_check ← numbers_collection[counters_index]  
		IF NOT (element_check >= 0) THEN  
			APPEND element_check TO negatives_collection  
		ELSE IF NOT (element_check <= 0) THEN  
			APPEND element_check TO positives_collection  
		END IF  
		counters_index ← counters_index + 1  
	END WHILE  
  
	FUNCTION find_maximum(sequence_list, current_pos, current_maximum)  
		IF current_pos = LENGTH(sequence_list) THEN  
			EXECUTE RETURN current_maximum  
		END IF  
		item_at_pos ← sequence_list[current_pos]  
		update_maximum ← (item_at_pos > current_maximum) ? item_at_pos : current_maximum  
		PERFORM find_maximum(sequence_list, current_pos + 1, update_maximum)  
	END FUNCTION  
  
	FUNCTION find_minimum(sequence_list, current_pos, current_minimum)  
		IF current_pos = LENGTH(sequence_list) THEN  
			EXECUTE RETURN current_minimum  
		END IF  
		item_at_pos ← sequence_list[current_pos]  
		update_minimum ← (item_at_pos < current_minimum) ? item_at_pos : current_minimum  
		PERFORM find_minimum(sequence_list, current_pos + 1, update_minimum)  
	END FUNCTION  
  
	IF LENGTH(negatives_collection) > 0 THEN  
		EXECUTE find_maximum(negatives_collection, 0, negatives_collection[0])  
	ELSE  
		EXECUTE RETURN (null, null)  
	END IF  
  
	largest_negative_value ← null  
	smallest_positive_value ← null  
  
	early_exit_label:  
	IF LENGTH(negatives_collection) = 0 THEN  
		largest_negative_value ← null  
	ELSE  
		largest_negative_value ← find_maximum(negatives_collection, 0, negatives_collection[0])  
	END IF  
  
	IF LENGTH(positives_collection) <> 0 THEN  
		smallest_positive_value ← find_minimum(positives_collection, 0, positives_collection[0])  
	ELSE  
		smallest_positive_value ← null  
	END IF  
  
	EXECUTE RETURN (largest_negative_value, smallest_positive_value)  
END FUNCTION