{
  "prompt": "```\nYou will be given one or more pseudocode snippets, each purporting to fully specify a complete solution for some computational problem.\n\nYour task is to determine, for each snippet independently, whether it is truly **REPRODUCIBLE**, meaning that if implemented exactly as written, without any external assumptions, guesswork, or modifications, it will **unfailingly** pass **all** relevant unit tests for the indicated problem.\n\nTo decide **REPRODUCIBILITY**, rigorously apply the following evaluation framework:\n\n1. **Explicit Completeness:**  \n   - All essential elements must be fully and explicitly declared and defined, including variables, data structures, initial values, loop and conditional constructs, return statements, and edge case handling.  \n   - No critical implementation detail can be missing, ambiguous, or implied implicitly.  \n   - You must NOT supply or infer any information beyond what is clearly presented.\n\n2. **Correctness of Logic:**  \n   - The pseudocode\u2019s algorithmic logic must correctly solve the stated problem for every valid input case, including all edge and corner cases, without error, infinite loops, or contradictions.  \n   - Confirm correctness by mentally simulating or logically analyzing how the snippet processes inputs and produces outputs.\n\n3. **Unambiguous Determinism:**  \n   - The instructions must be so precise and clear that only one interpretation exists that leads to correct and complete implementation behavior.  \n   - Vague specifications, undefined operations, or inconsistent constructs disqualify reproducibility.\n\n4. **Self-Containment and Independence:**  \n   - The snippet must be fully standalone: it cannot depend on any external code, context, environmental specifics, or definitions beyond what is explicitly included.  \n   - Absence of required auxiliary functions, initializations, or specified standard library use counts as not reproducible.\n\n5. **Structural and Semantic Validity:**  \n   - Control structures (loops, conditionals, recursion), data manipulation, and return values must be syntactically consistent within the pseudocode\u2019s style and semantically coherent.  \n   - The flow of execution must be complete and correctly terminate, with no logical dead ends or undefined variables.\n\n**Important:**  \n- Do NOT attempt to fix, complete, or improve ambiguous/incomplete pseudocode; mark such snippets as NOT reproducible (`0`).  \n- Mark as reproducible (`1`) only if every aspect above is unequivocally satisfied.\n\n---\n\n**Output instructions:**  \nFor each input pseudocode snippet, output a single digit \u2014 `1` if reproducible, otherwise `0`.  \nOutput these digits in the exact order the pseudocode snippets are presented, each on its own line, with no additional text, commentary, or formatting.\n\nBegin evaluation immediately upon receiving the pseudocode inputs.\n```\n",
  "response": "```\nYou will be given one or more pseudocode snippets, each purporting to fully specify a complete solution for some computational problem.\n\nYour task is to determine, for each snippet independently, whether it is truly **REPRODUCIBLE**, meaning that if implemented exactly as written, without any external assumptions, guesswork, or modifications, it will **unfailingly** pass **all** relevant unit tests for the indicated problem.\n\nTo decide **REPRODUCIBILITY**, rigorously apply the following evaluation framework:\n\n1. **Explicit Completeness:**  \n   - All essential elements must be fully and explicitly declared and defined, including variables, data structures, initial values, loop and conditional constructs, return statements, and edge case handling.  \n   - No critical implementation detail can be missing, ambiguous, or implied implicitly.  \n   - You must NOT supply or infer any information beyond what is clearly presented.\n\n2. **Correctness of Logic:**  \n   - The pseudocode\u2019s algorithmic logic must correctly solve the stated problem for every valid input case, including all edge and corner cases, without error, infinite loops, or contradictions.  \n   - Confirm correctness by mentally simulating or logically analyzing how the snippet processes inputs and produces outputs.\n\n3. **Unambiguous Determinism:**  \n   - The instructions must be so precise and clear that only one interpretation exists that leads to correct and complete implementation behavior.  \n   - Vague specifications, undefined operations, or inconsistent constructs disqualify reproducibility.\n\n4. **Self-Containment and Independence:**  \n   - The snippet must be fully standalone: it cannot depend on any external code, context, environmental specifics, or definitions beyond what is explicitly included.  \n   - Absence of required auxiliary functions, initializations, or specified standard library use counts as not reproducible.\n\n5. **Structural and Semantic Validity:**  \n   - Control structures (loops, conditionals, recursion), data manipulation, and return values must be syntactically consistent within the pseudocode\u2019s style and semantically coherent.  \n   - The flow of execution must be complete and correctly terminate, with no logical dead ends or undefined variables.\n\n**Important:**  \n- Do NOT attempt to fix, complete, or improve ambiguous/incomplete pseudocode; mark such snippets as NOT reproducible (`0`).  \n- Mark as reproducible (`1`) only if every aspect above is unequivocally satisfied.\n\n---\n\n**Output instructions:**  \nFor each input pseudocode snippet, output a single digit \u2014 `1` if reproducible, otherwise `0`.  \nOutput these digits in the exact order the pseudocode snippets are presented, each on its own line, with no additional text, commentary, or formatting.\n\nBegin evaluation immediately upon receiving the pseudocode inputs.\n```\n",
  "score": 0.6133333333333333,
  "feedback": "We have a 4 way split for the pseudocodes: true positives, which are pseudocodes that correspond to code that passes all test cases.\nWe also have true negatives, which are pseudocodes that correspond to code that do not pass all test cases.\nWe have cosmetic, which are pseudocodes that are variations of the positive pseudocodes and also pass all test cases.\nWe have near-misses, which are pseudocodes that correspond to code that almost passes all test cases but do not. They pass at least 80% of test cases\nHere is the score for this prompt on positive-labeled pseudocodes: 0.6666666666666666\nHere is the score for this prompt on negative-labeled pseudocodes: 0.5933333333333334\nHere is the score for this prompt on cosmetic-labeled pseudocodes: 0.76\nHere is the score for this prompt on near_miss-labeled pseudocodes: 0.43333333333333335\n\nThe following are pseudocodes that are reproducible but were labeled as not:\nCLASS Solution  \n    FUNCTION multiply(num1 string num2 string) RETURNS string  \n        IF num1 EQUALS string zero OR num2 EQUALS string zero  \n            RETURN string zero  \n        END IF  \n\n        SET result TO a list of zeros with the LENGTH OF num1 PLUS the LENGTH OF num2  \n\n        SET num1 TO the reversal of num1  \n        SET num2 TO the reversal of num2  \n\n        FOR i FROM zero TO the LENGTH OF num1 MINUS one  \n            FOR j FROM zero TO the LENGTH OF num2 MINUS one  \n                SET mul TO the character code of the element at position i of num1 MINUS the character code of string zero MULTIPLIED BY the character code of the element at position j of num2 MINUS the character code of string zero  \n                SET p1 TO i PLUS j  \n                SET p2 TO i PLUS j PLUS one  \n                SET sum TO mul PLUS the element at position p1 of result  \n\n                SET the element at position p1 of result TO sum MODULO ten  \n                INCREMENT the element at position p2 of result BY the integer division of sum BY ten  \n            END FOR  \n        END FOR  \n\n        SET result_str TO the concatenation of the string representations of the elements of result in reverse order  \n        RETURN result_str with all leading string zeros removed  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION uniquePaths(m n)  \n        SET dp TO a two dimensional list with m rows and n columns where each element is set to one  \n        FOR i FROM two TO m  \n            FOR j FROM two TO n  \n                SET element at position i of dp TO the list at position i of dp  \n                SET element at position j of element at position i of dp TO the sum of the element at position i MINUS one of dp at position j AND the element at position i of dp at position j MINUS one  \n            END FOR  \n        END FOR  \n        RETURN the element at position m MINUS one of dp at position n MINUS one  \n    END FUNCTION  \nEND CLASS\n\nThe following are cosmetic or modified pseudocodes of other reproducible versions of pseudocode that are reproducible but were labeled as not:\noriginal version of the pseudocode for this problem that is reproducible:\nCLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET INT_MAX TO two RAISED TO THE POWER OF thirty ONE MINUS one  \n        SET INT_MIN TO the NEGATIVE of two RAISED TO THE POWER OF thirty ONE  \n        SET result TO zero  \n        SET index TO zero  \n        SET n TO the LENGTH OF s  \n        SET sign TO one  \n        WHILE index LESS THAN n AND element at position index of s EQUALS the space character  \n            INCREMENT index BY one  \n        END WHILE  \n        IF index LESS THAN n AND (element at position index of s EQUALS the plus character OR element at position index of s EQUALS the minus character)  \n            IF element at position index of s EQUALS the minus character  \n                SET sign TO the NEGATIVE of one  \n            ELSE  \n                SET sign TO one  \n            END IF  \n            INCREMENT index BY one  \n        END IF  \n        WHILE index LESS THAN n AND element at position index of s IS A DIGIT  \n            SET digit TO the INTEGER VALUE OF element at position index of s  \n            IF result GREATER THAN INT_MAX MINUS digit DIVIDED BY ten  \n                IF sign EQUALS one  \n                    RETURN INT_MAX  \n                ELSE  \n                    RETURN INT_MIN  \n                END IF  \n            END IF  \n            SET result TO result MULTIPLIED BY ten PLUS digit  \n            INCREMENT index BY one  \n        END WHILE  \n        RETURN sign MULTIPLIED BY result  \n    END FUNCTION  \nEND CLASS\nmodified version of the pseudocode for this problem that is also reproducible:\nCLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET maxIntValue AS (2 ^ 31) - 1  \n        SET minIntValue AS 0 - (2 ^ 31)  \n        SET accumulatedNumber TO 0  \n        SET position TO 0  \n        SET lengthOfString TO LENGTH OF s  \n        SET polarity TO 1  \n\n        WHILE position < lengthOfString AND s[position] = ' '  \n            position \u2190 position + 1  \n        END WHILE  \n\n        IF position < lengthOfString THEN  \n            SWITCH s[position]  \n                CASE '-'  \n                    polarity \u2190 0 - 1  \n                    position \u2190 position + 1  \n                    BREAK  \n                CASE '+'  \n                    polarity \u2190 1  \n                    position \u2190 position + 1  \n                    BREAK  \n            END SWITCH  \n        END IF  \n\n        REPEAT UNTIL NOT (position < lengthOfString AND s[position] >= '0' AND s[position] <= '9')  \n            SET currentChar TO s[position]  \n            SET numericValue TO INTEGER VALUE OF currentChar  \n            SET boundaryCheck TO maxIntValue - (numericValue DIV 10)  \n\n            IF accumulatedNumber > boundaryCheck THEN  \n                IF polarity = 1 THEN  \n                    RETURN maxIntValue  \n                ELSE  \n                    RETURN minIntValue  \n                END IF  \n            END IF  \n\n            accumulatedNumber \u2190 (accumulatedNumber * 10) + numericValue  \n            position \u2190 position + 1  \n        END REPEAT  \n\n        RETURN polarity * accumulatedNumber  \n    END FUNCTION  \nEND CLASS\noriginal version of the pseudocode for this problem that is reproducible:\nCLASS Solution  \n    FUNCTION isMatch(s, p)  \n        SET dp TO a two dimensional list of False with the number of rows equal to the length of s PLUS one and the number of columns equal to the length of p PLUS one  \n        SET element at position zero zero of dp TO True  \n        FOR j FROM one TO the length of p  \n            IF element at position j MINUS one of p EQUALS the character representing asterisk  \n                SET element at position zero j of dp TO the value of element at position zero j MINUS one of dp  \n            END IF  \n        END FOR  \n        FOR i FROM one TO the length of s  \n            FOR j FROM one TO the length of p  \n                IF element at position j MINUS one of p EQUALS the character representing asterisk  \n                    SET element at position i j of dp TO the value of element at position i MINUS one j of dp OR the value of element at position i j MINUS one of dp  \n                ELSE IF element at position j MINUS one of p EQUALS the character representing question mark OR element at position i MINUS one of s EQUALS element at position j MINUS one of p  \n                    SET element at position i j of dp TO the value of element at position i MINUS one j MINUS one of dp  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position the length of s the length of p of dp  \n    END FUNCTION  \nEND CLASS\nmodified version of the pseudocode for this problem that is also reproducible:\nCLASS Solution  \n    FUNCTION isMatch(s, p)  \n        DECLARE table AS two-dimensional array FILLED WITH False, SIZE (length(s) + 1) BY (length(p) + 1)  \n        ASSIGN table[0][0] \u2190 True  \n\n        SET indexP TO 1  \n        WHILE indexP \u2264 length(p)  \n            IF p[indexP - 1] = '*' THEN  \n                ASSIGN table[0][indexP] \u2190 table[0][indexP - 1]  \n            END IF  \n            INCREMENT indexP BY 1  \n        END WHILE  \n\n        SET indexS TO 1  \n        WHILE indexS \u2264 length(s)  \n            SET indexPTmp TO 1  \n            WHILE indexPTmp \u2264 length(p)  \n                IF p[indexPTmp - 1] = '*' THEN  \n                    ASSIGN table[indexS][indexPTmp] \u2190 (table[indexS - 1][indexPTmp] OR table[indexS][indexPTmp - 1])  \n                ELSE  \n                    IF (p[indexPTmp - 1] = '?' OR s[indexS - 1] = p[indexPTmp - 1]) THEN  \n                        ASSIGN table[indexS][indexPTmp] \u2190 table[indexS - 1][indexPTmp - 1]  \n                    END IF  \n                END IF  \n                SET indexPTmp \u2190 indexPTmp + 1  \n            END WHILE  \n            SET indexS \u2190 indexS + 1  \n        END WHILE  \n\n        RETURN table[length(s)][length(p)]  \n    END FUNCTION  \nEND CLASS\n\nThe following are pseudocodes that are not reproducible but were labeled as reproducible:\n```\nif num1==\"0\" or num2==\"0\": return \"0\"\nres = [0]*(len(num1)+len(num2))\nn1, n2 = num1[::-1], num2[::-1]\nfor i in range(len(n1)):\n  for j in range(len(n2)):\n    mul = (ord(n1[i])-48)*(ord(n2[j])-48)\n    sum_ = mul + res[i+j]\n    res[i+j], res[i+j+1] = sum_%10, res[i+j+1]+sum_//10\nreturn ''.join(map(str,res[::-1])).lstrip('0')\n```\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION multiply(num1 string num2 string) RETURNS string  \n        IF num1 EQUALS string zero OR num2 EQUALS string zero  \n            RETURN string zero  \n        END IF  \n\n        SET result TO a list of zeros with the LENGTH OF num1 PLUS the LENGTH OF num2  \n\n        SET num1 TO the reversal of num1  \n        SET num2 TO the reversal of num2  \n\n        FOR i FROM zero TO the LENGTH OF num1 MINUS one  \n            FOR j FROM zero TO the LENGTH OF num2 MINUS one  \n                SET mul TO the character code of the element at position i of num1 MINUS the character code of string zero MULTIPLIED BY the character code of the element at position j of num2 MINUS the character code of string zero  \n                SET p1 TO i PLUS j  \n                SET p2 TO i PLUS j PLUS one  \n                SET sum TO mul PLUS the element at position p1 of result  \n\n                SET the element at position p1 of result TO sum MODULO ten  \n                INCREMENT the element at position p2 of result BY the integer division of sum BY ten  \n            END FOR  \n        END FOR  \n\n        SET result_str TO the concatenation of the string representations of the elements of result in reverse order  \n        RETURN result_str with all leading string zeros removed  \n    END FUNCTION  \nEND CLASS\nCLASS Solution\n    FUNCTION isMatch(string_s, string_p)\n        SET dp TO a two dimensional list of BOOLEAN false VALUES with the number of rows EQUAL TO the LENGTH OF string_s PLUS one AND the number of columns EQUAL TO the LENGTH OF string_p PLUS one\n\n        SET the element at row zero AND column zero OF dp TO true\n\n        FOR index_j FROM one TO the LENGTH OF string_p INCLUSIVE\n            IF the element at position index_j MINUS one OF string_p EQUALS character star\n                SET the element at row zero AND column index_j OF dp TO the element at row zero AND column index_j MINUS one OF dp\n            END IF\n        END FOR\n        \n        FOR index_i FROM one TO the LENGTH OF string_s INCLUSIVE\n            FOR index_j FROM one TO the LENGTH OF string_p INCLUSIVE\n                IF the element at position index_j MINUS one OF string_p EQUALS character star\n                    SET the element at row index_i AND column index_j OF dp TO the element at row index_i MINUS one AND column index_j OF dp OR the element at row index_i AND column index_j MINUS one OF dp\n                ELSE IF the element at position index_j MINUS one OF string_p EQUALS character question MARK OR the element at position index_i MINUS one OF string_s EQUALS the element at position index_j MINUS one OF string_p\n                    SET the element at row index_i AND column index_j OF dp TO the element at row index_i MINUS one AND column index_j MINUS one OF dp\n                END IF\n            END FOR\n        END FOR\n\n        RETURN the element at row the LENGTH OF string_s AND column the LENGTH OF string_p OF dp\n    END FUNCTION\nEND CLASS\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION isMatch(s, p)  \n        SET dp TO a two dimensional list of False with the number of rows equal to the length of s PLUS one and the number of columns equal to the length of p PLUS one  \n        SET element at position zero zero of dp TO True  \n        FOR j FROM one TO the length of p  \n            IF element at position j MINUS one of p EQUALS the character representing asterisk  \n                SET element at position zero j of dp TO the value of element at position zero j MINUS one of dp  \n            END IF  \n        END FOR  \n        FOR i FROM one TO the length of s  \n            FOR j FROM one TO the length of p  \n                IF element at position j MINUS one of p EQUALS the character representing asterisk  \n                    SET element at position i j of dp TO the value of element at position i MINUS one j of dp OR the value of element at position i j MINUS one of dp  \n                ELSE IF element at position j MINUS one of p EQUALS the character representing question mark OR element at position i MINUS one of s EQUALS element at position j MINUS one of p  \n                    SET element at position i j of dp TO the value of element at position i MINUS one j MINUS one of dp  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position the length of s the length of p of dp  \n    END FUNCTION  \nEND CLASS\n\nThe following are near-miss pseudocodes - they are almost reproducible but were labeled as reproducible:\nCLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET INT_MAX TO two POWERED BY thirty ONE MINUS one  \n        SET INT_MIN TO negative two POWERED BY thirty ONE  \n        SET result TO zero  \n        SET index TO zero  \n        SET n TO the LENGTH OF s  \n        SET sign TO one  \n        WHILE index LESS THAN n AND character at position index OF s EQUALS a single whitespace character  \n            INCREMENT index BY one  \n        END WHILE  \n        IF index LESS THAN n AND (character at position index OF s EQUALS the plus sign OR character at position index OF s EQUALS the minus sign)  \n            IF character at position index OF s EQUALS the minus sign  \n                SET sign TO negative one  \n            ELSE  \n                SET sign TO one  \n            END IF  \n            INCREMENT index BY one  \n        END IF  \n        WHILE index LESS THAN n AND character at position index OF s IS A DIGIT  \n            SET digit TO the INTEGER VALUE OF character at position index OF s  \n            IF result GREATER THAN (INT_MAX MINUS digit) DIVIDED BY ten  \n                IF sign EQUALS one  \n                    RETURN INT_MAX  \n                ELSE  \n                    RETURN INT_MIN  \n                END IF  \n            END IF  \n            SET result TO result MULTIPLIED BY ten PLUS digit  \n            INCREMENT index BY one  \n        END WHILE  \n        RETURN sign MULTIPLIED BY result  \n    END FUNCTION  \nEND CLASS\nPassing rate for this pseudocode: 0.96875, but was given a label of 1\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET INT_MAX TO two RAISED TO THE POWER OF thirty ONE MINUS one  \n        SET INT_MIN TO the NEGATIVE of two RAISED TO THE POWER OF thirty ONE  \n        SET result TO zero  \n        SET index TO zero  \n        SET n TO the LENGTH OF s  \n        SET sign TO one  \n        WHILE index LESS THAN n AND element at position index of s EQUALS the space character  \n            INCREMENT index BY one  \n        END WHILE  \n        IF index LESS THAN n AND (element at position index of s EQUALS the plus character OR element at position index of s EQUALS the minus character)  \n            IF element at position index of s EQUALS the minus character  \n                SET sign TO the NEGATIVE of one  \n            ELSE  \n                SET sign TO one  \n            END IF  \n            INCREMENT index BY one  \n        END IF  \n        WHILE index LESS THAN n AND element at position index of s IS A DIGIT  \n            SET digit TO the INTEGER VALUE OF element at position index of s  \n            IF result GREATER THAN INT_MAX MINUS digit DIVIDED BY ten  \n                IF sign EQUALS one  \n                    RETURN INT_MAX  \n                ELSE  \n                    RETURN INT_MIN  \n                END IF  \n            END IF  \n            SET result TO result MULTIPLIED BY ten PLUS digit  \n            INCREMENT index BY one  \n        END WHILE  \n        RETURN sign MULTIPLIED BY result  \n    END FUNCTION  \nEND CLASS\nCLASS Solution\n    FUNCTION multiply(num1 string, num2 string) RETURNS string\n        IF num1 IS \"0\" OR num2 IS \"0\"\n            RETURN \"0\"\n        END IF\n\n        DECLARE digits AS MAP from INT to INT\n        DECLARE lengthSum AS INT = LENGTH(num1) + LENGTH(num2)\n        FOR index IN RANGE(lengthSum)\n            digits[index] = 0\n        END FOR\n\n        DECLARE reversed1 AS string = \"\"\n        DECLARE reversed2 AS string = \"\"\n        FOR p FROM LENGTH(num1) - 1 DOWNTO 0\n            reversed1 = reversed1 + num1[p]\n        END FOR\n        FOR q FROM LENGTH(num2) - 1 DOWNTO 0\n            reversed2 = reversed2 + num2[q]\n        END FOR\n\n        DECLARE function recursiveMul(i INT, j INT) RETURNS VOID\n            IF i = LENGTH(reversed1)\n                RETURN\n            END IF\n            IF j = LENGTH(reversed2)\n                recursiveMul(i + 1, 0)\n                RETURN\n            END IF\n\n            DECLARE valA AS INT = ASCII_CODE(reversed1[i]) - ASCII_CODE(\"0\")\n            DECLARE valB AS INT = ASCII_CODE(reversed2[j]) - ASCII_CODE(\"0\")\n            DECLARE product AS INT = valA * valB\n            DECLARE baseIndex AS INT = i + j\n            DECLARE nextIndex AS INT = baseIndex + 1\n            DECLARE totalSum AS INT = product + digits[baseIndex]\n\n            digits[baseIndex] = totalSum MOD 10\n            digits[nextIndex] = digits[nextIndex] + (totalSum DIV 10)\n\n            recursiveMul(i, j + 1)\n        END FUNCTION\n\n        CALL recursiveMul(0, 0)\n\n        DECLARE output AS string = \"\"\n        FOR key FROM lengthSum - 1 DOWNTO 0\n            output = output + TO_STRING(digits[key])\n        END FOR\n\n        WHILE LENGTH(output) > 1 AND output[0] = \"0\"\n            output = SUBSTRING(output, 1)\n        END WHILE\n\n        RETURN output\n    END FUNCTION\nEND CLASS\nPassing rate for this pseudocode: 0.9666666666666667, but was given a label of 1\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION multiply(num1 string num2 string) RETURNS string  \n        IF num1 EQUALS string zero OR num2 EQUALS string zero  \n            RETURN string zero  \n        END IF  \n\n        SET result TO a list of zeros with the LENGTH OF num1 PLUS the LENGTH OF num2  \n\n        SET num1 TO the reversal of num1  \n        SET num2 TO the reversal of num2  \n\n        FOR i FROM zero TO the LENGTH OF num1 MINUS one  \n            FOR j FROM zero TO the LENGTH OF num2 MINUS one  \n                SET mul TO the character code of the element at position i of num1 MINUS the character code of string zero MULTIPLIED BY the character code of the element at position j of num2 MINUS the character code of string zero  \n                SET p1 TO i PLUS j  \n                SET p2 TO i PLUS j PLUS one  \n                SET sum TO mul PLUS the element at position p1 of result  \n\n                SET the element at position p1 of result TO sum MODULO ten  \n                INCREMENT the element at position p2 of result BY the integer division of sum BY ten  \n            END FOR  \n        END FOR  \n\n        SET result_str TO the concatenation of the string representations of the elements of result in reverse order  \n        RETURN result_str with all leading string zeros removed  \n    END FUNCTION  \nEND CLASS\nCLASS Solution\n    FUNCTION combine WITH PARAMETERS n k\n        SET outcome TO []\n        FUNCTION backtrack WITH PARAMETERS pos seq\n            WHILE pos NOT EQUAL TO n + 1\n                APPEND pos TO seq\n                IF LENGTH seq EQUALS k THEN\n                    APPEND COPY OF seq TO outcome\n                ELSE\n                    CALL backtrack WITH ARGUMENTS pos + 1 seq\n                END IF\n                REMOVE LAST ITEM FROM seq\n                SET pos TO pos + 1\n            END WHILE\n        END FUNCTION\n        CALL backtrack WITH ARGUMENTS 1 []\n        RETURN outcome\n    END FUNCTION\nEND CLASS\nPassing rate for this pseudocode: 0.8823529411764706, but was given a label of 1\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION combine WITH PARAMETERS n k  \n        FUNCTION backtrack WITH PARAMETERS start path  \n            IF the LENGTH OF path EQUALS k  \n                APPEND a COPY OF path TO result  \n                RETURN  \n            END IF  \n            FOR i FROM start TO n PLUS one  \n                APPEND i TO path  \n                CALL backtrack WITH ARGUMENTS i PLUS one path  \n                REMOVE the LAST ELEMENT FROM path  \n            END FOR  \n        END FUNCTION  \n        SET result TO an EMPTY LIST  \n        CALL backtrack WITH ARGUMENTS one AN EMPTY LIST  \n        RETURN result  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION grayCode(n)  \n        IF n IS 0 THEN  \n            RETURN [0]  \n        END IF  \n        \n        ASSIGN resultList TO grayCode(n - 1)  \n        LET bitFlag BE 2 ^ (n - 1) * 1  \n        \n        DEFINE FUNCTION reverseList(inputList)  \n            IF inputList IS EMPTY THEN  \n                RETURN []  \n            ELSE  \n                RETURN reverseList(inputList[1:]) + [inputList[0]]  \n            END IF  \n        END FUNCTION  \n        \n        LET reversedResult BE reverseList(resultList)  \n        LET extendedList BE []  \n        \n        FOR each element IN reversedResult DO  \n            extendedList = extendedList + [(element BITWISE_OR bitFlag)]  \n        END FOR  \n        \n        RETURN resultList + extendedList  \n    END FUNCTION  \nEND CLASS\nPassing rate for this pseudocode: 0.8333333333333334, but was given a label of 1\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION grayCode(n)  \n        IF n EQUALS zero  \n            RETURN a list containing zero  \n        END IF  \n        SET prev_gray TO the result of calling grayCode with the value of n MINUS one  \n        SET mask TO one MULTIPLIED BY two RAISED TO the power of n MINUS one  \n        SET current_gray TO concatenation of prev_gray WITH a list constructed by taking each number IN the reversed prev_gray AND applying bitwise OR with mask  \n        RETURN current_gray  \n    END FUNCTION  \nEND CLASS\n\nAvg Score for all pseudocodes: 0.6133333333333333"
}