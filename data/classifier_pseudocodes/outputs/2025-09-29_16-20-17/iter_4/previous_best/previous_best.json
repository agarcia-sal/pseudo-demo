{
  "prompt": "Given an arbitrary pseudocode input, evaluate whether it defines a fully explicit, logically correct, and complete algorithm that can be directly implemented to pass **all** relevant unit tests for the described functionality\u2014regardless of domain or context. To decide this, verify that the pseudocode includes all necessary components such as correct input handling, clear control flow (loops, conditionals, recursion if any), proper data manipulation, edge case coverage, and unambiguous step-by-step procedures without logical errors, omissions, or indexing flaws.\n\nOutput **1** if the pseudocode is reproducible\u2014that is, if a competent programmer could write fully correct, test-passing code based solely on the given instructions. Output **0** if the pseudocode is incomplete, ambiguous, logically flawed, or missing critical details that would prevent it from passing all unit tests.\n\n**Do not output anything other than this single digit (1 or 0).**",
  "response": "Given an arbitrary pseudocode input, evaluate whether it defines a fully explicit, logically correct, and complete algorithm that can be directly implemented to pass **all** relevant unit tests for the described functionality\u2014regardless of domain or context. To decide this, verify that the pseudocode includes all necessary components such as correct input handling, clear control flow (loops, conditionals, recursion if any), proper data manipulation, edge case coverage, and unambiguous step-by-step procedures without logical errors, omissions, or indexing flaws.\n\nOutput **1** if the pseudocode is reproducible\u2014that is, if a competent programmer could write fully correct, test-passing code based solely on the given instructions. Output **0** if the pseudocode is incomplete, ambiguous, logically flawed, or missing critical details that would prevent it from passing all unit tests.\n\n**Do not output anything other than this single digit (1 or 0).**",
  "score": 0.4782608695652174,
  "feedback": "We have a 2 way split for the pseudocodes: true positives, which are pseudocodes that correspond to code that passes all test cases.\nWe also have true negatives, which are pseudocodes that correspond to code that do not pass all test cases.\nThe following are pseudocodes that are reproducible but were labeled as not:\n```\nFUNCTION parse_nested_parens(parentheses_string)\n    FUNCTION parse_paren_group(group_string)\n        SET depth_counter TO 0\n        SET max_depth_reached TO 0\n        FOR character IN group_string DO\n            IF character EQUALS '(' THEN\n                depth_counter = depth_counter + 1\n                IF depth_counter > max_depth_reached THEN\n                    max_depth_reached = depth_counter\n                END IF\n            ELSE\n                depth_counter = depth_counter - 1\n            END IF\n        END FOR\n        RETURN max_depth_reached\n    END FUNCTION\n\n    SET group_list TO FILTER(SPLIT parentheses_string BY ' '), WHERE item IS NOT EMPTY\n    RETURN MAP(parse_paren_group, group_list)\nEND FUNCTION\n```\n```\nFUNCTION smallest_change(array_of_integers)\n    INITIALIZE answer AS 0\n    SET midpoint TO (LENGTH(array_of_integers) / 2) - 1\n    FOR index IN RANGE FROM 0 TO midpoint\n        IF array_of_integers[index] != array_of_integers[(LENGTH(array_of_integers) - 1) - index]\n            answer = answer + 1\n    END FOR\n    RETURN answer\nEND FUNCTION\n```\n```\nFUNCTION is_multiply_prime(a)\n    FUNCTION is_prime(n)\n        FOR divisor IN RANGE 2 TO n - 1 DO\n            IF n MOD divisor == 0 THEN\n                RETURN False\n        END FOR\n        RETURN True\n    END FUNCTION\n\n    FOR x FROM 2 TO 100 DO\n        IF is_prime(x) == False THEN\n            NEXT x\n        FOR y FROM 2 TO 100 DO\n            IF is_prime(y) == False THEN\n                NEXT y\n            FOR z FROM 2 TO 100 DO\n                IF is_prime(z) == False THEN\n                    NEXT z\n                IF x * y * z == a THEN\n                    RETURN True\n            END FOR\n        END FOR\n    END FOR\n    RETURN False\nEND FUNCTION\n```\n```\nFUNCTION decimal_to_binary(decimal_number)\n    LET binary_str BE BINARY_FORMAT OF decimal_number\n    LET trimmed_binary BE SLICE binary_str FROM 2 TO LENGTH OF binary_str\n    RETURN \"db\" + trimmed_binary + \"db\"\nEND FUNCTION\n```\n\nThe following are pseudocodes that are not reproducible but were labeled as reproducible:\n```\nFUNCTION separate_paren_groups(string_of_parentheses)\n\tDEFINE FUNCTION recurse_grouped_chars(posIndex, nestingDepth, acc_chars, acc_groups)\n\t\tIF posIndex >= LENGTH(string_of_parentheses) THEN\n\t\t\tRETURN acc_groups\n\t\tEND IF\n\t\tLET currentChar = GET_CHAR_AT(string_of_parentheses, posIndex)\n\t\tLET updatedDepth = nestingDepth\n\t\tLET updated_acc_chars = acc_chars\n\t\tLET updated_acc_groups = acc_groups\n\t\tupdated_acc_chars = APPEND_TO_LIST(updated_acc_chars, currentChar)\n\t\tupdatedDepth = IF (currentChar = '(') THEN nestingDepth + 1 ELSE IF (currentChar = ')') THEN nestingDepth - 1 ELSE nestingDepth\n\t\tEND IF\n\t\tIF updatedDepth = 0 THEN\n\t\t\tLET groupString = JOIN_STRINGS(updated_acc_chars)\n\t\t\tupdated_acc_groups = APPEND_TO_LIST(acc_groups, groupString)\n\t\t\tupdated_acc_chars = EMPTY_LIST()\n\t\tEND IF\n\t\tRETURN recurse_grouped_chars(posIndex + 1, updatedDepth, updated_acc_chars, updated_acc_groups)\n\tEND FUNCTION\n\tRETURN recurse_grouped_chars(0, 0, [], [])\nEND FUNCTION\n```\nHere are the errors for this pseudocode:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpw05mj2a5/solution_0.py\", line 34, in <module>\\n    check(separate_paren_groups)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpw05mj2a5/solution_0.py\", line 31, in check\\n    assert candidate(\\'(()()) ((())) () ((())()())\\') == [\\nAssertionError\\n', 'Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpw05mj2a5/solution_1.py\", line 34, in <module>\\n    check(separate_paren_groups)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpw05mj2a5/solution_1.py\", line 31, in check\\n    assert candidate(\\'() (()) ((())) (((())))\\') == [\\nAssertionError\\n']\nHere is a version of the pseudocode that IS reproducible:\n```\nFUNCTION separate_paren_groups(string_of_parentheses)\n    INITIALIZE list_of_results AS an empty list\n    INITIALIZE list_current_string AS an empty list\n    INITIALIZE integer_current_depth AS 0\n\n    FOR EACH char IN string_of_parentheses DO\n        IF char == '(' THEN\n            integer_current_depth = integer_current_depth + 1\n            ADD char TO list_current_string\n        ELSE IF char == ')' THEN\n            integer_current_depth = integer_current_depth - 1\n            ADD char TO list_current_string\n\n            IF integer_current_depth == 0 THEN\n                APPEND JOINED list_current_string TO list_of_results\n                RESET list_current_string TO an empty list\n            END IF\n        END IF\n    END FOR\n\n    RETURN list_of_results\nEND FUNCTION\n```\n```\nFUNCTION below_zero(list_of_operations)\n\tVAR acc__X1 := 0\n\tVAR idx$qY := 0\n\tVAR doneFLAG := length(list_of_operations) <= 0\n\tLOOP \n\t\tIF doneFLAG THEN BREAK\n\t\tacc__X1 := acc__X1 + list_of_operations[idx$qY]\n\t\tIF NOT (acc__X1 >= 0) THEN\n\t\t\tRETURN TRUE\n\t\tEND IF\n\t\tidx$qY := idx$qY + 1\n\t\tdoneFLAG := idx$qY >= length(list_of_operations)\n\tEND LOOP\n\tRETURN FALSE\nEND FUNCTION\n```\nHere are the errors for this pseudocode:\n['  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpnsv95ev8/solution_0.py\", line 6\\n    idx$qY: int = 0\\n       ^\\nSyntaxError: invalid syntax\\n', '  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmpnsv95ev8/solution_1.py\", line 6\\n    idx$qY: int = 0\\n       ^\\nSyntaxError: invalid syntax\\n']\nHere is a version of the pseudocode that IS reproducible:\n```\nFUNCTION below_zero(list_of_operations)\n    INITIALIZE balance AS 0\n    FOR operation IN list_of_operations DO\n        balance = balance + operation\n        IF balance < 0 THEN\n            RETURN True\n        END IF\n    END FOR\n    RETURN False\nEND FUNCTION\n```\n```\nFUNCTION intersperse(list_of_numbers, delimiter)\n  DEFINE helper(idx, res)\n    IF idx > LENGTH(list_of_numbers) THEN\n      RETURN res\n    ELSE IF idx = LENGTH(list_of_numbers) THEN\n      RETURN res + [list_of_numbers[idx]]\n    ELSE\n      RETURN helper(idx + 1, res + [list_of_numbers[idx]] + [delimiter])\n    END IF\n  END DEFINE\n\n  IF LENGTH(list_of_numbers) = 0 THEN\n    RETURN []\n  ELSE\n    RETURN helper(1, [])\n  END IF\nEND FUNCTION\n```\nHere are the errors for this pseudocode:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp7gzn57c8/solution_1.py\", line 20, in <module>\\n    check(intersperse)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp7gzn57c8/solution_1.py\", line 19, in check\\n    assert candidate([5, 6, 3, 2], 8) == [5, 8, 6, 8, 3, 8, 2]\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp7gzn57c8/solution_1.py\", line 17, in intersperse\\n    return helper(1, [list_of_numbers[0]])\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp7gzn57c8/solution_1.py\", line 12, in helper\\n    return helper(idx + 1, res + [list_of_numbers[idx], delimiter])\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp7gzn57c8/solution_1.py\", line 12, in helper\\n    return helper(idx + 1, res + [list_of_numbers[idx], delimiter])\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp7gzn57c8/solution_1.py\", line 12, in helper\\n    return helper(idx + 1, res + [list_of_numbers[idx], delimiter])\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp7gzn57c8/solution_1.py\", line 10, in helper\\n    return res + [list_of_numbers[idx]]\\nIndexError: list index out of range\\n', 'Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp7gzn57c8/solution_2.py\", line 20, in <module>\\n    check(intersperse)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp7gzn57c8/solution_2.py\", line 19, in check\\n    assert candidate([2, 2, 2], 2) == [2, 2, 2, 2, 2]\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp7gzn57c8/solution_2.py\", line 17, in intersperse\\n    return helper(1, [list_of_numbers[0]])\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp7gzn57c8/solution_2.py\", line 12, in helper\\n    return helper(idx + 1, res + [list_of_numbers[idx], delimiter])\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp7gzn57c8/solution_2.py\", line 12, in helper\\n    return helper(idx + 1, res + [list_of_numbers[idx], delimiter])\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp7gzn57c8/solution_2.py\", line 10, in helper\\n    return res + [list_of_numbers[idx]]\\nIndexError: list index out of range\\n']\nHere is a version of the pseudocode that IS reproducible:\n```\nFUNCTION intersperse(list_of_numbers, delimiter)\n    IF LENGTH(list_of_numbers) == 0 THEN\n        RETURN []\n    END IF\n\n    INITIALIZE result_list AS []\n\n    FOR index FROM 0 TO LENGTH(list_of_numbers) - 2\n        ADD list_of_numbers[index] TO result_list\n        ADD delimiter TO result_list\n    END FOR\n\n    ADD list_of_numbers[LENGTH(list_of_numbers) - 1] TO result_list\n\n    RETURN result_list\nEND FUNCTION\n```\n```\nFUNCTION rolling_max(list_of_numbers)\n  DEFINE iterate(idx, current_max, acc_snake)\n    IF idx == LENGTH(list_of_numbers) THEN\n      RETURN acc_snake\n    END IF\n    \n    LET next_val_camel = list_of_numbers[idx]\n    LET updatedMax = (current_max * (current_max >= next_val_camel)) + (next_val_camel * (next_val_camel > current_max))\n    LET new_accumulator = acc_snake + [updatedMax]\n    \n    RETURN iterate(idx + 1, updatedMax, new_accumulator)\n  END DEFINE\n\n  IF LENGTH(list_of_numbers) == 0 THEN\n    RETURN []\n  END IF\n\n  RETURN iterate(0, -1 * (2 ^ 1000), [])[1:] + [list_of_numbers[0]] WHERE\n    -1 * (2 ^ 1000)  simulates None replacement, but with a quirk handled through slicing and concatenation to emulate initial state\nEND FUNCTION\n```\nHere are the errors for this pseudocode:\n['Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp3c6cmez8/solution_1.py\", line 26, in <module>\\n    check(rolling_max)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp3c6cmez8/solution_1.py\", line 25, in check\\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\\nAssertionError\\n', 'Traceback (most recent call last):\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp3c6cmez8/solution_3.py\", line 26, in <module>\\n    check(rolling_max)\\n  File \"/var/folders/x3/l43tt5dd3y19dmn0cq8rhm7r0000gq/T/tmp3c6cmez8/solution_3.py\", line 25, in check\\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\\nAssertionError\\n']\nHere is a version of the pseudocode that IS reproducible:\n```\nFUNCTION rolling_max(list_of_numbers)\n    INITIALIZE result_list AS an empty list\n    INITIALIZE running_maximum AS undefined\n\n    FOR index FROM 0 TO LENGTH(list_of_numbers) - 1\n        IF running_maximum IS undefined THEN\n            running_maximum = list_of_numbers[index]\n        ELSE\n            IF list_of_numbers[index] > running_maximum THEN\n                running_maximum = list_of_numbers[index]\n            END IF\n        END IF\n        ADD running_maximum TO result_list\n    END FOR\n\n    RETURN result_list\nEND FUNCTION\n```\n\nAvg Score for all pseudocodes: 0.4782608695652174",
  "iter": 4
}