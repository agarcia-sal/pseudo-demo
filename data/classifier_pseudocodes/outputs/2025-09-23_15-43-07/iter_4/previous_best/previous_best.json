{
  "prompt": "Given the prior prompt and empirical evaluation insights, key shortcomings appear to stem from ambiguities and insufficient rigor in assessing pseudocode completeness, clarity, and executable structure\u2014leading to misclassification, especially around pseudocode lacking explicit method signatures, class definitions, or proper scoping, and borderline cases near full reproducibility.\n\nTo substantially improve performance, the new prompt will:\n\n- Enforce rigorous checks for explicit definitions of all required components (class, function signatures with correct parameters matching expected usage).\n- Demand clarity about control flow, data structures, and operations that guarantee unambiguous translation to executable code.\n- Incorporate evaluation of whether pseudocode could be implemented without assumptions or guesswork, including handling input/output, initialization, loop and branching completeness.\n- Explicitly instruct to treat nearly complete but ambiguous or incomplete pseudocode as non-reproducible (\"0\"), ensuring stronger precision.\n- Provide a systematic analytic framework to evaluate reproducibility (structural completeness, operational clarity, input/output coverage).\n- Emphasize adherence to passing *all* unit tests, ruling out partial correctness or near-miss coverage.\n- Retain strict output requirements: output exactly \"1\" or \"0\" with no extra text.\n\n\n---\n\n### Improved prompt:\n\n```\nYou are given a pseudocode implementation purported to solve a programming problem. Your task is to determine if this pseudocode is *fully reproducible* \u2014 meaning that it is written with sufficient explicitness, clarity, and completeness such that an experienced developer could implement it directly and have the resulting program pass *every* relevant unit test for that problem without needing any assumptions or additional information.\n\nConsider the following criteria when making your judgement:\n\n1. **Structural completeness:**  \n   - The pseudocode must explicitly define all necessary components, including classes, functions/methods with correct parameter names and count matching typical usage.  \n   - All control structures (loops, conditionals, recursion) must be clearly and unambiguously delineated.  \n   - Data structures and their initializations should be clearly specified.\n\n2. **Operational clarity:**  \n   - Each step must have a precise and unambiguous description of the operations to be performed (e.g., index handling, arithmetic, logical operations, assignments).  \n   - The flow of data and control must be explicit, with no gaps or vague statements that could cause differing implementations.\n\n3. **Input/output coverage:**  \n   - The pseudocode must specify how inputs are received (including variable names as used in function signatures).  \n   - The output or return value must be clearly stated and depend only on the defined inputs and intermediate computations.\n\n4. **No assumptions or missing details:**  \n   - The pseudocode should not omit critical steps or leave implementation details implicit, including edge cases, initialization details, and final return values.  \n   - It should not rely on unstated language features, syntactic sugar, or assumed knowledge beyond the pseudocode itself.\n\n5. **Correctness for all test cases:**  \n   - Assume the pseudocode is meant to cover all relevant edge cases and satisfy all unit tests for the given problem domain.  \n   - Partial implementations or near-complete solutions that would fail some tests must be considered *not* reproducible.\n\nAfter careful deliberation, output a single integer **1** if the pseudocode meets *all* the above criteria and can be considered fully reproducible as defined. Otherwise, output **0**.\n\n**Output strictly: 1 or 0. Nothing else.**  \nThe outputs should be produced in the same order as the pseudocode inputs are fed.\n\n---\n\nPseudocode:\n\n```\n<<INSERT PSEUDOCODE HERE>>\n```\n```\n\n---\n\nThis prompt's innovations lie in explicit, criterion-based evaluation rather than mere intuition or vague \"clarity,\" which addresses borderline and near-miss cases more robustly.\n\nBy requiring precise matching of function signatures, input/output definitions, explicit control flow, and forbidding assumptions, it will reduce false positives on incomplete or ambiguous pseudocode and improve the distinction between reproducible and non-reproducible inputs.\n\nThe formal, enumerated checklist also encourages thorough analysis leading to more consistent and justifiable outputs, which should enhance test-time performance significantly.",
  "response": "Given the prior prompt and empirical evaluation insights, key shortcomings appear to stem from ambiguities and insufficient rigor in assessing pseudocode completeness, clarity, and executable structure\u2014leading to misclassification, especially around pseudocode lacking explicit method signatures, class definitions, or proper scoping, and borderline cases near full reproducibility.\n\nTo substantially improve performance, the new prompt will:\n\n- Enforce rigorous checks for explicit definitions of all required components (class, function signatures with correct parameters matching expected usage).\n- Demand clarity about control flow, data structures, and operations that guarantee unambiguous translation to executable code.\n- Incorporate evaluation of whether pseudocode could be implemented without assumptions or guesswork, including handling input/output, initialization, loop and branching completeness.\n- Explicitly instruct to treat nearly complete but ambiguous or incomplete pseudocode as non-reproducible (\"0\"), ensuring stronger precision.\n- Provide a systematic analytic framework to evaluate reproducibility (structural completeness, operational clarity, input/output coverage).\n- Emphasize adherence to passing *all* unit tests, ruling out partial correctness or near-miss coverage.\n- Retain strict output requirements: output exactly \"1\" or \"0\" with no extra text.\n\n\n---\n\n### Improved prompt:\n\n```\nYou are given a pseudocode implementation purported to solve a programming problem. Your task is to determine if this pseudocode is *fully reproducible* \u2014 meaning that it is written with sufficient explicitness, clarity, and completeness such that an experienced developer could implement it directly and have the resulting program pass *every* relevant unit test for that problem without needing any assumptions or additional information.\n\nConsider the following criteria when making your judgement:\n\n1. **Structural completeness:**  \n   - The pseudocode must explicitly define all necessary components, including classes, functions/methods with correct parameter names and count matching typical usage.  \n   - All control structures (loops, conditionals, recursion) must be clearly and unambiguously delineated.  \n   - Data structures and their initializations should be clearly specified.\n\n2. **Operational clarity:**  \n   - Each step must have a precise and unambiguous description of the operations to be performed (e.g., index handling, arithmetic, logical operations, assignments).  \n   - The flow of data and control must be explicit, with no gaps or vague statements that could cause differing implementations.\n\n3. **Input/output coverage:**  \n   - The pseudocode must specify how inputs are received (including variable names as used in function signatures).  \n   - The output or return value must be clearly stated and depend only on the defined inputs and intermediate computations.\n\n4. **No assumptions or missing details:**  \n   - The pseudocode should not omit critical steps or leave implementation details implicit, including edge cases, initialization details, and final return values.  \n   - It should not rely on unstated language features, syntactic sugar, or assumed knowledge beyond the pseudocode itself.\n\n5. **Correctness for all test cases:**  \n   - Assume the pseudocode is meant to cover all relevant edge cases and satisfy all unit tests for the given problem domain.  \n   - Partial implementations or near-complete solutions that would fail some tests must be considered *not* reproducible.\n\nAfter careful deliberation, output a single integer **1** if the pseudocode meets *all* the above criteria and can be considered fully reproducible as defined. Otherwise, output **0**.\n\n**Output strictly: 1 or 0. Nothing else.**  \nThe outputs should be produced in the same order as the pseudocode inputs are fed.\n\n---\n\nPseudocode:\n\n```\n<<INSERT PSEUDOCODE HERE>>\n```\n```\n\n---\n\nThis prompt's innovations lie in explicit, criterion-based evaluation rather than mere intuition or vague \"clarity,\" which addresses borderline and near-miss cases more robustly.\n\nBy requiring precise matching of function signatures, input/output definitions, explicit control flow, and forbidding assumptions, it will reduce false positives on incomplete or ambiguous pseudocode and improve the distinction between reproducible and non-reproducible inputs.\n\nThe formal, enumerated checklist also encourages thorough analysis leading to more consistent and justifiable outputs, which should enhance test-time performance significantly.",
  "score": 0.7366666666666667,
  "feedback": "We have a 4 way split for the pseudocodes: true positives, which are pseudocodes that correspond to code that passes all test cases.\nWe also have true negatives, which are pseudocodes that correspond to code that do not pass all test cases.\nWe have cosmetic, which are pseudocodes that are variations of the positive pseudocodes and also pass all test cases.\nWe have near-misses, which are pseudocodes that correspond to code that almost passes all test cases but do not. They pass at least 80% of test cases\nHere is the score for this prompt on positive-labeled pseudocodes: 0.8933333333333333\nHere is the score for this prompt on negative-labeled pseudocodes: 0.58\nHere is the score for this prompt on cosmetic-labeled pseudocodes: 0.9\nHere is the score for this prompt on near_miss-labeled pseudocodes: 0.2\n\nThe following are pseudocodes that are reproducible but were labeled as not:\nCLASS Solution  \n    FUNCTION uniquePaths(m n)  \n        SET dp TO a two dimensional list with m rows and n columns where each element is set to one  \n        FOR i FROM two TO m  \n            FOR j FROM two TO n  \n                SET element at position i of dp TO the list at position i of dp  \n                SET element at position j of element at position i of dp TO the sum of the element at position i MINUS one of dp at position j AND the element at position i of dp at position j MINUS one  \n            END FOR  \n        END FOR  \n        RETURN the element at position m MINUS one of dp at position n MINUS one  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION medianSlidingWindow(nums k)  \n        SET lo TO empty list  \n        SET hi TO empty list  \n\n        FUNCTION balance_heaps()  \n            IF the LENGTH OF lo IS GREATER THAN the LENGTH OF hi PLUS one  \n                CALL heappush WITH the argument hi AND NEGATIVE of the result of heappop ON lo  \n            ELSE IF the LENGTH OF hi IS GREATER THAN the LENGTH OF lo  \n                CALL heappush WITH the argument lo AND NEGATIVE of the result of heappop ON hi  \n            END IF  \n        END FUNCTION  \n\n        FUNCTION add_num(num)  \n            IF lo IS empty OR num IS LESS THAN OR EQUAL TO NEGATIVE of element at position zero of lo  \n                CALL heappush WITH the argument lo AND NEGATIVE num  \n            ELSE  \n                CALL heappush WITH the argument hi AND num  \n            END IF  \n            CALL balance_heaps()  \n        END FUNCTION  \n\n        FUNCTION remove_num(num)  \n            IF num IS LESS THAN OR EQUAL TO NEGATIVE of element at position zero of lo  \n                REMOVE NEGATIVE num FROM lo  \n                IF lo IS NOT empty  \n                    CALL heapify WITH the argument lo  \n                END IF  \n            ELSE  \n                REMOVE num FROM hi  \n                IF hi IS NOT empty  \n                    CALL heapify WITH the argument hi  \n                END IF  \n            END IF  \n            CALL balance_heaps()  \n        END FUNCTION  \n\n        FUNCTION get_median()  \n            IF the LENGTH OF lo IS GREATER THAN the LENGTH OF hi  \n                RETURN NEGATIVE of element at position zero of lo  \n            END IF  \n            RETURN NEGATIVE of element at position zero of lo PLUS element at position zero of hi DIVIDED BY two  \n        END FUNCTION  \n\n        FOR i FROM zero TO k MINUS one  \n            CALL add_num WITH element at position i of nums  \n        END FOR  \n\n        SET medians TO a list containing the result of get_median()  \n\n        FOR i FROM k TO the LENGTH OF nums MINUS one  \n            CALL add_num WITH element at position i of nums  \n            CALL remove_num WITH element at position i MINUS k of nums  \n            APPEND the result of get_median() TO medians  \n        END FOR  \n\n        RETURN medians  \n    END FUNCTION  \nEND CLASS\n\nThe following are modified pseudocodes of other reproducible versions of pseudocode that are reproducible but were labeled as not:\noriginal version of the pseudocode for this problem that is reproducible:\nCLASS Solution  \n    FUNCTION isRectangleCover(rectangles)  \n        SET X1 TO positive infinity  \n        SET Y1 TO positive infinity  \n        SET X2 TO negative infinity  \n        SET Y2 TO negative infinity  \n        \n        SET points TO empty set  \n        SET area TO zero  \n        \n        FOR each rectangle WITH elements x1 y1 x2 y2 IN rectangles  \n            IF X1 GREATER THAN x1 THEN  \n                SET X1 TO x1  \n            END IF  \n            IF Y1 GREATER THAN y1 THEN  \n                SET Y1 TO y1  \n            END IF  \n            IF X2 LESS THAN x2 THEN  \n                SET X2 TO x2  \n            END IF  \n            IF Y2 LESS THAN y2 THEN  \n                SET Y2 TO y2  \n            END IF  \n            \n            SET current_area TO (x2 MINUS x1) MULTIPLIED BY (y2 MINUS y1)  \n            INCREMENT area BY current_area  \n            \n            FOR each point p IN list containing element pair of x1 and y1 element pair of x1 and y2 element pair of x2 and y1 element pair of x2 and y2  \n                IF points CONTAINS p THEN  \n                    REMOVE p FROM points  \n                ELSE  \n                    ADD p TO points  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET expected_area TO (X2 MINUS X1) MULTIPLIED BY (Y2 MINUS Y1)  \n        IF area NOT EQUALS expected_area THEN  \n            RETURN False  \n        END IF  \n        \n        SET expected_points TO set containing element pair of X1 and Y1 element pair of X1 and Y2 element pair of X2 and Y1 element pair of X2 and Y2  \n        IF points NOT EQUALS expected_points THEN  \n            RETURN False  \n        END IF  \n        \n        RETURN True  \n    END FUNCTION  \nEND CLASS\nmodified version of the pseudocode for this problem that is also reproducible:\nCLASS Solution  \n    FUNCTION isRectangleCover(rectangles)  \n        LET minX BE positive infinity  \n        LET minY BE positive infinity  \n        LET maxX BE negative infinity  \n        LET maxY BE negative infinity  \n        \n        INITIALIZE corners AS empty set  \n        DEFINE totalArea AS 0  \n        \n        DEFINE idx AS 0  \n        WHILE idx LESS THAN LENGTH OF rectangles DO  \n            LET rect BE rectangles[idx]  \n            LET leftX BE rect[0]  \n            LET bottomY BE rect[1]  \n            LET rightX BE rect[2]  \n            LET topY BE rect[3]  \n            \n            IF NOT (leftX >= minX) THEN  \n                minX \u2190 leftX  \n            END IF  \n            IF NOT (bottomY >= minY) THEN  \n                minY \u2190 bottomY  \n            END IF  \n            IF NOT (rightX <= maxX) THEN  \n                maxX \u2190 rightX  \n            END IF  \n            IF NOT (topY <= maxY) THEN  \n                maxY \u2190 topY  \n            END IF  \n            \n            LET rectArea BE (rightX - leftX)  \n            LET height BE (topY - bottomY)  \n            LET thisArea BE rectArea * height  \n            totalArea \u2190 totalArea + thisArea  \n            \n            LET cornerPoints BE list of pairs: (leftX, bottomY), (leftX, topY), (rightX, bottomY), (rightX, topY)  \n            \n            LET ctr AS 0  \n            WHILE ctr LESS THAN LENGTH OF cornerPoints DO  \n                LET corner BE cornerPoints[ctr]  \n                IF corners CONTAINS corner THEN  \n                    REMOVE corner FROM corners  \n                ELSE  \n                    INSERT corner INTO corners  \n                END IF  \n                ctr \u2190 ctr + 1  \n            END WHILE  \n            idx \u2190 idx + 1  \n        END WHILE  \n        \n        LET fullWidth BE maxX - minX  \n        LET fullHeight BE maxY - minY  \n        LET expectedArea BE fullWidth * fullHeight  \n        \n        IF totalArea IS NOT expectedArea THEN  \n            RETURN False  \n        END IF  \n        \n        LET requiredCorners BE set of pairs: (minX, minY), (minX, maxY), (maxX, minY), (maxX, maxY)  \n        IF corners IS NOT EQUAL TO requiredCorners THEN  \n            RETURN False  \n        END IF  \n        \n        RETURN True  \n    END FUNCTION  \nEND CLASS\noriginal version of the pseudocode for this problem that is reproducible:\nCLASS Solution  \n    FUNCTION wordSquares(words)  \n        SET prefix_to_words TO an empty mapping from string to list of strings  \n        FOR each word IN words  \n            FOR index FROM zero TO the LENGTH OF word MINUS one  \n                SET prefix TO the substring of word from position zero TO position index MINUS one  \n                APPEND word TO the list at prefix_to_words corresponding to prefix  \n            END FOR  \n        END FOR  \n        \n        SET results TO an empty list  \n        \n        FUNCTION backtrack(square)  \n            IF the LENGTH OF square EQUALS the LENGTH OF the first element of words THEN  \n                APPEND square TO results  \n                RETURN  \n            END IF  \n            \n            SET prefix TO an empty string  \n            FOR each word_element IN square  \n                APPEND the element at position the LENGTH OF square of word_element TO prefix  \n            END FOR  \n            \n            FOR each candidate IN the list at prefix_to_words corresponding to prefix  \n                CALL backtrack WITH the argument of the concatenation of square with candidate as a new list element  \n            END FOR  \n        END FUNCTION  \n        \n        FOR each word IN words  \n            CALL backtrack WITH a list containing only word  \n        END FOR  \n        \n        RETURN results  \n    END FUNCTION  \nEND CLASS\nmodified version of the pseudocode for this problem that is also reproducible:\nCLASS Solution\n    FUNCTION wordSquares(words)\n        SET lookup TO an empty mapping from string to list of strings\n\n        SET w_index TO 0\n        WHILE w_index < LENGTH(words)\n            SET current_word TO words[w_index]\n            SET i TO 0\n            WHILE i < LENGTH(current_word)\n                SET key TO substring(current_word, 0, i)\n                IF NOT lookup HAS KEY key THEN\n                    lookup[key] \u2190 an empty list\n                END IF\n                SET word_list TO lookup[key]\n                word_list \u2190 word_list + [current_word]\n                lookup[key] \u2190 word_list\n                i \u2190 i + 1\n            END WHILE\n            w_index \u2190 w_index + 1\n        END WHILE\n\n        SET output TO an empty list\n\n        FUNCTION backtrack(square)\n            IF NOT LENGTH(square) \u2260 LENGTH(words[0]) THEN\n                output \u2190 output + [square]\n                RETURN\n            END IF\n\n            SET build_prefix TO \"\"\n            SET idx TO 0\n            WHILE idx < LENGTH(square)\n                SET temp_word TO square[idx]\n                SET prefix_char TO temp_word[LENGTH(square)]\n                build_prefix \u2190 build_prefix + prefix_char\n                idx \u2190 idx + 1\n            END WHILE\n\n            IF lookup HAS KEY build_prefix THEN\n                SET candidates_list TO lookup[build_prefix]\n                SET c_idx TO 0\n                WHILE c_idx < LENGTH(candidates_list)\n                    SET next_word TO candidates_list[c_idx]\n                    backtrack(square + [next_word])\n                    c_idx \u2190 c_idx + 1\n                END WHILE\n            END IF\n        END FUNCTION\n\n        FOR EACH initial_word IN words\n            backtrack([initial_word])\n        END FOR\n\n        RETURN output\n    END FUNCTION\nEND CLASS\n\nThe following are pseudocodes that are not reproducible but were labeled as reproducible:\nCLASS Solution\n    FUNCTION isMatch(string_s, string_p)\n        SET dp TO a two dimensional list of BOOLEAN false VALUES with the number of rows EQUAL TO the LENGTH OF string_s PLUS one AND the number of columns EQUAL TO the LENGTH OF string_p PLUS one\n\n        SET the element at row zero AND column zero OF dp TO true\n\n        FOR index_j FROM one TO the LENGTH OF string_p INCLUSIVE\n            IF the element at position index_j MINUS one OF string_p EQUALS character star\n                SET the element at row zero AND column index_j OF dp TO the element at row zero AND column index_j MINUS one OF dp\n            END IF\n        END FOR\n        \n        FOR index_i FROM one TO the LENGTH OF string_s INCLUSIVE\n            FOR index_j FROM one TO the LENGTH OF string_p INCLUSIVE\n                IF the element at position index_j MINUS one OF string_p EQUALS character star\n                    SET the element at row index_i AND column index_j OF dp TO the element at row index_i MINUS one AND column index_j OF dp OR the element at row index_i AND column index_j MINUS one OF dp\n                ELSE IF the element at position index_j MINUS one OF string_p EQUALS character question MARK OR the element at position index_i MINUS one OF string_s EQUALS the element at position index_j MINUS one OF string_p\n                    SET the element at row index_i AND column index_j OF dp TO the element at row index_i MINUS one AND column index_j MINUS one OF dp\n                END IF\n            END FOR\n        END FOR\n\n        RETURN the element at row the LENGTH OF string_s AND column the LENGTH OF string_p OF dp\n    END FUNCTION\nEND CLASS\nHere are the errors for this pseudocode:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmp9fs83dtq/solution_0.py\", line 45, in <module>\\n    print(Solution().isMatch(s = \"ho\", p = \"ho***\"))\\n          ^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'isMatch\\'\\n', 'Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmp9fs83dtq/solution_1.py\", line 45, in <module>\\n    print(Solution().isMatch(s = \"abcdef\", p = \"abc*ef\"))\\n          ^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'isMatch\\'\\n', 'Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmp9fs83dtq/solution_2.py\", line 45, in <module>\\n    print(Solution().isMatch(s = \"abcabczzzde\", p = \"*abc???de*\"))\\n          ^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'isMatch\\'\\n', 'Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmp9fs83dtq/solution_3.py\", line 45, in <module>\\n    print(Solution().isMatch(s = \"abbabbbbbbabaababbabbbabaaabbaaaaabbbabbbabaaabbabbaaabbbabaabbbabbabbabbbbba\", p = \"*a*****b*bb*b****b*bb*bb*a*aa*b*b*a*a*b*aba*b*ba*a*aab*bbb*a*aaab*ba*a*bb*bb*bb*ba*ba*b*ab*b*b\"))\\n          ^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'isMatch\\'\\n', 'Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmp9fs83dtq/solution_4.py\", line 45, in <module>\\n    print(Solution().isMatch(s = \"aabbccddeeff\", p = \"a*b*c*d*e*f*\"))\\n          ^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'isMatch\\'\\n']\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION isMatch(s, p)  \n        SET dp TO a two dimensional list of False with the number of rows equal to the length of s PLUS one and the number of columns equal to the length of p PLUS one  \n        SET element at position zero zero of dp TO True  \n        FOR j FROM one TO the length of p  \n            IF element at position j MINUS one of p EQUALS the character representing asterisk  \n                SET element at position zero j of dp TO the value of element at position zero j MINUS one of dp  \n            END IF  \n        END FOR  \n        FOR i FROM one TO the length of s  \n            FOR j FROM one TO the length of p  \n                IF element at position j MINUS one of p EQUALS the character representing asterisk  \n                    SET element at position i j of dp TO the value of element at position i MINUS one j of dp OR the value of element at position i j MINUS one of dp  \n                ELSE IF element at position j MINUS one of p EQUALS the character representing question mark OR element at position i MINUS one of s EQUALS element at position j MINUS one of p  \n                    SET element at position i j of dp TO the value of element at position i MINUS one j MINUS one of dp  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position the length of s the length of p of dp  \n    END FUNCTION  \nEND CLASS\nCLASS Solution\n    FUNCTION canJump(list_of_numbers)\n        SET farthest_reachable_index TO zero\n        FOR index FROM zero TO the LENGTH OF list_of_numbers MINUS one INCLUSIVE\n            IF index GREATER THAN farthest_reachable_index\n                RETURN False\n            END IF\n            SET possible_reach TO index PLUS element at position index OF list_of_numbers\n            SET farthest_reachable_index TO the GREATER OF farthest_reachable_index AND possible_reach\n        END FOR\n        RETURN farthest_reachable_index GREATER THAN OR EQUAL TO the LENGTH OF list_of_numbers MINUS one\n    END FUNCTION\nEND CLASS\nHere are the errors for this pseudocode:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpp37hyifd/solution_0.py\", line 29, in <module>\\n    print(Solution().canJump(nums = [2,3,1,1,4]))\\n          ^^^^^^^^\\nNameError: name \\'Solution\\' is not defined\\n', 'Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpp37hyifd/solution_1.py\", line 29, in <module>\\n    print(Solution().canJump(nums = [3,2,1,0,4]))\\n          ^^^^^^^^\\nNameError: name \\'Solution\\' is not defined\\n', 'Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpp37hyifd/solution_2.py\", line 29, in <module>\\n    print(Solution().canJump(nums = [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]))\\n          ^^^^^^^^\\nNameError: name \\'Solution\\' is not defined\\n', 'Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpp37hyifd/solution_3.py\", line 29, in <module>\\n    print(Solution().canJump(nums = [1,2,3,4,5,6,7,8,9,10]))\\n          ^^^^^^^^\\nNameError: name \\'Solution\\' is not defined\\n', 'Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpp37hyifd/solution_4.py\", line 29, in <module>\\n    print(Solution().canJump(nums = [5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]))\\n          ^^^^^^^^\\nNameError: name \\'Solution\\' is not defined\\n']\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION canJump(nums)  \n        SET farthest TO zero  \n        FOR i FROM zero TO the LENGTH OF nums MINUS one  \n            IF i GREATER THAN farthest  \n                RETURN false  \n            END IF  \n            SET possible_reach TO i PLUS element at position i of nums  \n            IF possible_reach GREATER THAN farthest  \n                SET farthest TO possible_reach  \n            END IF  \n        END FOR  \n        IF farthest GREATER THAN OR EQUAL TO the LENGTH OF nums MINUS one  \n            RETURN true  \n        ELSE  \n            RETURN false  \n        END IF  \n    END FUNCTION  \nEND CLASS\n\nThe following are near-miss pseudocodes - they are almost reproducible but were labeled as reproducible:\nCLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET INT_MAX TO two POWERED BY thirty ONE MINUS one  \n        SET INT_MIN TO negative two POWERED BY thirty ONE  \n        SET result TO zero  \n        SET index TO zero  \n        SET n TO the LENGTH OF s  \n        SET sign TO one  \n        WHILE index LESS THAN n AND character at position index OF s EQUALS a single whitespace character  \n            INCREMENT index BY one  \n        END WHILE  \n        IF index LESS THAN n AND (character at position index OF s EQUALS the plus sign OR character at position index OF s EQUALS the minus sign)  \n            IF character at position index OF s EQUALS the minus sign  \n                SET sign TO negative one  \n            ELSE  \n                SET sign TO one  \n            END IF  \n            INCREMENT index BY one  \n        END IF  \n        WHILE index LESS THAN n AND character at position index OF s IS A DIGIT  \n            SET digit TO the INTEGER VALUE OF character at position index OF s  \n            IF result GREATER THAN (INT_MAX MINUS digit) DIVIDED BY ten  \n                IF sign EQUALS one  \n                    RETURN INT_MAX  \n                ELSE  \n                    RETURN INT_MIN  \n                END IF  \n            END IF  \n            SET result TO result MULTIPLIED BY ten PLUS digit  \n            INCREMENT index BY one  \n        END WHILE  \n        RETURN sign MULTIPLIED BY result  \n    END FUNCTION  \nEND CLASS\nPassing rate for this pseudocode: 0.96875, but was given a label of 1\nHere are the errors for this pseudocode:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmps6pxau_y/solution_0.py\", line 54, in <module>\\n    print(Solution().myAtoi(s = \"42\"))\\n          ^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'myAtoi\\'\\n', 'Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmps6pxau_y/solution_1.py\", line 54, in <module>\\n    print(Solution().myAtoi(s = \" -042\"))\\n          ^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'myAtoi\\'\\n', 'Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmps6pxau_y/solution_2.py\", line 54, in <module>\\n    print(Solution().myAtoi(s = \"1337c0d3\"))\\n          ^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'myAtoi\\'\\n', 'Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmps6pxau_y/solution_3.py\", line 54, in <module>\\n    print(Solution().myAtoi(s = \"0-1\"))\\n          ^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'myAtoi\\'\\n', 'Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmps6pxau_y/solution_4.py\", line 54, in <module>\\n    print(Solution().myAtoi(s = \"words and 987\"))\\n          ^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'myAtoi\\'\\n']\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET INT_MAX TO two RAISED TO THE POWER OF thirty ONE MINUS one  \n        SET INT_MIN TO the NEGATIVE of two RAISED TO THE POWER OF thirty ONE  \n        SET result TO zero  \n        SET index TO zero  \n        SET n TO the LENGTH OF s  \n        SET sign TO one  \n        WHILE index LESS THAN n AND element at position index of s EQUALS the space character  \n            INCREMENT index BY one  \n        END WHILE  \n        IF index LESS THAN n AND (element at position index of s EQUALS the plus character OR element at position index of s EQUALS the minus character)  \n            IF element at position index of s EQUALS the minus character  \n                SET sign TO the NEGATIVE of one  \n            ELSE  \n                SET sign TO one  \n            END IF  \n            INCREMENT index BY one  \n        END IF  \n        WHILE index LESS THAN n AND element at position index of s IS A DIGIT  \n            SET digit TO the INTEGER VALUE OF element at position index of s  \n            IF result GREATER THAN INT_MAX MINUS digit DIVIDED BY ten  \n                IF sign EQUALS one  \n                    RETURN INT_MAX  \n                ELSE  \n                    RETURN INT_MIN  \n                END IF  \n            END IF  \n            SET result TO result MULTIPLIED BY ten PLUS digit  \n            INCREMENT index BY one  \n        END WHILE  \n        RETURN sign MULTIPLIED BY result  \n    END FUNCTION  \nEND CLASS\nCLASS Solution\n    FUNCTION multiply(num1 string, num2 string) RETURNS string\n        IF num1 IS \"0\" OR num2 IS \"0\"\n            RETURN \"0\"\n        END IF\n\n        DECLARE digits AS MAP from INT to INT\n        DECLARE lengthSum AS INT = LENGTH(num1) + LENGTH(num2)\n        FOR index IN RANGE(lengthSum)\n            digits[index] = 0\n        END FOR\n\n        DECLARE reversed1 AS string = \"\"\n        DECLARE reversed2 AS string = \"\"\n        FOR p FROM LENGTH(num1) - 1 DOWNTO 0\n            reversed1 = reversed1 + num1[p]\n        END FOR\n        FOR q FROM LENGTH(num2) - 1 DOWNTO 0\n            reversed2 = reversed2 + num2[q]\n        END FOR\n\n        DECLARE function recursiveMul(i INT, j INT) RETURNS VOID\n            IF i = LENGTH(reversed1)\n                RETURN\n            END IF\n            IF j = LENGTH(reversed2)\n                recursiveMul(i + 1, 0)\n                RETURN\n            END IF\n\n            DECLARE valA AS INT = ASCII_CODE(reversed1[i]) - ASCII_CODE(\"0\")\n            DECLARE valB AS INT = ASCII_CODE(reversed2[j]) - ASCII_CODE(\"0\")\n            DECLARE product AS INT = valA * valB\n            DECLARE baseIndex AS INT = i + j\n            DECLARE nextIndex AS INT = baseIndex + 1\n            DECLARE totalSum AS INT = product + digits[baseIndex]\n\n            digits[baseIndex] = totalSum MOD 10\n            digits[nextIndex] = digits[nextIndex] + (totalSum DIV 10)\n\n            recursiveMul(i, j + 1)\n        END FUNCTION\n\n        CALL recursiveMul(0, 0)\n\n        DECLARE output AS string = \"\"\n        FOR key FROM lengthSum - 1 DOWNTO 0\n            output = output + TO_STRING(digits[key])\n        END FOR\n\n        WHILE LENGTH(output) > 1 AND output[0] = \"0\"\n            output = SUBSTRING(output, 1)\n        END WHILE\n\n        RETURN output\n    END FUNCTION\nEND CLASS\nPassing rate for this pseudocode: 0.9666666666666667, but was given a label of 1\nHere are the errors for this pseudocode:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmp3bd59_62/solution_0.py\", line 36, in <module>\\n    print(Solution().multiply(num1 = \"2\", num2 = \"3\"))\\n          ^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'multiply\\'\\n', 'Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmp3bd59_62/solution_1.py\", line 36, in <module>\\n    print(Solution().multiply(num1 = \"123\", num2 = \"456\"))\\n          ^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'multiply\\'\\n', 'Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmp3bd59_62/solution_2.py\", line 36, in <module>\\n    print(Solution().multiply(num1 = \"1\", num2 = \"12345678901234567890\"))\\n          ^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'multiply\\'\\n', 'Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmp3bd59_62/solution_3.py\", line 36, in <module>\\n    print(Solution().multiply(num1 = \"12345678901234567890\", num2 = \"9876543210\"))\\n          ^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'multiply\\'\\n', 'Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmp3bd59_62/solution_4.py\", line 36, in <module>\\n    print(Solution().multiply(num1 = \"0\", num2 = \"987654321\"))\\n          ^^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'multiply\\'\\n']\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION multiply(num1 string num2 string) RETURNS string  \n        IF num1 EQUALS string zero OR num2 EQUALS string zero  \n            RETURN string zero  \n        END IF  \n\n        SET result TO a list of zeros with the LENGTH OF num1 PLUS the LENGTH OF num2  \n\n        SET num1 TO the reversal of num1  \n        SET num2 TO the reversal of num2  \n\n        FOR i FROM zero TO the LENGTH OF num1 MINUS one  \n            FOR j FROM zero TO the LENGTH OF num2 MINUS one  \n                SET mul TO the character code of the element at position i of num1 MINUS the character code of string zero MULTIPLIED BY the character code of the element at position j of num2 MINUS the character code of string zero  \n                SET p1 TO i PLUS j  \n                SET p2 TO i PLUS j PLUS one  \n                SET sum TO mul PLUS the element at position p1 of result  \n\n                SET the element at position p1 of result TO sum MODULO ten  \n                INCREMENT the element at position p2 of result BY the integer division of sum BY ten  \n            END FOR  \n        END FOR  \n\n        SET result_str TO the concatenation of the string representations of the elements of result in reverse order  \n        RETURN result_str with all leading string zeros removed  \n    END FUNCTION  \nEND CLASS\nCLASS Solution\n    FUNCTION isMatch(s, p)\n        SET x TO LENGTH(s)\n        SET y TO LENGTH(p)\n        SET dp TO []\n        SET u TO 0\n        WHILE u <= x\n            SET tempList TO []\n            SET v TO 0\n            WHILE v <= y\n                APPEND False TO tempList\n                SET v TO v + 1\n            END WHILE\n            APPEND tempList TO dp\n            SET u TO u + 1\n        END WHILE\n\n        SET dp[0][0] TO True\n\n        PROCEDURE fillFirstRow(w)\n            IF w > y THEN\n                RETURN\n            END IF\n            IF p[w - 1] = '*'\n                SET dp[0][w] TO dp[0][w - 1]\n            END IF\n            fillFirstRow(w + 1)\n        END PROCEDURE\n\n        CALL fillFirstRow(1)\n\n        PROCEDURE processRow(i, j)\n            IF i > x THEN\n                RETURN\n            END IF\n            IF j > y THEN\n                CALL processRow(i + 1, 1)\n                RETURN\n            END IF\n\n            SWITCH TRUE\n                CASE (p[j - 1] = '*')\n                    SET dp[i][j] TO dp[i - 1][j] OR dp[i][j - 1]\n                BREAK\n\n                CASE (p[j - 1] = '?' OR s[i - 1] = p[j - 1])\n                    SET dp[i][j] TO dp[i - 1][j - 1]\n                BREAK\n\n                DEFAULT\n                    // dp[i][j] remains False implicitly\n                BREAK\n            END SWITCH\n\n            processRow(i, j + 1)\n        END PROCEDURE\n\n        CALL processRow(1, 1)\n\n        RETURN dp[x][y]\n    END FUNCTION\nEND CLASS\nPassing rate for this pseudocode: 0.96, but was given a label of 1\nHere are the errors for this pseudocode:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmp8y2asww1/solution_0.py\", line 51, in <module>\\n    print(Solution().isMatch(s = \"ho\", p = \"ho***\"))\\n          ^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'isMatch\\'\\n', 'Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmp8y2asww1/solution_1.py\", line 51, in <module>\\n    print(Solution().isMatch(s = \"abcdef\", p = \"abc*ef\"))\\n          ^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'isMatch\\'\\n', 'Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmp8y2asww1/solution_2.py\", line 51, in <module>\\n    print(Solution().isMatch(s = \"abcabczzzde\", p = \"*abc???de*\"))\\n          ^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'isMatch\\'\\n', 'Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmp8y2asww1/solution_3.py\", line 51, in <module>\\n    print(Solution().isMatch(s = \"abbabbbbbbabaababbabbbabaaabbaaaaabbbabbbabaaabbabbaaabbbabaabbbabbabbabbbbba\", p = \"*a*****b*bb*b****b*bb*bb*a*aa*b*b*a*a*b*aba*b*ba*a*aab*bbb*a*aaab*ba*a*bb*bb*bb*ba*ba*b*ab*b*b\"))\\n          ^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'isMatch\\'\\n', 'Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmp8y2asww1/solution_4.py\", line 51, in <module>\\n    print(Solution().isMatch(s = \"aabbccddeeff\", p = \"a*b*c*d*e*f*\"))\\n          ^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'isMatch\\'\\n']\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION isMatch(s, p)  \n        SET dp TO a two dimensional list of False with the number of rows equal to the length of s PLUS one and the number of columns equal to the length of p PLUS one  \n        SET element at position zero zero of dp TO True  \n        FOR j FROM one TO the length of p  \n            IF element at position j MINUS one of p EQUALS the character representing asterisk  \n                SET element at position zero j of dp TO the value of element at position zero j MINUS one of dp  \n            END IF  \n        END FOR  \n        FOR i FROM one TO the length of s  \n            FOR j FROM one TO the length of p  \n                IF element at position j MINUS one of p EQUALS the character representing asterisk  \n                    SET element at position i j of dp TO the value of element at position i MINUS one j of dp OR the value of element at position i j MINUS one of dp  \n                ELSE IF element at position j MINUS one of p EQUALS the character representing question mark OR element at position i MINUS one of s EQUALS element at position j MINUS one of p  \n                    SET element at position i j of dp TO the value of element at position i MINUS one j MINUS one of dp  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position the length of s the length of p of dp  \n    END FUNCTION  \nEND CLASS\nCLASS Solution\n    FUNCTION combine WITH PARAMETERS n k\n        SET outcome TO []\n        FUNCTION backtrack WITH PARAMETERS pos seq\n            WHILE pos NOT EQUAL TO n + 1\n                APPEND pos TO seq\n                IF LENGTH seq EQUALS k THEN\n                    APPEND COPY OF seq TO outcome\n                ELSE\n                    CALL backtrack WITH ARGUMENTS pos + 1 seq\n                END IF\n                REMOVE LAST ITEM FROM seq\n                SET pos TO pos + 1\n            END WHILE\n        END FUNCTION\n        CALL backtrack WITH ARGUMENTS 1 []\n        RETURN outcome\n    END FUNCTION\nEND CLASS\nPassing rate for this pseudocode: 0.8823529411764706, but was given a label of 1\nHere are the errors for this pseudocode:\n['Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpc01neu5b/solution_0.py\", line 39, in <module>\\n    print(Solution().combine(n = 3, k = 2))\\n          ^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'combine\\'\\n', 'Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpc01neu5b/solution_1.py\", line 39, in <module>\\n    print(Solution().combine(n = 6, k = 4))\\n          ^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'combine\\'\\n', 'Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpc01neu5b/solution_2.py\", line 39, in <module>\\n    print(Solution().combine(n = 1, k = 1))\\n          ^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'combine\\'\\n', 'Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpc01neu5b/solution_3.py\", line 39, in <module>\\n    print(Solution().combine(n = 4, k = 2))\\n          ^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'combine\\'\\n', 'Traceback (most recent call last):\\n  File \"/var/folders/tm/227pgc2d0tzgphcb1s4kjrj80000gn/T/tmpc01neu5b/solution_4.py\", line 39, in <module>\\n    print(Solution().combine(n = 6, k = 0))\\n          ^^^^^^^^^^^^^^^^^^\\nAttributeError: \\'Solution\\' object has no attribute \\'combine\\'\\n']\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION combine WITH PARAMETERS n k  \n        FUNCTION backtrack WITH PARAMETERS start path  \n            IF the LENGTH OF path EQUALS k  \n                APPEND a COPY OF path TO result  \n                RETURN  \n            END IF  \n            FOR i FROM start TO n PLUS one  \n                APPEND i TO path  \n                CALL backtrack WITH ARGUMENTS i PLUS one path  \n                REMOVE the LAST ELEMENT FROM path  \n            END FOR  \n        END FUNCTION  \n        SET result TO an EMPTY LIST  \n        CALL backtrack WITH ARGUMENTS one AN EMPTY LIST  \n        RETURN result  \n    END FUNCTION  \nEND CLASS\n\nAvg Score for all pseudocodes: 0.7366666666666667"
}