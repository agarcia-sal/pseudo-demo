{
  "prompt": "Given one or more pseudocode snippets, each purporting to fully solve a problem, your sole task is to output a single digit (`1` or `0`) per snippet, concatenated into a single string reflecting the input order, with no spaces, punctuation, or any other characters.\n\n**Output a `1` if and only if the snippet is strictly reproducible \u2014 meaning it will deterministically pass _all possible valid unit tests_ for the stated problem, with no exceptions, failures, or undefined behavior under _any_ valid input scenario. Otherwise, output `0`.**\n\n---\n\n### Core evaluation principles (apply independently to each snippet):\n\n#### A. **Complete, Terminating, and Exhaustive Logic**  \n- The snippet fully specifies behavior covering all inputs, including edge and corner cases (empty, minimal, maximal, boundary).  \n- All control flows (loops, recursion, conditionals) conclusively terminate or produce defined results without infinite loops, deadlocks, or partial evaluations.  \n- No input branch or case is left unspecified, ambiguous, or partially handled.\n\n#### B. **Unambiguous, Self-contained Semantics**  \n- All variables, data structures, and operations used are explicitly declared, initialized, and updated within the snippet\u2014there are no hidden external dependencies, implicit states, or assumptions about a runtime environment.  \n- Data transformations and outputs are deterministic and consistent on identical inputs \u2014 no randomness, concurrency issues, or nondeterminism.  \n- No vagueness or underspecification in how computations proceed.\n\n#### C. **Algorithmic Correctness and Completeness**  \n- The snippet fully embodies a valid end-to-end algorithm that logically aligns with the problem requirements or can be soundly inferred as correct for the intended task.  \n- Partial outlines, incomplete heuristics, or mere sketches that omit critical steps or helper procedures cause failure.  \n- All auxiliary functions and procedures invoked are fully defined in the snippet or validly included in-context.  \n- Recognizable standard algorithms must be logically and structurally correct in core details (correct initialization, updates, and state transitions).\n\n#### D. **Robustness and Fault Handling**  \n- The snippet explicitly accounts for invalid inputs, exceptional/fault conditions, boundary values, numeric overflows/underflows, empty structures, and other corner cases.  \n- It either handles or explicitly excludes error conditions to avoid runtime failures, crashes, or undefined results.\n\n#### E. **Consistent Control Flow and Data Integrity**  \n- State changes occur in a logically consistent manner; there are no contradictory updates, unreachable code segments, or silent logical errors.  \n- Data dependencies and side effects are accounted for clearly within the snippet.\n\n---\n\n### Strict rules for assessment:\n\n- **Limit your analysis purely to the snippet itself, ignoring comments, formatting, variable naming, or any external context not explicitly given.**  \n- **Do not assess style, syntax variants, or superficial issues.**  \n- **If any single principle is violated, output `0` for that snippet.**  \n- **Only output `1` if the snippet meets _all_ the criteria beyond reasonable doubt.**\n\n---\n\n### Output format reminder:\n\n- Output exactly one `1` or `0` digit per snippet in input order, no spaces, no newlines, no extra text.\n\n---\n\n### Performance considerations:\n\n- Your judgment must be logically sound yet efficient enough to complete within 5 seconds per all snippets combined.  \n- Prioritize decisive, semantically precise evaluation over guesswork or partial heuristics.\n\n---\n\n**Summary**: Your role is a meticulous semantic verifier of reproducibility\u2014that is, if given these pseudocode snippets, can they be confidently regarded as fully correct, self-contained, terminating, error-free solutions guaranteed to pass _every_ valid unit test. Your output string encodes thus, per snippet, `1` for reproducible, `0` for otherwise, no more, no less.",
  "response": "Given one or more pseudocode snippets, each purporting to fully solve a problem, your sole task is to output a single digit (`1` or `0`) per snippet, concatenated into a single string reflecting the input order, with no spaces, punctuation, or any other characters.\n\n**Output a `1` if and only if the snippet is strictly reproducible \u2014 meaning it will deterministically pass _all possible valid unit tests_ for the stated problem, with no exceptions, failures, or undefined behavior under _any_ valid input scenario. Otherwise, output `0`.**\n\n---\n\n### Core evaluation principles (apply independently to each snippet):\n\n#### A. **Complete, Terminating, and Exhaustive Logic**  \n- The snippet fully specifies behavior covering all inputs, including edge and corner cases (empty, minimal, maximal, boundary).  \n- All control flows (loops, recursion, conditionals) conclusively terminate or produce defined results without infinite loops, deadlocks, or partial evaluations.  \n- No input branch or case is left unspecified, ambiguous, or partially handled.\n\n#### B. **Unambiguous, Self-contained Semantics**  \n- All variables, data structures, and operations used are explicitly declared, initialized, and updated within the snippet\u2014there are no hidden external dependencies, implicit states, or assumptions about a runtime environment.  \n- Data transformations and outputs are deterministic and consistent on identical inputs \u2014 no randomness, concurrency issues, or nondeterminism.  \n- No vagueness or underspecification in how computations proceed.\n\n#### C. **Algorithmic Correctness and Completeness**  \n- The snippet fully embodies a valid end-to-end algorithm that logically aligns with the problem requirements or can be soundly inferred as correct for the intended task.  \n- Partial outlines, incomplete heuristics, or mere sketches that omit critical steps or helper procedures cause failure.  \n- All auxiliary functions and procedures invoked are fully defined in the snippet or validly included in-context.  \n- Recognizable standard algorithms must be logically and structurally correct in core details (correct initialization, updates, and state transitions).\n\n#### D. **Robustness and Fault Handling**  \n- The snippet explicitly accounts for invalid inputs, exceptional/fault conditions, boundary values, numeric overflows/underflows, empty structures, and other corner cases.  \n- It either handles or explicitly excludes error conditions to avoid runtime failures, crashes, or undefined results.\n\n#### E. **Consistent Control Flow and Data Integrity**  \n- State changes occur in a logically consistent manner; there are no contradictory updates, unreachable code segments, or silent logical errors.  \n- Data dependencies and side effects are accounted for clearly within the snippet.\n\n---\n\n### Strict rules for assessment:\n\n- **Limit your analysis purely to the snippet itself, ignoring comments, formatting, variable naming, or any external context not explicitly given.**  \n- **Do not assess style, syntax variants, or superficial issues.**  \n- **If any single principle is violated, output `0` for that snippet.**  \n- **Only output `1` if the snippet meets _all_ the criteria beyond reasonable doubt.**\n\n---\n\n### Output format reminder:\n\n- Output exactly one `1` or `0` digit per snippet in input order, no spaces, no newlines, no extra text.\n\n---\n\n### Performance considerations:\n\n- Your judgment must be logically sound yet efficient enough to complete within 5 seconds per all snippets combined.  \n- Prioritize decisive, semantically precise evaluation over guesswork or partial heuristics.\n\n---\n\n**Summary**: Your role is a meticulous semantic verifier of reproducibility\u2014that is, if given these pseudocode snippets, can they be confidently regarded as fully correct, self-contained, terminating, error-free solutions guaranteed to pass _every_ valid unit test. Your output string encodes thus, per snippet, `1` for reproducible, `0` for otherwise, no more, no less.",
  "score": 0.6233333333333333,
  "feedback": "The following are pseudocodes that are reproducible but were labeled as not:\nCLASS Solution  \n    FUNCTION uniquePaths(m n)  \n        SET dp TO a two dimensional list with m rows and n columns where each element is set to one  \n        FOR i FROM two TO m  \n            FOR j FROM two TO n  \n                SET element at position i of dp TO the list at position i of dp  \n                SET element at position j of element at position i of dp TO the sum of the element at position i MINUS one of dp at position j AND the element at position i of dp at position j MINUS one  \n            END FOR  \n        END FOR  \n        RETURN the element at position m MINUS one of dp at position n MINUS one  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION canWin(currentState)  \n        SET memo TO an empty dictionary  \n        \n        FUNCTION can_win_helper(state)  \n            IF state EXISTS IN memo THEN  \n                RETURN the value associated with state in memo  \n            END IF  \n            \n            FOR index FROM zero TO the LENGTH OF state MINUS one MINUS one  \n                IF the element at position index of state EQUALS the plus character AND the element at position index PLUS one of state EQUALS the plus character THEN  \n                    SET new_state TO the substring from position zero TO position index MINUS one CONCATENATED WITH two minus characters CONCATENATED WITH the substring from position index PLUS two TO the END OF state  \n                    IF the result of calling can_win_helper WITH new_state IS EQUAL TO false THEN  \n                        SET the value associated with state in memo TO true  \n                        RETURN true  \n                    END IF  \n                END IF  \n            END FOR  \n            \n            SET the value associated with state in memo TO false  \n            RETURN false  \n        END FUNCTION  \n        \n        RETURN the result of calling can_win_helper WITH currentState  \n    END FUNCTION  \nEND CLASS\n\nThe following are cosmetic or modified pseudocodes of other reproducible versions of pseudocode that are reproducible but were labeled as not:\nCLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET maxIntValue AS (2 ^ 31) - 1  \n        SET minIntValue AS 0 - (2 ^ 31)  \n        SET accumulatedNumber TO 0  \n        SET position TO 0  \n        SET lengthOfString TO LENGTH OF s  \n        SET polarity TO 1  \n\n        WHILE position < lengthOfString AND s[position] = ' '  \n            position \u2190 position + 1  \n        END WHILE  \n\n        IF position < lengthOfString THEN  \n            SWITCH s[position]  \n                CASE '-'  \n                    polarity \u2190 0 - 1  \n                    position \u2190 position + 1  \n                    BREAK  \n                CASE '+'  \n                    polarity \u2190 1  \n                    position \u2190 position + 1  \n                    BREAK  \n            END SWITCH  \n        END IF  \n\n        REPEAT UNTIL NOT (position < lengthOfString AND s[position] >= '0' AND s[position] <= '9')  \n            SET currentChar TO s[position]  \n            SET numericValue TO INTEGER VALUE OF currentChar  \n            SET boundaryCheck TO maxIntValue - (numericValue DIV 10)  \n\n            IF accumulatedNumber > boundaryCheck THEN  \n                IF polarity = 1 THEN  \n                    RETURN maxIntValue  \n                ELSE  \n                    RETURN minIntValue  \n                END IF  \n            END IF  \n\n            accumulatedNumber \u2190 (accumulatedNumber * 10) + numericValue  \n            position \u2190 position + 1  \n        END REPEAT  \n\n        RETURN polarity * accumulatedNumber  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION multiply(num1 string num2 string) RETURNS string  \n        IF NOT (num1 NOT EQUALS string zero AND num2 NOT EQUALS string zero) THEN  \n            RETURN string zero  \n        END IF  \n\n        SET intermediateList TO new list  \n        SET lengthLimit TO (LENGTH OF num1) PLUS (LENGTH OF num2)  \n        FOR counter FROM zero UPTO lengthLimit MINUS one  \n            APPEND zero TO intermediateList  \n        END FOR   \n\n        SET reversedNum1 TO empty string  \n        SET indexA TO LENGTH OF num1 MINUS one  \n        WHILE indexA GREATER OR EQUAL TO zero DO  \n            SET reversedNum1 TO reversedNum1 PLUS CHARACTER AT indexA OF num1  \n            DECREMENT indexA BY one  \n        END WHILE  \n        SET num1 TO reversedNum1  \n\n        SET reversedNum2 TO empty string  \n        SET indexB TO LENGTH OF num2 MINUS one  \n        WHILE indexB GREATER OR EQUAL TO zero DO  \n            SET reversedNum2 TO reversedNum2 PLUS CHARACTER AT indexB OF num2  \n            DECREMENT indexB BY one  \n        END WHILE  \n        SET num2 TO reversedNum2  \n\n        SET posI TO zero  \n        WHILE posI LESS THAN LENGTH OF num1 DO  \n            SET posJ TO zero  \n            WHILE posJ LESS THAN LENGTH OF num2 DO  \n                SET codeA TO (CHARACTER CODE OF CHARACTER AT posI OF num1) MINUS (CHARACTER CODE OF string zero)  \n                SET codeB TO (CHARACTER CODE OF CHARACTER AT posJ OF num2) MINUS (CHARACTER CODE OF string zero)  \n                SET productVal TO codeA TIMES codeB  \n\n                SET positionOne TO posI PLUS posJ  \n                SET positionTwo TO positionOne PLUS one  \n\n                SET combinedSum TO productVal PLUS ELEMENT AT positionOne OF intermediateList  \n\n                SET ELEMENT AT positionOne OF intermediateList TO combinedSum MODULO ten  \n                SET ELEMENT AT positionTwo OF intermediateList TO ELEMENT AT positionTwo OF intermediateList PLUS (combinedSum DIVIDED BY ten)  \n                INCREMENT posJ BY one  \n            END WHILE  \n            INCREMENT posI BY one  \n        END WHILE  \n\n        SET reversedResultStr TO empty string  \n        SET revIndex TO LENGTH OF intermediateList MINUS one  \n        WHILE revIndex GREATER OR EQUAL TO zero DO  \n            SET reversedResultStr TO reversedResultStr PLUS STRING OF ELEMENT AT revIndex OF intermediateList  \n            DECREMENT revIndex BY one  \n        END WHILE  \n\n        SET startIndex TO zero  \n        WHILE startIndex LESS THAN LENGTH OF reversedResultStr AND CHARACTER AT startIndex OF reversedResultStr EQUALS string zero DO  \n            INCREMENT startIndex BY one  \n        END WHILE  \n\n        IF startIndex EQUALS LENGTH OF reversedResultStr THEN  \n            RETURN string zero  \n        END IF  \n\n        RETURN SUBSTRING OF reversedResultStr FROM startIndex TO LENGTH OF reversedResultStr MINUS one  \n    END FUNCTION  \nEND CLASS\n\nThe following are pseudocodes that are not reproducible but were labeled as reproducible:\n```\nSET INT_MAX = 2^31 - 1, INT_MIN = -2^31\nINIT res = 0, i = 0, n = len(s), sign = 1\nWHILE i < n AND s[i] = ' ' : i += 1\nIF i < n AND s[i] IN ['+', '-'] : sign = -1 IF s[i] = '-' ELSE 1; i += 1\nWHILE i < n AND s[i].isdigit():\n    d = int(s[i])\n    IF res > (INT_MAX - d)//10: RETURN INT_MAX IF sign = 1 ELSE INT_MIN\n    res = res*10 + d\n    i += 1\nRETURN sign * res\n```\n```\nif num1==\"0\" or num2==\"0\": return \"0\"\nres = [0]*(len(num1)+len(num2))\nn1, n2 = num1[::-1], num2[::-1]\nfor i in range(len(n1)):\n  for j in range(len(n2)):\n    mul = (ord(n1[i])-48)*(ord(n2[j])-48)\n    sum_ = mul + res[i+j]\n    res[i+j], res[i+j+1] = sum_%10, res[i+j+1]+sum_//10\nreturn ''.join(map(str,res[::-1])).lstrip('0')\n```\n\nThe following are near-miss pseudocodes - they are almost reproducible but were labeled as reproducible:\nCLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET INT_MAX TO two POWERED BY thirty ONE MINUS one  \n        SET INT_MIN TO negative two POWERED BY thirty ONE  \n        SET result TO zero  \n        SET index TO zero  \n        SET n TO the LENGTH OF s  \n        SET sign TO one  \n        WHILE index LESS THAN n AND character at position index OF s EQUALS a single whitespace character  \n            INCREMENT index BY one  \n        END WHILE  \n        IF index LESS THAN n AND (character at position index OF s EQUALS the plus sign OR character at position index OF s EQUALS the minus sign)  \n            IF character at position index OF s EQUALS the minus sign  \n                SET sign TO negative one  \n            ELSE  \n                SET sign TO one  \n            END IF  \n            INCREMENT index BY one  \n        END IF  \n        WHILE index LESS THAN n AND character at position index OF s IS A DIGIT  \n            SET digit TO the INTEGER VALUE OF character at position index OF s  \n            IF result GREATER THAN (INT_MAX MINUS digit) DIVIDED BY ten  \n                IF sign EQUALS one  \n                    RETURN INT_MAX  \n                ELSE  \n                    RETURN INT_MIN  \n                END IF  \n            END IF  \n            SET result TO result MULTIPLIED BY ten PLUS digit  \n            INCREMENT index BY one  \n        END WHILE  \n        RETURN sign MULTIPLIED BY result  \n    END FUNCTION  \nEND CLASS\nPassing rate for this pseudocode: 0.96875, but was given a label of 1\nCLASS Solution\n    FUNCTION multiply(num1 string, num2 string) RETURNS string\n        IF num1 IS \"0\" OR num2 IS \"0\"\n            RETURN \"0\"\n        END IF\n\n        DECLARE digits AS MAP from INT to INT\n        DECLARE lengthSum AS INT = LENGTH(num1) + LENGTH(num2)\n        FOR index IN RANGE(lengthSum)\n            digits[index] = 0\n        END FOR\n\n        DECLARE reversed1 AS string = \"\"\n        DECLARE reversed2 AS string = \"\"\n        FOR p FROM LENGTH(num1) - 1 DOWNTO 0\n            reversed1 = reversed1 + num1[p]\n        END FOR\n        FOR q FROM LENGTH(num2) - 1 DOWNTO 0\n            reversed2 = reversed2 + num2[q]\n        END FOR\n\n        DECLARE function recursiveMul(i INT, j INT) RETURNS VOID\n            IF i = LENGTH(reversed1)\n                RETURN\n            END IF\n            IF j = LENGTH(reversed2)\n                recursiveMul(i + 1, 0)\n                RETURN\n            END IF\n\n            DECLARE valA AS INT = ASCII_CODE(reversed1[i]) - ASCII_CODE(\"0\")\n            DECLARE valB AS INT = ASCII_CODE(reversed2[j]) - ASCII_CODE(\"0\")\n            DECLARE product AS INT = valA * valB\n            DECLARE baseIndex AS INT = i + j\n            DECLARE nextIndex AS INT = baseIndex + 1\n            DECLARE totalSum AS INT = product + digits[baseIndex]\n\n            digits[baseIndex] = totalSum MOD 10\n            digits[nextIndex] = digits[nextIndex] + (totalSum DIV 10)\n\n            recursiveMul(i, j + 1)\n        END FUNCTION\n\n        CALL recursiveMul(0, 0)\n\n        DECLARE output AS string = \"\"\n        FOR key FROM lengthSum - 1 DOWNTO 0\n            output = output + TO_STRING(digits[key])\n        END FOR\n\n        WHILE LENGTH(output) > 1 AND output[0] = \"0\"\n            output = SUBSTRING(output, 1)\n        END WHILE\n\n        RETURN output\n    END FUNCTION\nEND CLASS\nPassing rate for this pseudocode: 0.9666666666666667, but was given a label of 1\nCLASS Solution\n    FUNCTION isMatch(s, p)\n        SET x TO LENGTH(s)\n        SET y TO LENGTH(p)\n        SET dp TO []\n        SET u TO 0\n        WHILE u <= x\n            SET tempList TO []\n            SET v TO 0\n            WHILE v <= y\n                APPEND False TO tempList\n                SET v TO v + 1\n            END WHILE\n            APPEND tempList TO dp\n            SET u TO u + 1\n        END WHILE\n\n        SET dp[0][0] TO True\n\n        PROCEDURE fillFirstRow(w)\n            IF w > y THEN\n                RETURN\n            END IF\n            IF p[w - 1] = '*'\n                SET dp[0][w] TO dp[0][w - 1]\n            END IF\n            fillFirstRow(w + 1)\n        END PROCEDURE\n\n        CALL fillFirstRow(1)\n\n        PROCEDURE processRow(i, j)\n            IF i > x THEN\n                RETURN\n            END IF\n            IF j > y THEN\n                CALL processRow(i + 1, 1)\n                RETURN\n            END IF\n\n            SWITCH TRUE\n                CASE (p[j - 1] = '*')\n                    SET dp[i][j] TO dp[i - 1][j] OR dp[i][j - 1]\n                BREAK\n\n                CASE (p[j - 1] = '?' OR s[i - 1] = p[j - 1])\n                    SET dp[i][j] TO dp[i - 1][j - 1]\n                BREAK\n\n                DEFAULT\n                    // dp[i][j] remains False implicitly\n                BREAK\n            END SWITCH\n\n            processRow(i, j + 1)\n        END PROCEDURE\n\n        CALL processRow(1, 1)\n\n        RETURN dp[x][y]\n    END FUNCTION\nEND CLASS\nPassing rate for this pseudocode: 0.96, but was given a label of 1\nCLASS Solution\n    FUNCTION removeDuplicates(nums)\n        DECLARE counter \u2190 0\n        IF counter EQUALS LENGTH(nums) THEN\n            RETURN counter\n        ELSE\n            DECLARE definer \u2190 0\n            DECLARE temp_list \u2190 new Queue()\n            \n            WHILE definer < MIN(2, LENGTH(nums))\n                ENQUEUE(nums[definer], temp_list)\n                definer \u2190 definer + 1\n            END WHILE\n            \n            WHILE NOT IS_EMPTY(temp_list)\n                nums[counter] \u2190 DEQUEUE(temp_list)\n                counter \u2190 counter + 1\n            END WHILE\n            \n            FUNCTION recurse(pos)\n                IF pos EQUALS LENGTH(nums) THEN\n                    RETURN\n                END IF\n                IF nums[pos] \u2260 nums[counter - 2] THEN\n                    nums[counter] \u2190 nums[pos]\n                    counter \u2190 counter + 1\n                END IF\n                recurse(pos + 1)\n            END FUNCTION\n            \n            recurse(2)\n            \n            RETURN counter\n        END IF\n    END FUNCTION\nEND CLASS\nPassing rate for this pseudocode: 0.9743589743589743, but was given a label of 1\n\nAvg Score for all pseudocodes: 0.6233333333333333"
}