{
  "prompt": "Given one or more input pseudocode snippets, each purporting to be a full implementation solving a problem, produce a single output digit (`1` or `0`) for each snippet in the exact order given, concatenated into one continuous string with no delimiters or spaces.\n\nFor each pseudocode snippet, output `1` **if and only if** it is **fully and unconditionally reproducible**, meaning it will **pass all valid unit tests** for its problem without exceptions or failures. Output `0` otherwise.\n\nTo determine reproducibility, perform a rigorous and comprehensive internal logical analysis focusing solely on the snippet itself, ignoring comments, formatting, or external context. Evaluate the snippet against the following enhanced criteria:\n\n1. **Complete and explicit logic coverage:**  \n   - All input domains, edge cases, control paths, and branches are explicitly addressed.  \n   - No implicit assumptions, partial algorithms, or skipped steps exist.  \n   - All loops, recursions, and conditionals terminate correctly and handle boundary cases, including minimal, maximal, empty, or special inputs relevant to the problem.\n\n2. **Deterministic and unambiguous behavior:**  \n   - Every variable, function, and state update is precisely defined and free from ambiguity.  \n   - No nondeterministic or underspecified operations occur.  \n   - Results are consistent and correct across **every** valid input.\n\n3. **Self-contained completeness:**  \n   - The snippet explicitly declares, initializes, and updates all variables, functions, data structures, and helper procedures without reliance on hidden state, external libraries, or unstated prerequisites.  \n   - It must not depend on informal notation or implicit context.\n\n4. **Logical correctness aligned with intended semantics:**  \n   - The implementation corresponds exactly to a sound algorithmic approach sufficient to solve the problem fully.  \n   - Partial outlines, unverified heuristics, or logically flawed steps invalidate reproducibility.\n\n5. **Robustness in error, boundary, and edge condition handling:**  \n   - Handles empty, zero, null, maximum, minimum, overflow, underflow, and other corner cases rigorously and explicitly.  \n   - No gaps or undefined behaviors remain for any plausible input.\n\n6. **Consistent control and data flow integrity:**  \n   - Variables and states change according to valid conditions ensuring correctness and guaranteed termination or well-defined completion.  \n   - No infinite loops without base cases or recursive cycles without exit conditions.\n\n7. **Algorithmic faithfulness:**  \n   - When the algorithm implemented is recognizable (e.g., classic sorting, DP, recursion schemes), the pseudocode faithfully replicates the complete logical structure and correctness of that algorithm, not just a high-level sketch.\n\nApply these criteria methodically, step-by-step, analyzing only the provided pseudocode snippet(s). Disregard stylistic variations, comments, or superficial formatting differences.\n\n**Output instructions:**  \n- For each provided snippet in input order, output `1` if it meets **all** the above criteria and will pass all valid unit tests unconditionally.  \n- Output `0` if it fails even one criterion, indicating incompleteness, ambiguity, or likely failure on some tests.\n\n**Final output:** a compact, contiguous string of digits composed solely of `1`s and `0`s, with no spaces, line breaks, punctuation, explanation, or additional characters.\n\n**Strictness and performance:**  \n- Prioritize logical rigor, precision, and correctness above all else.  \n- Timeout is 5 seconds per evaluation batch.  \n- No extraneous output permitted.\n\nThis prompt replaces heuristic or partial judgments with a strict, logically grounded, reproducibility verification suitable for diverse problems and pseudocode styles, aimed at maximizing accuracy and minimizing false positives or negatives.",
  "response": "Given one or more input pseudocode snippets, each purporting to be a full implementation solving a problem, produce a single output digit (`1` or `0`) for each snippet in the exact order given, concatenated into one continuous string with no delimiters or spaces.\n\nFor each pseudocode snippet, output `1` **if and only if** it is **fully and unconditionally reproducible**, meaning it will **pass all valid unit tests** for its problem without exceptions or failures. Output `0` otherwise.\n\nTo determine reproducibility, perform a rigorous and comprehensive internal logical analysis focusing solely on the snippet itself, ignoring comments, formatting, or external context. Evaluate the snippet against the following enhanced criteria:\n\n1. **Complete and explicit logic coverage:**  \n   - All input domains, edge cases, control paths, and branches are explicitly addressed.  \n   - No implicit assumptions, partial algorithms, or skipped steps exist.  \n   - All loops, recursions, and conditionals terminate correctly and handle boundary cases, including minimal, maximal, empty, or special inputs relevant to the problem.\n\n2. **Deterministic and unambiguous behavior:**  \n   - Every variable, function, and state update is precisely defined and free from ambiguity.  \n   - No nondeterministic or underspecified operations occur.  \n   - Results are consistent and correct across **every** valid input.\n\n3. **Self-contained completeness:**  \n   - The snippet explicitly declares, initializes, and updates all variables, functions, data structures, and helper procedures without reliance on hidden state, external libraries, or unstated prerequisites.  \n   - It must not depend on informal notation or implicit context.\n\n4. **Logical correctness aligned with intended semantics:**  \n   - The implementation corresponds exactly to a sound algorithmic approach sufficient to solve the problem fully.  \n   - Partial outlines, unverified heuristics, or logically flawed steps invalidate reproducibility.\n\n5. **Robustness in error, boundary, and edge condition handling:**  \n   - Handles empty, zero, null, maximum, minimum, overflow, underflow, and other corner cases rigorously and explicitly.  \n   - No gaps or undefined behaviors remain for any plausible input.\n\n6. **Consistent control and data flow integrity:**  \n   - Variables and states change according to valid conditions ensuring correctness and guaranteed termination or well-defined completion.  \n   - No infinite loops without base cases or recursive cycles without exit conditions.\n\n7. **Algorithmic faithfulness:**  \n   - When the algorithm implemented is recognizable (e.g., classic sorting, DP, recursion schemes), the pseudocode faithfully replicates the complete logical structure and correctness of that algorithm, not just a high-level sketch.\n\nApply these criteria methodically, step-by-step, analyzing only the provided pseudocode snippet(s). Disregard stylistic variations, comments, or superficial formatting differences.\n\n**Output instructions:**  \n- For each provided snippet in input order, output `1` if it meets **all** the above criteria and will pass all valid unit tests unconditionally.  \n- Output `0` if it fails even one criterion, indicating incompleteness, ambiguity, or likely failure on some tests.\n\n**Final output:** a compact, contiguous string of digits composed solely of `1`s and `0`s, with no spaces, line breaks, punctuation, explanation, or additional characters.\n\n**Strictness and performance:**  \n- Prioritize logical rigor, precision, and correctness above all else.  \n- Timeout is 5 seconds per evaluation batch.  \n- No extraneous output permitted.\n\nThis prompt replaces heuristic or partial judgments with a strict, logically grounded, reproducibility verification suitable for diverse problems and pseudocode styles, aimed at maximizing accuracy and minimizing false positives or negatives.",
  "score": 0.5766666666666667,
  "feedback": "The following are pseudocodes that are reproducible but were labeled as not:\nCLASS Solution  \n    FUNCTION longestPalindrome(s)  \n        SET n TO the LENGTH OF s  \n        SET f TO a TWO DIMENSIONAL LIST of BOOLEAN TRUES with n ROWS and n COLUMNS  \n        SET k TO zero  \n        SET mx TO one  \n        FOR i FROM n MINUS two DOWN TO zero  \n            FOR j FROM i PLUS one TO n MINUS one  \n                SET element at position i and position j of f TO FALSE  \n                IF element at position i of s EQUALS element at position j of s  \n                    SET element at position i and position j of f TO element at position i PLUS one and position j MINUS one of f  \n                    IF element at position i and position j of f EQUALS TRUE AND mx LESS THAN j MINUS i PLUS one  \n                        SET k TO i  \n                        SET mx TO j MINUS i PLUS one  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN substring from position k TO position k PLUS mx MINUS one of s  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION canWin(currentState)  \n        SET memo TO an empty dictionary  \n        \n        FUNCTION can_win_helper(state)  \n            IF state EXISTS IN memo THEN  \n                RETURN the value associated with state in memo  \n            END IF  \n            \n            FOR index FROM zero TO the LENGTH OF state MINUS one MINUS one  \n                IF the element at position index of state EQUALS the plus character AND the element at position index PLUS one of state EQUALS the plus character THEN  \n                    SET new_state TO the substring from position zero TO position index MINUS one CONCATENATED WITH two minus characters CONCATENATED WITH the substring from position index PLUS two TO the END OF state  \n                    IF the result of calling can_win_helper WITH new_state IS EQUAL TO false THEN  \n                        SET the value associated with state in memo TO true  \n                        RETURN true  \n                    END IF  \n                END IF  \n            END FOR  \n            \n            SET the value associated with state in memo TO false  \n            RETURN false  \n        END FUNCTION  \n        \n        RETURN the result of calling can_win_helper WITH currentState  \n    END FUNCTION  \nEND CLASS\n\nThe following are cosmetic or modified pseudocodes of other reproducible versions of pseudocode that are reproducible but were labeled as not:\nCLASS Solution\n    FUNCTION longestPalindrome(s)\n        SET length AS THE COUNT OF s\n        SET truth_matrix AS AN ARRAY (length) OF ARRAYS (length) FILLED WITH TRUE\n        SET start_index AS 0\n        SET max_length AS 1\n        \n        SET outer_index AS length MINUS 2\n        WHILE outer_index IS GREATER THAN OR EQUAL TO 0 DO\n            SET inner_index AS outer_index PLUS 1\n            WHILE inner_index IS LESS THAN length DO\n                SET truth_matrix[outer_index][inner_index] AS FALSE\n                \n                IF NOT (s[outer_index] NOT EQUAL TO s[inner_index]) THEN\n                    SET truth_matrix[outer_index][inner_index] AS truth_matrix[outer_index PLUS 1][inner_index MINUS 1]\n                    \n                    IF truth_matrix[outer_index][inner_index] IS TRUE THEN\n                        IF (max_length LESS THAN (inner_index MINUS outer_index PLUS 1)) THEN\n                            SET start_index AS outer_index\n                            SET max_length AS (inner_index MINUS outer_index PLUS 1)\n                        END IF\n                    END IF\n                END IF\n                INCREMENT inner_index BY 1\n            END WHILE\n            DECREMENT outer_index BY 1\n        END WHILE\n        \n        RETURN s SUBSTRING FROM start_index TO (start_index PLUS max_length MINUS 1)\n    END FUNCTION\nEND CLASS\nCLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET maxIntValue AS (2 ^ 31) - 1  \n        SET minIntValue AS 0 - (2 ^ 31)  \n        SET accumulatedNumber TO 0  \n        SET position TO 0  \n        SET lengthOfString TO LENGTH OF s  \n        SET polarity TO 1  \n\n        WHILE position < lengthOfString AND s[position] = ' '  \n            position \u2190 position + 1  \n        END WHILE  \n\n        IF position < lengthOfString THEN  \n            SWITCH s[position]  \n                CASE '-'  \n                    polarity \u2190 0 - 1  \n                    position \u2190 position + 1  \n                    BREAK  \n                CASE '+'  \n                    polarity \u2190 1  \n                    position \u2190 position + 1  \n                    BREAK  \n            END SWITCH  \n        END IF  \n\n        REPEAT UNTIL NOT (position < lengthOfString AND s[position] >= '0' AND s[position] <= '9')  \n            SET currentChar TO s[position]  \n            SET numericValue TO INTEGER VALUE OF currentChar  \n            SET boundaryCheck TO maxIntValue - (numericValue DIV 10)  \n\n            IF accumulatedNumber > boundaryCheck THEN  \n                IF polarity = 1 THEN  \n                    RETURN maxIntValue  \n                ELSE  \n                    RETURN minIntValue  \n                END IF  \n            END IF  \n\n            accumulatedNumber \u2190 (accumulatedNumber * 10) + numericValue  \n            position \u2190 position + 1  \n        END REPEAT  \n\n        RETURN polarity * accumulatedNumber  \n    END FUNCTION  \nEND CLASS\n\nThe following are pseudocodes that are not reproducible but were labeled as reproducible:\n```\nSET INT_MAX = 2^31 - 1, INT_MIN = -2^31\nINIT res = 0, i = 0, n = len(s), sign = 1\nWHILE i < n AND s[i] = ' ' : i += 1\nIF i < n AND s[i] IN ['+', '-'] : sign = -1 IF s[i] = '-' ELSE 1; i += 1\nWHILE i < n AND s[i].isdigit():\n    d = int(s[i])\n    IF res > (INT_MAX - d)//10: RETURN INT_MAX IF sign = 1 ELSE INT_MIN\n    res = res*10 + d\n    i += 1\nRETURN sign * res\n```\n```\nif num1==\"0\" or num2==\"0\": return \"0\"\nres = [0]*(len(num1)+len(num2))\nn1, n2 = num1[::-1], num2[::-1]\nfor i in range(len(n1)):\n  for j in range(len(n2)):\n    mul = (ord(n1[i])-48)*(ord(n2[j])-48)\n    sum_ = mul + res[i+j]\n    res[i+j], res[i+j+1] = sum_%10, res[i+j+1]+sum_//10\nreturn ''.join(map(str,res[::-1])).lstrip('0')\n```\n\nThe following are near-miss pseudocodes - they are almost reproducible but were labeled as reproducible:\nCLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET INT_MAX TO two POWERED BY thirty ONE MINUS one  \n        SET INT_MIN TO negative two POWERED BY thirty ONE  \n        SET result TO zero  \n        SET index TO zero  \n        SET n TO the LENGTH OF s  \n        SET sign TO one  \n        WHILE index LESS THAN n AND character at position index OF s EQUALS a single whitespace character  \n            INCREMENT index BY one  \n        END WHILE  \n        IF index LESS THAN n AND (character at position index OF s EQUALS the plus sign OR character at position index OF s EQUALS the minus sign)  \n            IF character at position index OF s EQUALS the minus sign  \n                SET sign TO negative one  \n            ELSE  \n                SET sign TO one  \n            END IF  \n            INCREMENT index BY one  \n        END IF  \n        WHILE index LESS THAN n AND character at position index OF s IS A DIGIT  \n            SET digit TO the INTEGER VALUE OF character at position index OF s  \n            IF result GREATER THAN (INT_MAX MINUS digit) DIVIDED BY ten  \n                IF sign EQUALS one  \n                    RETURN INT_MAX  \n                ELSE  \n                    RETURN INT_MIN  \n                END IF  \n            END IF  \n            SET result TO result MULTIPLIED BY ten PLUS digit  \n            INCREMENT index BY one  \n        END WHILE  \n        RETURN sign MULTIPLIED BY result  \n    END FUNCTION  \nEND CLASS\nPassing rate for this pseudocode: 0.96875, but was given a label of 1\nCLASS Solution\n    FUNCTION multiply(num1 string, num2 string) RETURNS string\n        IF num1 IS \"0\" OR num2 IS \"0\"\n            RETURN \"0\"\n        END IF\n\n        DECLARE digits AS MAP from INT to INT\n        DECLARE lengthSum AS INT = LENGTH(num1) + LENGTH(num2)\n        FOR index IN RANGE(lengthSum)\n            digits[index] = 0\n        END FOR\n\n        DECLARE reversed1 AS string = \"\"\n        DECLARE reversed2 AS string = \"\"\n        FOR p FROM LENGTH(num1) - 1 DOWNTO 0\n            reversed1 = reversed1 + num1[p]\n        END FOR\n        FOR q FROM LENGTH(num2) - 1 DOWNTO 0\n            reversed2 = reversed2 + num2[q]\n        END FOR\n\n        DECLARE function recursiveMul(i INT, j INT) RETURNS VOID\n            IF i = LENGTH(reversed1)\n                RETURN\n            END IF\n            IF j = LENGTH(reversed2)\n                recursiveMul(i + 1, 0)\n                RETURN\n            END IF\n\n            DECLARE valA AS INT = ASCII_CODE(reversed1[i]) - ASCII_CODE(\"0\")\n            DECLARE valB AS INT = ASCII_CODE(reversed2[j]) - ASCII_CODE(\"0\")\n            DECLARE product AS INT = valA * valB\n            DECLARE baseIndex AS INT = i + j\n            DECLARE nextIndex AS INT = baseIndex + 1\n            DECLARE totalSum AS INT = product + digits[baseIndex]\n\n            digits[baseIndex] = totalSum MOD 10\n            digits[nextIndex] = digits[nextIndex] + (totalSum DIV 10)\n\n            recursiveMul(i, j + 1)\n        END FUNCTION\n\n        CALL recursiveMul(0, 0)\n\n        DECLARE output AS string = \"\"\n        FOR key FROM lengthSum - 1 DOWNTO 0\n            output = output + TO_STRING(digits[key])\n        END FOR\n\n        WHILE LENGTH(output) > 1 AND output[0] = \"0\"\n            output = SUBSTRING(output, 1)\n        END WHILE\n\n        RETURN output\n    END FUNCTION\nEND CLASS\nPassing rate for this pseudocode: 0.9666666666666667, but was given a label of 1\nCLASS Solution\n    FUNCTION isMatch(s, p)\n        SET x TO LENGTH(s)\n        SET y TO LENGTH(p)\n        SET dp TO []\n        SET u TO 0\n        WHILE u <= x\n            SET tempList TO []\n            SET v TO 0\n            WHILE v <= y\n                APPEND False TO tempList\n                SET v TO v + 1\n            END WHILE\n            APPEND tempList TO dp\n            SET u TO u + 1\n        END WHILE\n\n        SET dp[0][0] TO True\n\n        PROCEDURE fillFirstRow(w)\n            IF w > y THEN\n                RETURN\n            END IF\n            IF p[w - 1] = '*'\n                SET dp[0][w] TO dp[0][w - 1]\n            END IF\n            fillFirstRow(w + 1)\n        END PROCEDURE\n\n        CALL fillFirstRow(1)\n\n        PROCEDURE processRow(i, j)\n            IF i > x THEN\n                RETURN\n            END IF\n            IF j > y THEN\n                CALL processRow(i + 1, 1)\n                RETURN\n            END IF\n\n            SWITCH TRUE\n                CASE (p[j - 1] = '*')\n                    SET dp[i][j] TO dp[i - 1][j] OR dp[i][j - 1]\n                BREAK\n\n                CASE (p[j - 1] = '?' OR s[i - 1] = p[j - 1])\n                    SET dp[i][j] TO dp[i - 1][j - 1]\n                BREAK\n\n                DEFAULT\n                    // dp[i][j] remains False implicitly\n                BREAK\n            END SWITCH\n\n            processRow(i, j + 1)\n        END PROCEDURE\n\n        CALL processRow(1, 1)\n\n        RETURN dp[x][y]\n    END FUNCTION\nEND CLASS\nPassing rate for this pseudocode: 0.96, but was given a label of 1\nCLASS Solution\n    FUNCTION combine WITH PARAMETERS n k\n        SET outcome TO []\n        FUNCTION backtrack WITH PARAMETERS pos seq\n            WHILE pos NOT EQUAL TO n + 1\n                APPEND pos TO seq\n                IF LENGTH seq EQUALS k THEN\n                    APPEND COPY OF seq TO outcome\n                ELSE\n                    CALL backtrack WITH ARGUMENTS pos + 1 seq\n                END IF\n                REMOVE LAST ITEM FROM seq\n                SET pos TO pos + 1\n            END WHILE\n        END FUNCTION\n        CALL backtrack WITH ARGUMENTS 1 []\n        RETURN outcome\n    END FUNCTION\nEND CLASS\nPassing rate for this pseudocode: 0.8823529411764706, but was given a label of 1\n\nAvg Score for all pseudocodes: 0.5766666666666667"
}