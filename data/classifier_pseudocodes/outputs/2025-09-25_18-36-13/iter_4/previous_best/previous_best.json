{
  "prompt": "Given an input pseudocode snippet representing a complete solution implementation, determine if it **unconditionally** passes all valid unit tests for its problem by verifying whether it is fully reproducible. Base your judgment strictly on internal logic and completeness, ignoring any extraneous context or information outside the pseudocode itself.\n\nTo decide reproducibility (output `1`) versus non-reproducibility (output `0`), use these strict, comprehensive criteria:  \n  \n1. **Explicit completeness:** The pseudocode must cover all necessary computations, control paths (including edge cases and boundary conditions), and termination conditions without missing scenarios or shortcuts.  \n  \n2. **Deterministic correctness:** All operations, decisions, updates, and returns must be unambiguous, deterministic, and clearly defined to produce the correct output for any valid input within the problem domain.  \n  \n3. **Self-contained definitions:** All variables, functions, data structures, and procedures must be explicitly initialized, updated, and utilized with stated logic, free from reliance on implicit assumptions, hidden states, or unstated prerequisites.  \n  \n4. **No partial or informal logic:** Avoid accepting partial, sketchy, symbolic, or vaguely specified logic that could cause inconsistent or incorrect outputs under some test conditions.  \n  \n5. **Consistent data flow and control flow:** Every variable modification, loop control, recursion, and return path must be logically consistent and enabled by valid conditions ensuring termination and correctness.  \n  \n6. **Precision in edge case handling:** The pseudocode must explicitly handle empty inputs, zero cases, overflow/underflow scenarios, or other special inputs relevant to the problem without ambiguity or omission.  \n  \n7. **Faithful translation:** When the pseudocode implies a known algorithm, it must reflect a logically sound and complete implementation, not just a partial conceptual outline.  \n  \nPerform a meticulous, stepwise logical analysis on the given pseudocode *only*, verifying all above points. Ignore irrelevant comments, syntactic variations, or low-level formatting.  \n  \nAfter analysis of each pseudocode snippet in the provided order, output only a concatenated string of digits:  \n- `1` if the pseudocode snippet meets **all** reproducibility criteria and will pass all valid tests.  \n- `0` if it fails any of the criteria, implying it is incomplete, ambiguous, incorrect, or likely to fail some tests.  \n  \n**Output format:** a single contiguous string of `1`s and `0`s representing the reproducibility assessment in exact order of input pseudocodes, with no spaces, newlines, comments, explanations, or extra characters.  \n  \nYour response must be strictly binary, concise, and maximally accurate, prioritizing correctness and logical rigor within the 5-second evaluation limit.",
  "response": "Given an input pseudocode snippet representing a complete solution implementation, determine if it **unconditionally** passes all valid unit tests for its problem by verifying whether it is fully reproducible. Base your judgment strictly on internal logic and completeness, ignoring any extraneous context or information outside the pseudocode itself.\n\nTo decide reproducibility (output `1`) versus non-reproducibility (output `0`), use these strict, comprehensive criteria:  \n  \n1. **Explicit completeness:** The pseudocode must cover all necessary computations, control paths (including edge cases and boundary conditions), and termination conditions without missing scenarios or shortcuts.  \n  \n2. **Deterministic correctness:** All operations, decisions, updates, and returns must be unambiguous, deterministic, and clearly defined to produce the correct output for any valid input within the problem domain.  \n  \n3. **Self-contained definitions:** All variables, functions, data structures, and procedures must be explicitly initialized, updated, and utilized with stated logic, free from reliance on implicit assumptions, hidden states, or unstated prerequisites.  \n  \n4. **No partial or informal logic:** Avoid accepting partial, sketchy, symbolic, or vaguely specified logic that could cause inconsistent or incorrect outputs under some test conditions.  \n  \n5. **Consistent data flow and control flow:** Every variable modification, loop control, recursion, and return path must be logically consistent and enabled by valid conditions ensuring termination and correctness.  \n  \n6. **Precision in edge case handling:** The pseudocode must explicitly handle empty inputs, zero cases, overflow/underflow scenarios, or other special inputs relevant to the problem without ambiguity or omission.  \n  \n7. **Faithful translation:** When the pseudocode implies a known algorithm, it must reflect a logically sound and complete implementation, not just a partial conceptual outline.  \n  \nPerform a meticulous, stepwise logical analysis on the given pseudocode *only*, verifying all above points. Ignore irrelevant comments, syntactic variations, or low-level formatting.  \n  \nAfter analysis of each pseudocode snippet in the provided order, output only a concatenated string of digits:  \n- `1` if the pseudocode snippet meets **all** reproducibility criteria and will pass all valid tests.  \n- `0` if it fails any of the criteria, implying it is incomplete, ambiguous, incorrect, or likely to fail some tests.  \n  \n**Output format:** a single contiguous string of `1`s and `0`s representing the reproducibility assessment in exact order of input pseudocodes, with no spaces, newlines, comments, explanations, or extra characters.  \n  \nYour response must be strictly binary, concise, and maximally accurate, prioritizing correctness and logical rigor within the 5-second evaluation limit.",
  "score": 0.5766666666666667,
  "feedback": "The following are pseudocodes that are reproducible but were labeled as not:\nCLASS Solution  \n    FUNCTION canWin(currentState)  \n        SET memo TO an empty dictionary  \n        \n        FUNCTION can_win_helper(state)  \n            IF state EXISTS IN memo THEN  \n                RETURN the value associated with state in memo  \n            END IF  \n            \n            FOR index FROM zero TO the LENGTH OF state MINUS one MINUS one  \n                IF the element at position index of state EQUALS the plus character AND the element at position index PLUS one of state EQUALS the plus character THEN  \n                    SET new_state TO the substring from position zero TO position index MINUS one CONCATENATED WITH two minus characters CONCATENATED WITH the substring from position index PLUS two TO the END OF state  \n                    IF the result of calling can_win_helper WITH new_state IS EQUAL TO false THEN  \n                        SET the value associated with state in memo TO true  \n                        RETURN true  \n                    END IF  \n                END IF  \n            END FOR  \n            \n            SET the value associated with state in memo TO false  \n            RETURN false  \n        END FUNCTION  \n        \n        RETURN the result of calling can_win_helper WITH currentState  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION canCross(stones)  \n        IF stones EQUALS empty OR the LENGTH OF stones LESS THAN two  \n            RETURN False  \n        END IF  \n        SET stone_set TO the SET of all elements in stones  \n        SET memo TO an EMPTY DICTIONARY  \n\n        FUNCTION can_jump_to(position, jump)  \n            IF position EQUALS the element at the last position of stones  \n                RETURN True  \n            END IF  \n            IF the TUPLE of position AND jump IS IN memo  \n                RETURN the VALUE associated with the TUPLE of position AND jump in memo  \n            END IF  \n            FOR next_jump FROM jump MINUS one TO jump PLUS one  \n                IF next_jump GREATER THAN zero AND the SUM of position AND next_jump IS IN stone_set  \n                    IF can_jump_to(the SUM of position AND next_jump, next_jump)  \n                        SET memo at key TUPLE of position AND jump TO True  \n                        RETURN True  \n                    END IF  \n                END IF  \n            END FOR  \n            SET memo at key TUPLE of position AND jump TO False  \n            RETURN False  \n        END FUNCTION  \n\n        RETURN can_jump_to(the element at the first position of stones, zero)  \n    END FUNCTION  \nEND CLASS\n\nThe following are cosmetic or modified pseudocodes of other reproducible versions of pseudocode that are reproducible but were labeled as not:\nCLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET maxIntValue AS (2 ^ 31) - 1  \n        SET minIntValue AS 0 - (2 ^ 31)  \n        SET accumulatedNumber TO 0  \n        SET position TO 0  \n        SET lengthOfString TO LENGTH OF s  \n        SET polarity TO 1  \n\n        WHILE position < lengthOfString AND s[position] = ' '  \n            position \u2190 position + 1  \n        END WHILE  \n\n        IF position < lengthOfString THEN  \n            SWITCH s[position]  \n                CASE '-'  \n                    polarity \u2190 0 - 1  \n                    position \u2190 position + 1  \n                    BREAK  \n                CASE '+'  \n                    polarity \u2190 1  \n                    position \u2190 position + 1  \n                    BREAK  \n            END SWITCH  \n        END IF  \n\n        REPEAT UNTIL NOT (position < lengthOfString AND s[position] >= '0' AND s[position] <= '9')  \n            SET currentChar TO s[position]  \n            SET numericValue TO INTEGER VALUE OF currentChar  \n            SET boundaryCheck TO maxIntValue - (numericValue DIV 10)  \n\n            IF accumulatedNumber > boundaryCheck THEN  \n                IF polarity = 1 THEN  \n                    RETURN maxIntValue  \n                ELSE  \n                    RETURN minIntValue  \n                END IF  \n            END IF  \n\n            accumulatedNumber \u2190 (accumulatedNumber * 10) + numericValue  \n            position \u2190 position + 1  \n        END REPEAT  \n\n        RETURN polarity * accumulatedNumber  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION isRectangleCover(rectangles)  \n        LET minX BE positive infinity  \n        LET minY BE positive infinity  \n        LET maxX BE negative infinity  \n        LET maxY BE negative infinity  \n        \n        INITIALIZE corners AS empty set  \n        DEFINE totalArea AS 0  \n        \n        DEFINE idx AS 0  \n        WHILE idx LESS THAN LENGTH OF rectangles DO  \n            LET rect BE rectangles[idx]  \n            LET leftX BE rect[0]  \n            LET bottomY BE rect[1]  \n            LET rightX BE rect[2]  \n            LET topY BE rect[3]  \n            \n            IF NOT (leftX >= minX) THEN  \n                minX \u2190 leftX  \n            END IF  \n            IF NOT (bottomY >= minY) THEN  \n                minY \u2190 bottomY  \n            END IF  \n            IF NOT (rightX <= maxX) THEN  \n                maxX \u2190 rightX  \n            END IF  \n            IF NOT (topY <= maxY) THEN  \n                maxY \u2190 topY  \n            END IF  \n            \n            LET rectArea BE (rightX - leftX)  \n            LET height BE (topY - bottomY)  \n            LET thisArea BE rectArea * height  \n            totalArea \u2190 totalArea + thisArea  \n            \n            LET cornerPoints BE list of pairs: (leftX, bottomY), (leftX, topY), (rightX, bottomY), (rightX, topY)  \n            \n            LET ctr AS 0  \n            WHILE ctr LESS THAN LENGTH OF cornerPoints DO  \n                LET corner BE cornerPoints[ctr]  \n                IF corners CONTAINS corner THEN  \n                    REMOVE corner FROM corners  \n                ELSE  \n                    INSERT corner INTO corners  \n                END IF  \n                ctr \u2190 ctr + 1  \n            END WHILE  \n            idx \u2190 idx + 1  \n        END WHILE  \n        \n        LET fullWidth BE maxX - minX  \n        LET fullHeight BE maxY - minY  \n        LET expectedArea BE fullWidth * fullHeight  \n        \n        IF totalArea IS NOT expectedArea THEN  \n            RETURN False  \n        END IF  \n        \n        LET requiredCorners BE set of pairs: (minX, minY), (minX, maxY), (maxX, minY), (maxX, maxY)  \n        IF corners IS NOT EQUAL TO requiredCorners THEN  \n            RETURN False  \n        END IF  \n        \n        RETURN True  \n    END FUNCTION  \nEND CLASS\n\nThe following are pseudocodes that are not reproducible but were labeled as reproducible:\nCLASS Solution\n    FUNCTION longestPalindrome(string_s)\n        SET length_n TO the LENGTH OF string_s\n        SET matrix_f TO auxiliary FUNCTION create_boolean_matrix WITH parameters length_n AND initial_value true\n        SET variable_k TO zero\n        SET variable_mx TO one\n        FOR index_i FROM length_n MINUS two TO zero STEP minus one\n            FOR index_j FROM index_i PLUS one TO length_n MINUS one\n                SET element at position index_i AND index_j of matrix_f TO false\n                IF element at position index_i of string_s EQUALS element at position index_j of string_s\n                    SET element at position index_i AND index_j of matrix_f TO element at position index_i PLUS one AND index_j MINUS one of matrix_f\n                    IF element at position index_i AND index_j of matrix_f AND variable_mx LESS THAN index_j MINUS index_i PLUS one\n                        SET variable_k TO index_i\n                        SET variable_mx TO index_j MINUS index_i PLUS one\n                    END IF\n                END IF\n            END FOR\n        END FOR\n        RETURN substring from position variable_k TO variable_k PLUS variable_mx MINUS one of string_s\n    END FUNCTION\nEND CLASS\n```\nSET INT_MAX = 2^31 - 1, INT_MIN = -2^31\nINIT res = 0, i = 0, n = len(s), sign = 1\nWHILE i < n AND s[i] = ' ' : i += 1\nIF i < n AND s[i] IN ['+', '-'] : sign = -1 IF s[i] = '-' ELSE 1; i += 1\nWHILE i < n AND s[i].isdigit():\n    d = int(s[i])\n    IF res > (INT_MAX - d)//10: RETURN INT_MAX IF sign = 1 ELSE INT_MIN\n    res = res*10 + d\n    i += 1\nRETURN sign * res\n```\n\nThe following are near-miss pseudocodes - they are almost reproducible but were labeled as reproducible:\nCLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET INT_MAX TO two POWERED BY thirty ONE MINUS one  \n        SET INT_MIN TO negative two POWERED BY thirty ONE  \n        SET result TO zero  \n        SET index TO zero  \n        SET n TO the LENGTH OF s  \n        SET sign TO one  \n        WHILE index LESS THAN n AND character at position index OF s EQUALS a single whitespace character  \n            INCREMENT index BY one  \n        END WHILE  \n        IF index LESS THAN n AND (character at position index OF s EQUALS the plus sign OR character at position index OF s EQUALS the minus sign)  \n            IF character at position index OF s EQUALS the minus sign  \n                SET sign TO negative one  \n            ELSE  \n                SET sign TO one  \n            END IF  \n            INCREMENT index BY one  \n        END IF  \n        WHILE index LESS THAN n AND character at position index OF s IS A DIGIT  \n            SET digit TO the INTEGER VALUE OF character at position index OF s  \n            IF result GREATER THAN (INT_MAX MINUS digit) DIVIDED BY ten  \n                IF sign EQUALS one  \n                    RETURN INT_MAX  \n                ELSE  \n                    RETURN INT_MIN  \n                END IF  \n            END IF  \n            SET result TO result MULTIPLIED BY ten PLUS digit  \n            INCREMENT index BY one  \n        END WHILE  \n        RETURN sign MULTIPLIED BY result  \n    END FUNCTION  \nEND CLASS\nPassing rate for this pseudocode: 0.96875, but was given a label of 1\nCLASS Solution\n    FUNCTION multiply(num1 string, num2 string) RETURNS string\n        IF num1 IS \"0\" OR num2 IS \"0\"\n            RETURN \"0\"\n        END IF\n\n        DECLARE digits AS MAP from INT to INT\n        DECLARE lengthSum AS INT = LENGTH(num1) + LENGTH(num2)\n        FOR index IN RANGE(lengthSum)\n            digits[index] = 0\n        END FOR\n\n        DECLARE reversed1 AS string = \"\"\n        DECLARE reversed2 AS string = \"\"\n        FOR p FROM LENGTH(num1) - 1 DOWNTO 0\n            reversed1 = reversed1 + num1[p]\n        END FOR\n        FOR q FROM LENGTH(num2) - 1 DOWNTO 0\n            reversed2 = reversed2 + num2[q]\n        END FOR\n\n        DECLARE function recursiveMul(i INT, j INT) RETURNS VOID\n            IF i = LENGTH(reversed1)\n                RETURN\n            END IF\n            IF j = LENGTH(reversed2)\n                recursiveMul(i + 1, 0)\n                RETURN\n            END IF\n\n            DECLARE valA AS INT = ASCII_CODE(reversed1[i]) - ASCII_CODE(\"0\")\n            DECLARE valB AS INT = ASCII_CODE(reversed2[j]) - ASCII_CODE(\"0\")\n            DECLARE product AS INT = valA * valB\n            DECLARE baseIndex AS INT = i + j\n            DECLARE nextIndex AS INT = baseIndex + 1\n            DECLARE totalSum AS INT = product + digits[baseIndex]\n\n            digits[baseIndex] = totalSum MOD 10\n            digits[nextIndex] = digits[nextIndex] + (totalSum DIV 10)\n\n            recursiveMul(i, j + 1)\n        END FUNCTION\n\n        CALL recursiveMul(0, 0)\n\n        DECLARE output AS string = \"\"\n        FOR key FROM lengthSum - 1 DOWNTO 0\n            output = output + TO_STRING(digits[key])\n        END FOR\n\n        WHILE LENGTH(output) > 1 AND output[0] = \"0\"\n            output = SUBSTRING(output, 1)\n        END WHILE\n\n        RETURN output\n    END FUNCTION\nEND CLASS\nPassing rate for this pseudocode: 0.9666666666666667, but was given a label of 1\nCLASS Solution\n    FUNCTION combine WITH PARAMETERS n k\n        SET outcome TO []\n        FUNCTION backtrack WITH PARAMETERS pos seq\n            WHILE pos NOT EQUAL TO n + 1\n                APPEND pos TO seq\n                IF LENGTH seq EQUALS k THEN\n                    APPEND COPY OF seq TO outcome\n                ELSE\n                    CALL backtrack WITH ARGUMENTS pos + 1 seq\n                END IF\n                REMOVE LAST ITEM FROM seq\n                SET pos TO pos + 1\n            END WHILE\n        END FUNCTION\n        CALL backtrack WITH ARGUMENTS 1 []\n        RETURN outcome\n    END FUNCTION\nEND CLASS\nPassing rate for this pseudocode: 0.8823529411764706, but was given a label of 1\nCLASS Solution  \n    FUNCTION grayCode(n)  \n        IF n IS 0 THEN  \n            RETURN [0]  \n        END IF  \n        \n        ASSIGN resultList TO grayCode(n - 1)  \n        LET bitFlag BE 2 ^ (n - 1) * 1  \n        \n        DEFINE FUNCTION reverseList(inputList)  \n            IF inputList IS EMPTY THEN  \n                RETURN []  \n            ELSE  \n                RETURN reverseList(inputList[1:]) + [inputList[0]]  \n            END IF  \n        END FUNCTION  \n        \n        LET reversedResult BE reverseList(resultList)  \n        LET extendedList BE []  \n        \n        FOR each element IN reversedResult DO  \n            extendedList = extendedList + [(element BITWISE_OR bitFlag)]  \n        END FOR  \n        \n        RETURN resultList + extendedList  \n    END FUNCTION  \nEND CLASS\nPassing rate for this pseudocode: 0.8333333333333334, but was given a label of 1\n\nAvg Score for all pseudocodes: 0.5766666666666667"
}