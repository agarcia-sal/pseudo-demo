{
  "prompt": "Given one or more pseudocode snippets, each claiming to fully solve a problem, output a single digit (`1` or `0`) for each snippet, concatenated into one string in input order, with no spaces or delimiters.\n\n**Output `1` if and only if the snippet is strictly and fully reproducible\u2014meaning it will pass every valid unit test for its problem without exception or failure under all circumstances. Otherwise, output `0`.**\n\nTo decide reproducibility, perform an exhaustive, precise, and deterministic semantic analysis of each snippet alone, ignoring comments, formatting, or any external context. Use the following refined, rigorous criteria:\n\n---\n\n### 1. **Exhaustive Coverage and Termination**  \n- The snippet covers every input case explicitly or through sound general logic, including edge cases (empty inputs, minimal, maximal, boundary values).  \n- All control constructs (loops, recursion, conditionals) terminate or yield well-defined results without infinite execution or unresolved states.  \n- No implicit assumptions, missing cases, or undefined branches remain.\n\n### 2. **Deterministic, Precise Semantics**  \n- Variables, functions, and state changes are fully and unambiguously declared, initialized, and updated within the snippet\u2014no reliance on external state, hidden variables, or unstated context.  \n- Operations and data transformations produce consistent, repeatable outputs on every valid input.  \n- No nondeterministic constructs or vague specifications exist.\n\n### 3. **Complete and Correct Algorithmic Implementation**  \n- The code embodies a logically sound and complete algorithm matching known or inferable problem requirements, not a partial outline or heuristic.  \n- All helper functions or procedures are correctly and fully defined within the snippet or context.  \n- When recognizable (classic algorithms or patterns), the pseudocode logically replicates the full correct algorithmic flow and result.\n\n### 4. **Robustness to Fault and Edge Conditions**  \n- The snippet explicitly handles invalid or special inputs, boundary values, numeric limits (overflow/underflow), empty structures, or other corner cases, avoiding undefined or erroneous states.  \n- Error conditions\u2014if applicable\u2014are addressed or logically excluded to ensure no run-time failures.\n\n### 5. **Control Flow and Data Integrity**  \n- State variables and data structures evolve coherently, with all dependencies and side effects accounted for.  \n- There are no logical contradictions, unreachable code, or disallowed operations.\n\n---\n\n### Strict instructions:\n\n- **Analyze solely the code as given**, without assuming unstated input/output formats, libraries, or environment details.  \n- **Do not evaluate style, syntax variants, or comments.**  \n- **If the snippet fails any single one of these criteria, output `0`.**  \n- **If the snippet meets all criteria beyond reasonable doubt, output `1`.**\n\n---\n\n### Output format:\n\n- A single string composed only of `1` and `0` digits, corresponding exactly to the input order of pseudocode snippets.  \n- No spaces, newlines, explanations, or any text besides the digit string.\n\n---\n\n### Performance note:\n\n- The evaluation is time-limited to 5 seconds per batch. Strive for a logically sound but efficient analysis.\n\n---\n\n**This prompt is designed to maximize accuracy in reproducibility determination with strict semantic completeness and correctness checks, minimizing false positives and false negatives across diverse pseudocode submissions.**",
  "response": "Given one or more pseudocode snippets, each claiming to fully solve a problem, output a single digit (`1` or `0`) for each snippet, concatenated into one string in input order, with no spaces or delimiters.\n\n**Output `1` if and only if the snippet is strictly and fully reproducible\u2014meaning it will pass every valid unit test for its problem without exception or failure under all circumstances. Otherwise, output `0`.**\n\nTo decide reproducibility, perform an exhaustive, precise, and deterministic semantic analysis of each snippet alone, ignoring comments, formatting, or any external context. Use the following refined, rigorous criteria:\n\n---\n\n### 1. **Exhaustive Coverage and Termination**  \n- The snippet covers every input case explicitly or through sound general logic, including edge cases (empty inputs, minimal, maximal, boundary values).  \n- All control constructs (loops, recursion, conditionals) terminate or yield well-defined results without infinite execution or unresolved states.  \n- No implicit assumptions, missing cases, or undefined branches remain.\n\n### 2. **Deterministic, Precise Semantics**  \n- Variables, functions, and state changes are fully and unambiguously declared, initialized, and updated within the snippet\u2014no reliance on external state, hidden variables, or unstated context.  \n- Operations and data transformations produce consistent, repeatable outputs on every valid input.  \n- No nondeterministic constructs or vague specifications exist.\n\n### 3. **Complete and Correct Algorithmic Implementation**  \n- The code embodies a logically sound and complete algorithm matching known or inferable problem requirements, not a partial outline or heuristic.  \n- All helper functions or procedures are correctly and fully defined within the snippet or context.  \n- When recognizable (classic algorithms or patterns), the pseudocode logically replicates the full correct algorithmic flow and result.\n\n### 4. **Robustness to Fault and Edge Conditions**  \n- The snippet explicitly handles invalid or special inputs, boundary values, numeric limits (overflow/underflow), empty structures, or other corner cases, avoiding undefined or erroneous states.  \n- Error conditions\u2014if applicable\u2014are addressed or logically excluded to ensure no run-time failures.\n\n### 5. **Control Flow and Data Integrity**  \n- State variables and data structures evolve coherently, with all dependencies and side effects accounted for.  \n- There are no logical contradictions, unreachable code, or disallowed operations.\n\n---\n\n### Strict instructions:\n\n- **Analyze solely the code as given**, without assuming unstated input/output formats, libraries, or environment details.  \n- **Do not evaluate style, syntax variants, or comments.**  \n- **If the snippet fails any single one of these criteria, output `0`.**  \n- **If the snippet meets all criteria beyond reasonable doubt, output `1`.**\n\n---\n\n### Output format:\n\n- A single string composed only of `1` and `0` digits, corresponding exactly to the input order of pseudocode snippets.  \n- No spaces, newlines, explanations, or any text besides the digit string.\n\n---\n\n### Performance note:\n\n- The evaluation is time-limited to 5 seconds per batch. Strive for a logically sound but efficient analysis.\n\n---\n\n**This prompt is designed to maximize accuracy in reproducibility determination with strict semantic completeness and correctness checks, minimizing false positives and false negatives across diverse pseudocode submissions.**",
  "score": 0.6083333333333333,
  "feedback": "The following are pseudocodes that are reproducible but were labeled as not:\nCLASS Solution  \n    FUNCTION removeDuplicates(nums)  \n        IF the LENGTH OF nums EQUALS zero THEN  \n            RETURN zero  \n        END IF  \n        \n        SET write_index TO zero  \n        \n        FOR i FROM zero TO the MINIMUM of two AND the LENGTH OF nums MINUS one  \n            SET element at position write_index of nums TO element at position i of nums  \n            INCREMENT write_index BY one  \n        END FOR  \n        \n        FOR i FROM two TO the LENGTH OF nums MINUS one  \n            IF element at position i of nums NOT EQUALS element at position write_index MINUS two of nums THEN  \n                SET element at position write_index of nums TO element at position i of nums  \n                INCREMENT write_index BY one  \n            END IF  \n        END FOR  \n        \n        RETURN write_index  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION canCross(stones)  \n        IF stones EQUALS empty OR the LENGTH OF stones LESS THAN two  \n            RETURN False  \n        END IF  \n        SET stone_set TO the SET of all elements in stones  \n        SET memo TO an EMPTY DICTIONARY  \n\n        FUNCTION can_jump_to(position, jump)  \n            IF position EQUALS the element at the last position of stones  \n                RETURN True  \n            END IF  \n            IF the TUPLE of position AND jump IS IN memo  \n                RETURN the VALUE associated with the TUPLE of position AND jump in memo  \n            END IF  \n            FOR next_jump FROM jump MINUS one TO jump PLUS one  \n                IF next_jump GREATER THAN zero AND the SUM of position AND next_jump IS IN stone_set  \n                    IF can_jump_to(the SUM of position AND next_jump, next_jump)  \n                        SET memo at key TUPLE of position AND jump TO True  \n                        RETURN True  \n                    END IF  \n                END IF  \n            END FOR  \n            SET memo at key TUPLE of position AND jump TO False  \n            RETURN False  \n        END FUNCTION  \n\n        RETURN can_jump_to(the element at the first position of stones, zero)  \n    END FUNCTION  \nEND CLASS\n\nThe following are cosmetic or modified pseudocodes of other reproducible versions of pseudocode that are reproducible but were labeled as not:\nCLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET maxIntValue AS (2 ^ 31) - 1  \n        SET minIntValue AS 0 - (2 ^ 31)  \n        SET accumulatedNumber TO 0  \n        SET position TO 0  \n        SET lengthOfString TO LENGTH OF s  \n        SET polarity TO 1  \n\n        WHILE position < lengthOfString AND s[position] = ' '  \n            position \u2190 position + 1  \n        END WHILE  \n\n        IF position < lengthOfString THEN  \n            SWITCH s[position]  \n                CASE '-'  \n                    polarity \u2190 0 - 1  \n                    position \u2190 position + 1  \n                    BREAK  \n                CASE '+'  \n                    polarity \u2190 1  \n                    position \u2190 position + 1  \n                    BREAK  \n            END SWITCH  \n        END IF  \n\n        REPEAT UNTIL NOT (position < lengthOfString AND s[position] >= '0' AND s[position] <= '9')  \n            SET currentChar TO s[position]  \n            SET numericValue TO INTEGER VALUE OF currentChar  \n            SET boundaryCheck TO maxIntValue - (numericValue DIV 10)  \n\n            IF accumulatedNumber > boundaryCheck THEN  \n                IF polarity = 1 THEN  \n                    RETURN maxIntValue  \n                ELSE  \n                    RETURN minIntValue  \n                END IF  \n            END IF  \n\n            accumulatedNumber \u2190 (accumulatedNumber * 10) + numericValue  \n            position \u2190 position + 1  \n        END REPEAT  \n\n        RETURN polarity * accumulatedNumber  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION isRectangleCover(rectangles)  \n        LET minX BE positive infinity  \n        LET minY BE positive infinity  \n        LET maxX BE negative infinity  \n        LET maxY BE negative infinity  \n        \n        INITIALIZE corners AS empty set  \n        DEFINE totalArea AS 0  \n        \n        DEFINE idx AS 0  \n        WHILE idx LESS THAN LENGTH OF rectangles DO  \n            LET rect BE rectangles[idx]  \n            LET leftX BE rect[0]  \n            LET bottomY BE rect[1]  \n            LET rightX BE rect[2]  \n            LET topY BE rect[3]  \n            \n            IF NOT (leftX >= minX) THEN  \n                minX \u2190 leftX  \n            END IF  \n            IF NOT (bottomY >= minY) THEN  \n                minY \u2190 bottomY  \n            END IF  \n            IF NOT (rightX <= maxX) THEN  \n                maxX \u2190 rightX  \n            END IF  \n            IF NOT (topY <= maxY) THEN  \n                maxY \u2190 topY  \n            END IF  \n            \n            LET rectArea BE (rightX - leftX)  \n            LET height BE (topY - bottomY)  \n            LET thisArea BE rectArea * height  \n            totalArea \u2190 totalArea + thisArea  \n            \n            LET cornerPoints BE list of pairs: (leftX, bottomY), (leftX, topY), (rightX, bottomY), (rightX, topY)  \n            \n            LET ctr AS 0  \n            WHILE ctr LESS THAN LENGTH OF cornerPoints DO  \n                LET corner BE cornerPoints[ctr]  \n                IF corners CONTAINS corner THEN  \n                    REMOVE corner FROM corners  \n                ELSE  \n                    INSERT corner INTO corners  \n                END IF  \n                ctr \u2190 ctr + 1  \n            END WHILE  \n            idx \u2190 idx + 1  \n        END WHILE  \n        \n        LET fullWidth BE maxX - minX  \n        LET fullHeight BE maxY - minY  \n        LET expectedArea BE fullWidth * fullHeight  \n        \n        IF totalArea IS NOT expectedArea THEN  \n            RETURN False  \n        END IF  \n        \n        LET requiredCorners BE set of pairs: (minX, minY), (minX, maxY), (maxX, minY), (maxX, maxY)  \n        IF corners IS NOT EQUAL TO requiredCorners THEN  \n            RETURN False  \n        END IF  \n        \n        RETURN True  \n    END FUNCTION  \nEND CLASS\n\nThe following are pseudocodes that are not reproducible but were labeled as reproducible:\nCLASS Solution\n    FUNCTION longestPalindrome(string_s)\n        SET length_n TO the LENGTH OF string_s\n        SET matrix_f TO auxiliary FUNCTION create_boolean_matrix WITH parameters length_n AND initial_value true\n        SET variable_k TO zero\n        SET variable_mx TO one\n        FOR index_i FROM length_n MINUS two TO zero STEP minus one\n            FOR index_j FROM index_i PLUS one TO length_n MINUS one\n                SET element at position index_i AND index_j of matrix_f TO false\n                IF element at position index_i of string_s EQUALS element at position index_j of string_s\n                    SET element at position index_i AND index_j of matrix_f TO element at position index_i PLUS one AND index_j MINUS one of matrix_f\n                    IF element at position index_i AND index_j of matrix_f AND variable_mx LESS THAN index_j MINUS index_i PLUS one\n                        SET variable_k TO index_i\n                        SET variable_mx TO index_j MINUS index_i PLUS one\n                    END IF\n                END IF\n            END FOR\n        END FOR\n        RETURN substring from position variable_k TO variable_k PLUS variable_mx MINUS one of string_s\n    END FUNCTION\nEND CLASS\n```\nSET INT_MAX = 2^31 - 1, INT_MIN = -2^31\nINIT res = 0, i = 0, n = len(s), sign = 1\nWHILE i < n AND s[i] = ' ' : i += 1\nIF i < n AND s[i] IN ['+', '-'] : sign = -1 IF s[i] = '-' ELSE 1; i += 1\nWHILE i < n AND s[i].isdigit():\n    d = int(s[i])\n    IF res > (INT_MAX - d)//10: RETURN INT_MAX IF sign = 1 ELSE INT_MIN\n    res = res*10 + d\n    i += 1\nRETURN sign * res\n```\n\nThe following are near-miss pseudocodes - they are almost reproducible but were labeled as reproducible:\nCLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET INT_MAX TO two POWERED BY thirty ONE MINUS one  \n        SET INT_MIN TO negative two POWERED BY thirty ONE  \n        SET result TO zero  \n        SET index TO zero  \n        SET n TO the LENGTH OF s  \n        SET sign TO one  \n        WHILE index LESS THAN n AND character at position index OF s EQUALS a single whitespace character  \n            INCREMENT index BY one  \n        END WHILE  \n        IF index LESS THAN n AND (character at position index OF s EQUALS the plus sign OR character at position index OF s EQUALS the minus sign)  \n            IF character at position index OF s EQUALS the minus sign  \n                SET sign TO negative one  \n            ELSE  \n                SET sign TO one  \n            END IF  \n            INCREMENT index BY one  \n        END IF  \n        WHILE index LESS THAN n AND character at position index OF s IS A DIGIT  \n            SET digit TO the INTEGER VALUE OF character at position index OF s  \n            IF result GREATER THAN (INT_MAX MINUS digit) DIVIDED BY ten  \n                IF sign EQUALS one  \n                    RETURN INT_MAX  \n                ELSE  \n                    RETURN INT_MIN  \n                END IF  \n            END IF  \n            SET result TO result MULTIPLIED BY ten PLUS digit  \n            INCREMENT index BY one  \n        END WHILE  \n        RETURN sign MULTIPLIED BY result  \n    END FUNCTION  \nEND CLASS\nPassing rate for this pseudocode: 0.96875, but was given a label of 1\nCLASS Solution\n    FUNCTION multiply(num1 string, num2 string) RETURNS string\n        IF num1 IS \"0\" OR num2 IS \"0\"\n            RETURN \"0\"\n        END IF\n\n        DECLARE digits AS MAP from INT to INT\n        DECLARE lengthSum AS INT = LENGTH(num1) + LENGTH(num2)\n        FOR index IN RANGE(lengthSum)\n            digits[index] = 0\n        END FOR\n\n        DECLARE reversed1 AS string = \"\"\n        DECLARE reversed2 AS string = \"\"\n        FOR p FROM LENGTH(num1) - 1 DOWNTO 0\n            reversed1 = reversed1 + num1[p]\n        END FOR\n        FOR q FROM LENGTH(num2) - 1 DOWNTO 0\n            reversed2 = reversed2 + num2[q]\n        END FOR\n\n        DECLARE function recursiveMul(i INT, j INT) RETURNS VOID\n            IF i = LENGTH(reversed1)\n                RETURN\n            END IF\n            IF j = LENGTH(reversed2)\n                recursiveMul(i + 1, 0)\n                RETURN\n            END IF\n\n            DECLARE valA AS INT = ASCII_CODE(reversed1[i]) - ASCII_CODE(\"0\")\n            DECLARE valB AS INT = ASCII_CODE(reversed2[j]) - ASCII_CODE(\"0\")\n            DECLARE product AS INT = valA * valB\n            DECLARE baseIndex AS INT = i + j\n            DECLARE nextIndex AS INT = baseIndex + 1\n            DECLARE totalSum AS INT = product + digits[baseIndex]\n\n            digits[baseIndex] = totalSum MOD 10\n            digits[nextIndex] = digits[nextIndex] + (totalSum DIV 10)\n\n            recursiveMul(i, j + 1)\n        END FUNCTION\n\n        CALL recursiveMul(0, 0)\n\n        DECLARE output AS string = \"\"\n        FOR key FROM lengthSum - 1 DOWNTO 0\n            output = output + TO_STRING(digits[key])\n        END FOR\n\n        WHILE LENGTH(output) > 1 AND output[0] = \"0\"\n            output = SUBSTRING(output, 1)\n        END WHILE\n\n        RETURN output\n    END FUNCTION\nEND CLASS\nPassing rate for this pseudocode: 0.9666666666666667, but was given a label of 1\nCLASS Solution\n    FUNCTION isMatch(s, p)\n        SET x TO LENGTH(s)\n        SET y TO LENGTH(p)\n        SET dp TO []\n        SET u TO 0\n        WHILE u <= x\n            SET tempList TO []\n            SET v TO 0\n            WHILE v <= y\n                APPEND False TO tempList\n                SET v TO v + 1\n            END WHILE\n            APPEND tempList TO dp\n            SET u TO u + 1\n        END WHILE\n\n        SET dp[0][0] TO True\n\n        PROCEDURE fillFirstRow(w)\n            IF w > y THEN\n                RETURN\n            END IF\n            IF p[w - 1] = '*'\n                SET dp[0][w] TO dp[0][w - 1]\n            END IF\n            fillFirstRow(w + 1)\n        END PROCEDURE\n\n        CALL fillFirstRow(1)\n\n        PROCEDURE processRow(i, j)\n            IF i > x THEN\n                RETURN\n            END IF\n            IF j > y THEN\n                CALL processRow(i + 1, 1)\n                RETURN\n            END IF\n\n            SWITCH TRUE\n                CASE (p[j - 1] = '*')\n                    SET dp[i][j] TO dp[i - 1][j] OR dp[i][j - 1]\n                BREAK\n\n                CASE (p[j - 1] = '?' OR s[i - 1] = p[j - 1])\n                    SET dp[i][j] TO dp[i - 1][j - 1]\n                BREAK\n\n                DEFAULT\n                    // dp[i][j] remains False implicitly\n                BREAK\n            END SWITCH\n\n            processRow(i, j + 1)\n        END PROCEDURE\n\n        CALL processRow(1, 1)\n\n        RETURN dp[x][y]\n    END FUNCTION\nEND CLASS\nPassing rate for this pseudocode: 0.96, but was given a label of 1\nCLASS Solution\n    FUNCTION removeDuplicates(nums)\n        DECLARE counter \u2190 0\n        IF counter EQUALS LENGTH(nums) THEN\n            RETURN counter\n        ELSE\n            DECLARE definer \u2190 0\n            DECLARE temp_list \u2190 new Queue()\n            \n            WHILE definer < MIN(2, LENGTH(nums))\n                ENQUEUE(nums[definer], temp_list)\n                definer \u2190 definer + 1\n            END WHILE\n            \n            WHILE NOT IS_EMPTY(temp_list)\n                nums[counter] \u2190 DEQUEUE(temp_list)\n                counter \u2190 counter + 1\n            END WHILE\n            \n            FUNCTION recurse(pos)\n                IF pos EQUALS LENGTH(nums) THEN\n                    RETURN\n                END IF\n                IF nums[pos] \u2260 nums[counter - 2] THEN\n                    nums[counter] \u2190 nums[pos]\n                    counter \u2190 counter + 1\n                END IF\n                recurse(pos + 1)\n            END FUNCTION\n            \n            recurse(2)\n            \n            RETURN counter\n        END IF\n    END FUNCTION\nEND CLASS\nPassing rate for this pseudocode: 0.9743589743589743, but was given a label of 1\n\nAvg Score for all pseudocodes: 0.6083333333333333"
}