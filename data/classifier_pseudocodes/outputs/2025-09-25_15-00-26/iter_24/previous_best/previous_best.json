{
  "prompt": "```\nTask:  \nYou will receive one or more pseudocode snippets, each describing the full logic of a solution to an unspecified computational problem. For each snippet, output exactly one digit:  \n- `1` if the pseudocode is *fully reproducible*, meaning that **any faithful implementation directly and strictly following this pseudocode (without adding, omitting, or guessing any detail) will pass every possible unit test verifying full correctness**, including normal, edge, boundary, error, invalid, and corner cases within the problem scope.  \n- `0` otherwise.  \n\nOutput:  \n- Concatenate all output digits in the input snippet order, with no spaces, newlines, or any other characters.  \n- Output nothing else (no explanations or formatting).  \n\nDefinition of *fully reproducible*:  \nA pseudocode snippet is *fully reproducible* if it unambiguously and exhaustively specifies an algorithm guaranteed to:  \n\n1. **Handle all valid and relevant invalid inputs explicitly or logically**  \n   - Define input domain, types, and constraints without unstated assumptions.  \n   - Address or safely tolerate empty inputs, zero-length structures, null-equivalents, boundary values, malformed or out-of-spec inputs within problem scope.  \n   - Reject or handle invalid inputs if expected by the problem; otherwise, explicitly exclude them.  \n   - Do *not* rely on external input validation or assumptions beyond the pseudocode.  \n\n2. **Define all variables, data structures, and state fully and clearly**  \n   - Declare and initialize every variable before use, including indices, counters, accumulators, flags, temporary values, and complex structures.  \n   - No use of undefined variables, implicit defaults, or externally defined symbols or types.  \n   - Explicitly specify data structures\u2019 sizes, initial values, and contents where relevant.\n\n3. **Specify deterministic, complete, and sound control flow and logic**  \n   - All loops and recursion have well-defined entry, progress, and termination conditions ensuring no infinite loops or premature exits that violate correctness.  \n   - Conditionals and switch statements collectively cover all relevant input and intermediate states with no ambiguous or omitted branches.  \n   - No logically contradictory, conflicting, or unreachable code affecting outcome correctness.  \n   - Every control path is well explained and fully covered.\n\n4. **Provide detailed, unambiguous, and correct algorithmic steps**  \n   - Every computational step, update, mutation, comparison, and operation is explicit, logically consistent, and accurately captures the intended algorithm.  \n   - No gaps, vague descriptions, or missing essential operations.  \n   - Arithmetic or indexing operations are clearly defined and respect data boundaries.\n\n5. **Explicitly handle all boundaries, edge cases, and exceptional or failure conditions**  \n   - Boundary values (e.g., minimal and maximal inputs, empty data, zero divisors, possible overflow/underflow cases) are checked and correctly handled.  \n   - Contains safeguards or checks avoiding undefined or erroneous states (e.g., out-of-range accesses, invalid memory/state).  \n   - Error handling or alternative flows for invalid or exceptional inputs are specified if the problem domain requires them.\n\n6. **Define outputs precisely and deterministically**  \n   - Output values, formats, and types are explicitly given and unmistakably derived from prior computation steps.  \n   - Intermediate and final outputs have no ambiguity about their construction or meaning.  \n   - Output format complies fully with expected problem output conventions.\n\n7. **Require no external context, unstated assumptions, or hidden dependencies**  \n   - The snippet is fully self-contained and implementable as-is, relying only on primitives explicitly defined within or universally understood in pseudocode context.  \n   - Does *not* depend on external libraries, environment, data, language features, or implicit behaviors.  \n   - No need for reader or implementer to infer or fill any missing detail.\n\n8. **Maintain clarity, consistency, and precision in style and notation**  \n   - Pseudocode syntax and idioms must be clear; style variations are allowed only if they maintain unambiguous semantics and full logical completeness.  \n   - Avoid overly terse, ambiguous, or inconsistent expressions that lead to conflicting interpretations.  \n   - Ambiguity in control flow, state changes, or output caused by style issues invalidates reproducibility.\n\n**Evaluation instructions:**  \n- Carefully and conservatively analyze each snippet according to all 8 criteria.  \n- If *any* uncertainty, missing detail, ambiguity, incompleteness, or logical gap exists that could cause any conceivable failing unit test, return `0`.  \n- Output `1` *only if* the snippet meets *all* criteria rigorously and completely.  \n- This includes full functional correctness across the entire expected input/output domain, not just typical or common cases.  \n\n**Additional strict notes:**  \n- Do *not* guess or supply any missing details or constraints, even if intuitively obvious.  \n- Do *not* tolerate implicit assumptions about input validity, environment or language behavior, or implementation details.  \n- Thoroughly consider the snippet\u2019s behavior on edge cases, invalid cases (if applicable), corner cases, and complex logical scenarios.  \n- Guard against subtle reproducibility pitfalls: uninitialized states, implicit default values, overlooked boundary conditions, ambiguous returns, infinite loops or recursion, and partial or incomplete logic coverage.  \n\n---\n\nPseudocode:  \n```<INSERT_PSEUDOCODE_HERE>```\n```",
  "response": "```\nTask:  \nYou will receive one or more pseudocode snippets, each describing the full logic of a solution to an unspecified computational problem. For each snippet, output exactly one digit:  \n- `1` if the pseudocode is *fully reproducible*, meaning that **any faithful implementation directly and strictly following this pseudocode (without adding, omitting, or guessing any detail) will pass every possible unit test verifying full correctness**, including normal, edge, boundary, error, invalid, and corner cases within the problem scope.  \n- `0` otherwise.  \n\nOutput:  \n- Concatenate all output digits in the input snippet order, with no spaces, newlines, or any other characters.  \n- Output nothing else (no explanations or formatting).  \n\nDefinition of *fully reproducible*:  \nA pseudocode snippet is *fully reproducible* if it unambiguously and exhaustively specifies an algorithm guaranteed to:  \n\n1. **Handle all valid and relevant invalid inputs explicitly or logically**  \n   - Define input domain, types, and constraints without unstated assumptions.  \n   - Address or safely tolerate empty inputs, zero-length structures, null-equivalents, boundary values, malformed or out-of-spec inputs within problem scope.  \n   - Reject or handle invalid inputs if expected by the problem; otherwise, explicitly exclude them.  \n   - Do *not* rely on external input validation or assumptions beyond the pseudocode.  \n\n2. **Define all variables, data structures, and state fully and clearly**  \n   - Declare and initialize every variable before use, including indices, counters, accumulators, flags, temporary values, and complex structures.  \n   - No use of undefined variables, implicit defaults, or externally defined symbols or types.  \n   - Explicitly specify data structures\u2019 sizes, initial values, and contents where relevant.\n\n3. **Specify deterministic, complete, and sound control flow and logic**  \n   - All loops and recursion have well-defined entry, progress, and termination conditions ensuring no infinite loops or premature exits that violate correctness.  \n   - Conditionals and switch statements collectively cover all relevant input and intermediate states with no ambiguous or omitted branches.  \n   - No logically contradictory, conflicting, or unreachable code affecting outcome correctness.  \n   - Every control path is well explained and fully covered.\n\n4. **Provide detailed, unambiguous, and correct algorithmic steps**  \n   - Every computational step, update, mutation, comparison, and operation is explicit, logically consistent, and accurately captures the intended algorithm.  \n   - No gaps, vague descriptions, or missing essential operations.  \n   - Arithmetic or indexing operations are clearly defined and respect data boundaries.\n\n5. **Explicitly handle all boundaries, edge cases, and exceptional or failure conditions**  \n   - Boundary values (e.g., minimal and maximal inputs, empty data, zero divisors, possible overflow/underflow cases) are checked and correctly handled.  \n   - Contains safeguards or checks avoiding undefined or erroneous states (e.g., out-of-range accesses, invalid memory/state).  \n   - Error handling or alternative flows for invalid or exceptional inputs are specified if the problem domain requires them.\n\n6. **Define outputs precisely and deterministically**  \n   - Output values, formats, and types are explicitly given and unmistakably derived from prior computation steps.  \n   - Intermediate and final outputs have no ambiguity about their construction or meaning.  \n   - Output format complies fully with expected problem output conventions.\n\n7. **Require no external context, unstated assumptions, or hidden dependencies**  \n   - The snippet is fully self-contained and implementable as-is, relying only on primitives explicitly defined within or universally understood in pseudocode context.  \n   - Does *not* depend on external libraries, environment, data, language features, or implicit behaviors.  \n   - No need for reader or implementer to infer or fill any missing detail.\n\n8. **Maintain clarity, consistency, and precision in style and notation**  \n   - Pseudocode syntax and idioms must be clear; style variations are allowed only if they maintain unambiguous semantics and full logical completeness.  \n   - Avoid overly terse, ambiguous, or inconsistent expressions that lead to conflicting interpretations.  \n   - Ambiguity in control flow, state changes, or output caused by style issues invalidates reproducibility.\n\n**Evaluation instructions:**  \n- Carefully and conservatively analyze each snippet according to all 8 criteria.  \n- If *any* uncertainty, missing detail, ambiguity, incompleteness, or logical gap exists that could cause any conceivable failing unit test, return `0`.  \n- Output `1` *only if* the snippet meets *all* criteria rigorously and completely.  \n- This includes full functional correctness across the entire expected input/output domain, not just typical or common cases.  \n\n**Additional strict notes:**  \n- Do *not* guess or supply any missing details or constraints, even if intuitively obvious.  \n- Do *not* tolerate implicit assumptions about input validity, environment or language behavior, or implementation details.  \n- Thoroughly consider the snippet\u2019s behavior on edge cases, invalid cases (if applicable), corner cases, and complex logical scenarios.  \n- Guard against subtle reproducibility pitfalls: uninitialized states, implicit default values, overlooked boundary conditions, ambiguous returns, infinite loops or recursion, and partial or incomplete logic coverage.  \n\n---\n\nPseudocode:  \n```<INSERT_PSEUDOCODE_HERE>```\n```",
  "score": 0.6283333333333333,
  "feedback": "We have a 4 way split for the pseudocodes: true positives, which are pseudocodes that correspond to code that passes all test cases.\nWe also have true negatives, which are pseudocodes that correspond to code that do not pass all test cases.\nWe have cosmetic, which are pseudocodes that are variations of the positive pseudocodes and also pass all test cases.\nWe have near-misses, which are pseudocodes that correspond to code that almost passes all test cases but do not. They pass at least 80% of test cases\nHere is the score for this prompt on positive-labeled pseudocodes: 0.5333333333333333\nHere is the score for this prompt on negative-labeled pseudocodes: 0.7933333333333333\nHere is the score for this prompt on cosmetic-labeled pseudocodes: 0.5866666666666667\nHere is the score for this prompt on near_miss-labeled pseudocodes: 0.6\n\nThe following are pseudocodes that are reproducible but were labeled as not:\nCLASS Solution  \n    FUNCTION longestPalindrome(s)  \n        SET n TO the LENGTH OF s  \n        SET f TO a TWO DIMENSIONAL LIST of BOOLEAN TRUES with n ROWS and n COLUMNS  \n        SET k TO zero  \n        SET mx TO one  \n        FOR i FROM n MINUS two DOWN TO zero  \n            FOR j FROM i PLUS one TO n MINUS one  \n                SET element at position i and position j of f TO FALSE  \n                IF element at position i of s EQUALS element at position j of s  \n                    SET element at position i and position j of f TO element at position i PLUS one and position j MINUS one of f  \n                    IF element at position i and position j of f EQUALS TRUE AND mx LESS THAN j MINUS i PLUS one  \n                        SET k TO i  \n                        SET mx TO j MINUS i PLUS one  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN substring from position k TO position k PLUS mx MINUS one of s  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION multiply(num1 string num2 string) RETURNS string  \n        IF num1 EQUALS string zero OR num2 EQUALS string zero  \n            RETURN string zero  \n        END IF  \n\n        SET result TO a list of zeros with the LENGTH OF num1 PLUS the LENGTH OF num2  \n\n        SET num1 TO the reversal of num1  \n        SET num2 TO the reversal of num2  \n\n        FOR i FROM zero TO the LENGTH OF num1 MINUS one  \n            FOR j FROM zero TO the LENGTH OF num2 MINUS one  \n                SET mul TO the character code of the element at position i of num1 MINUS the character code of string zero MULTIPLIED BY the character code of the element at position j of num2 MINUS the character code of string zero  \n                SET p1 TO i PLUS j  \n                SET p2 TO i PLUS j PLUS one  \n                SET sum TO mul PLUS the element at position p1 of result  \n\n                SET the element at position p1 of result TO sum MODULO ten  \n                INCREMENT the element at position p2 of result BY the integer division of sum BY ten  \n            END FOR  \n        END FOR  \n\n        SET result_str TO the concatenation of the string representations of the elements of result in reverse order  \n        RETURN result_str with all leading string zeros removed  \n    END FUNCTION  \nEND CLASS\n\nThe following are cosmetic or modified pseudocodes of other reproducible versions of pseudocode that are reproducible but were labeled as not:\noriginal version of the pseudocode for this problem that is reproducible:\nCLASS Solution  \n    FUNCTION longestPalindrome(s)  \n        SET n TO the LENGTH OF s  \n        SET f TO a TWO DIMENSIONAL LIST of BOOLEAN TRUES with n ROWS and n COLUMNS  \n        SET k TO zero  \n        SET mx TO one  \n        FOR i FROM n MINUS two DOWN TO zero  \n            FOR j FROM i PLUS one TO n MINUS one  \n                SET element at position i and position j of f TO FALSE  \n                IF element at position i of s EQUALS element at position j of s  \n                    SET element at position i and position j of f TO element at position i PLUS one and position j MINUS one of f  \n                    IF element at position i and position j of f EQUALS TRUE AND mx LESS THAN j MINUS i PLUS one  \n                        SET k TO i  \n                        SET mx TO j MINUS i PLUS one  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN substring from position k TO position k PLUS mx MINUS one of s  \n    END FUNCTION  \nEND CLASS\nmodified version of the pseudocode for this problem that is also reproducible:\nCLASS Solution\n    FUNCTION longestPalindrome(s)\n        SET length AS THE COUNT OF s\n        SET truth_matrix AS AN ARRAY (length) OF ARRAYS (length) FILLED WITH TRUE\n        SET start_index AS 0\n        SET max_length AS 1\n        \n        SET outer_index AS length MINUS 2\n        WHILE outer_index IS GREATER THAN OR EQUAL TO 0 DO\n            SET inner_index AS outer_index PLUS 1\n            WHILE inner_index IS LESS THAN length DO\n                SET truth_matrix[outer_index][inner_index] AS FALSE\n                \n                IF NOT (s[outer_index] NOT EQUAL TO s[inner_index]) THEN\n                    SET truth_matrix[outer_index][inner_index] AS truth_matrix[outer_index PLUS 1][inner_index MINUS 1]\n                    \n                    IF truth_matrix[outer_index][inner_index] IS TRUE THEN\n                        IF (max_length LESS THAN (inner_index MINUS outer_index PLUS 1)) THEN\n                            SET start_index AS outer_index\n                            SET max_length AS (inner_index MINUS outer_index PLUS 1)\n                        END IF\n                    END IF\n                END IF\n                INCREMENT inner_index BY 1\n            END WHILE\n            DECREMENT outer_index BY 1\n        END WHILE\n        \n        RETURN s SUBSTRING FROM start_index TO (start_index PLUS max_length MINUS 1)\n    END FUNCTION\nEND CLASS\noriginal version of the pseudocode for this problem that is reproducible:\nCLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET INT_MAX TO two RAISED TO THE POWER OF thirty ONE MINUS one  \n        SET INT_MIN TO the NEGATIVE of two RAISED TO THE POWER OF thirty ONE  \n        SET result TO zero  \n        SET index TO zero  \n        SET n TO the LENGTH OF s  \n        SET sign TO one  \n        WHILE index LESS THAN n AND element at position index of s EQUALS the space character  \n            INCREMENT index BY one  \n        END WHILE  \n        IF index LESS THAN n AND (element at position index of s EQUALS the plus character OR element at position index of s EQUALS the minus character)  \n            IF element at position index of s EQUALS the minus character  \n                SET sign TO the NEGATIVE of one  \n            ELSE  \n                SET sign TO one  \n            END IF  \n            INCREMENT index BY one  \n        END IF  \n        WHILE index LESS THAN n AND element at position index of s IS A DIGIT  \n            SET digit TO the INTEGER VALUE OF element at position index of s  \n            IF result GREATER THAN INT_MAX MINUS digit DIVIDED BY ten  \n                IF sign EQUALS one  \n                    RETURN INT_MAX  \n                ELSE  \n                    RETURN INT_MIN  \n                END IF  \n            END IF  \n            SET result TO result MULTIPLIED BY ten PLUS digit  \n            INCREMENT index BY one  \n        END WHILE  \n        RETURN sign MULTIPLIED BY result  \n    END FUNCTION  \nEND CLASS\nmodified version of the pseudocode for this problem that is also reproducible:\nCLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET maxIntValue AS (2 ^ 31) - 1  \n        SET minIntValue AS 0 - (2 ^ 31)  \n        SET accumulatedNumber TO 0  \n        SET position TO 0  \n        SET lengthOfString TO LENGTH OF s  \n        SET polarity TO 1  \n\n        WHILE position < lengthOfString AND s[position] = ' '  \n            position \u2190 position + 1  \n        END WHILE  \n\n        IF position < lengthOfString THEN  \n            SWITCH s[position]  \n                CASE '-'  \n                    polarity \u2190 0 - 1  \n                    position \u2190 position + 1  \n                    BREAK  \n                CASE '+'  \n                    polarity \u2190 1  \n                    position \u2190 position + 1  \n                    BREAK  \n            END SWITCH  \n        END IF  \n\n        REPEAT UNTIL NOT (position < lengthOfString AND s[position] >= '0' AND s[position] <= '9')  \n            SET currentChar TO s[position]  \n            SET numericValue TO INTEGER VALUE OF currentChar  \n            SET boundaryCheck TO maxIntValue - (numericValue DIV 10)  \n\n            IF accumulatedNumber > boundaryCheck THEN  \n                IF polarity = 1 THEN  \n                    RETURN maxIntValue  \n                ELSE  \n                    RETURN minIntValue  \n                END IF  \n            END IF  \n\n            accumulatedNumber \u2190 (accumulatedNumber * 10) + numericValue  \n            position \u2190 position + 1  \n        END REPEAT  \n\n        RETURN polarity * accumulatedNumber  \n    END FUNCTION  \nEND CLASS\n\nThe following are pseudocodes that are not reproducible but were labeled as reproducible:\n```\nSET INT_MAX = 2^31 - 1, INT_MIN = -2^31\nINIT res = 0, i = 0, n = len(s), sign = 1\nWHILE i < n AND s[i] = ' ' : i += 1\nIF i < n AND s[i] IN ['+', '-'] : sign = -1 IF s[i] = '-' ELSE 1; i += 1\nWHILE i < n AND s[i].isdigit():\n    d = int(s[i])\n    IF res > (INT_MAX - d)//10: RETURN INT_MAX IF sign = 1 ELSE INT_MIN\n    res = res*10 + d\n    i += 1\nRETURN sign * res\n```\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET INT_MAX TO two RAISED TO THE POWER OF thirty ONE MINUS one  \n        SET INT_MIN TO the NEGATIVE of two RAISED TO THE POWER OF thirty ONE  \n        SET result TO zero  \n        SET index TO zero  \n        SET n TO the LENGTH OF s  \n        SET sign TO one  \n        WHILE index LESS THAN n AND element at position index of s EQUALS the space character  \n            INCREMENT index BY one  \n        END WHILE  \n        IF index LESS THAN n AND (element at position index of s EQUALS the plus character OR element at position index of s EQUALS the minus character)  \n            IF element at position index of s EQUALS the minus character  \n                SET sign TO the NEGATIVE of one  \n            ELSE  \n                SET sign TO one  \n            END IF  \n            INCREMENT index BY one  \n        END IF  \n        WHILE index LESS THAN n AND element at position index of s IS A DIGIT  \n            SET digit TO the INTEGER VALUE OF element at position index of s  \n            IF result GREATER THAN INT_MAX MINUS digit DIVIDED BY ten  \n                IF sign EQUALS one  \n                    RETURN INT_MAX  \n                ELSE  \n                    RETURN INT_MIN  \n                END IF  \n            END IF  \n            SET result TO result MULTIPLIED BY ten PLUS digit  \n            INCREMENT index BY one  \n        END WHILE  \n        RETURN sign MULTIPLIED BY result  \n    END FUNCTION  \nEND CLASS\nCLASS Solution\n    FUNCTION canJump(list_of_numbers)\n        SET farthest_reachable_index TO zero\n        FOR index FROM zero TO the LENGTH OF list_of_numbers MINUS one INCLUSIVE\n            IF index GREATER THAN farthest_reachable_index\n                RETURN False\n            END IF\n            SET possible_reach TO index PLUS element at position index OF list_of_numbers\n            SET farthest_reachable_index TO the GREATER OF farthest_reachable_index AND possible_reach\n        END FOR\n        RETURN farthest_reachable_index GREATER THAN OR EQUAL TO the LENGTH OF list_of_numbers MINUS one\n    END FUNCTION\nEND CLASS\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION canJump(nums)  \n        SET farthest TO zero  \n        FOR i FROM zero TO the LENGTH OF nums MINUS one  \n            IF i GREATER THAN farthest  \n                RETURN false  \n            END IF  \n            SET possible_reach TO i PLUS element at position i of nums  \n            IF possible_reach GREATER THAN farthest  \n                SET farthest TO possible_reach  \n            END IF  \n        END FOR  \n        IF farthest GREATER THAN OR EQUAL TO the LENGTH OF nums MINUS one  \n            RETURN true  \n        ELSE  \n            RETURN false  \n        END IF  \n    END FUNCTION  \nEND CLASS\n\nThe following are near-miss pseudocodes - they are almost reproducible but were labeled as reproducible:\nCLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET INT_MAX TO two POWERED BY thirty ONE MINUS one  \n        SET INT_MIN TO negative two POWERED BY thirty ONE  \n        SET result TO zero  \n        SET index TO zero  \n        SET n TO the LENGTH OF s  \n        SET sign TO one  \n        WHILE index LESS THAN n AND character at position index OF s EQUALS a single whitespace character  \n            INCREMENT index BY one  \n        END WHILE  \n        IF index LESS THAN n AND (character at position index OF s EQUALS the plus sign OR character at position index OF s EQUALS the minus sign)  \n            IF character at position index OF s EQUALS the minus sign  \n                SET sign TO negative one  \n            ELSE  \n                SET sign TO one  \n            END IF  \n            INCREMENT index BY one  \n        END IF  \n        WHILE index LESS THAN n AND character at position index OF s IS A DIGIT  \n            SET digit TO the INTEGER VALUE OF character at position index OF s  \n            IF result GREATER THAN (INT_MAX MINUS digit) DIVIDED BY ten  \n                IF sign EQUALS one  \n                    RETURN INT_MAX  \n                ELSE  \n                    RETURN INT_MIN  \n                END IF  \n            END IF  \n            SET result TO result MULTIPLIED BY ten PLUS digit  \n            INCREMENT index BY one  \n        END WHILE  \n        RETURN sign MULTIPLIED BY result  \n    END FUNCTION  \nEND CLASS\nPassing rate for this pseudocode: 0.96875, but was given a label of 1\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET INT_MAX TO two RAISED TO THE POWER OF thirty ONE MINUS one  \n        SET INT_MIN TO the NEGATIVE of two RAISED TO THE POWER OF thirty ONE  \n        SET result TO zero  \n        SET index TO zero  \n        SET n TO the LENGTH OF s  \n        SET sign TO one  \n        WHILE index LESS THAN n AND element at position index of s EQUALS the space character  \n            INCREMENT index BY one  \n        END WHILE  \n        IF index LESS THAN n AND (element at position index of s EQUALS the plus character OR element at position index of s EQUALS the minus character)  \n            IF element at position index of s EQUALS the minus character  \n                SET sign TO the NEGATIVE of one  \n            ELSE  \n                SET sign TO one  \n            END IF  \n            INCREMENT index BY one  \n        END IF  \n        WHILE index LESS THAN n AND element at position index of s IS A DIGIT  \n            SET digit TO the INTEGER VALUE OF element at position index of s  \n            IF result GREATER THAN INT_MAX MINUS digit DIVIDED BY ten  \n                IF sign EQUALS one  \n                    RETURN INT_MAX  \n                ELSE  \n                    RETURN INT_MIN  \n                END IF  \n            END IF  \n            SET result TO result MULTIPLIED BY ten PLUS digit  \n            INCREMENT index BY one  \n        END WHILE  \n        RETURN sign MULTIPLIED BY result  \n    END FUNCTION  \nEND CLASS\nCLASS Solution\n    FUNCTION multiply(num1 string, num2 string) RETURNS string\n        IF num1 IS \"0\" OR num2 IS \"0\"\n            RETURN \"0\"\n        END IF\n\n        DECLARE digits AS MAP from INT to INT\n        DECLARE lengthSum AS INT = LENGTH(num1) + LENGTH(num2)\n        FOR index IN RANGE(lengthSum)\n            digits[index] = 0\n        END FOR\n\n        DECLARE reversed1 AS string = \"\"\n        DECLARE reversed2 AS string = \"\"\n        FOR p FROM LENGTH(num1) - 1 DOWNTO 0\n            reversed1 = reversed1 + num1[p]\n        END FOR\n        FOR q FROM LENGTH(num2) - 1 DOWNTO 0\n            reversed2 = reversed2 + num2[q]\n        END FOR\n\n        DECLARE function recursiveMul(i INT, j INT) RETURNS VOID\n            IF i = LENGTH(reversed1)\n                RETURN\n            END IF\n            IF j = LENGTH(reversed2)\n                recursiveMul(i + 1, 0)\n                RETURN\n            END IF\n\n            DECLARE valA AS INT = ASCII_CODE(reversed1[i]) - ASCII_CODE(\"0\")\n            DECLARE valB AS INT = ASCII_CODE(reversed2[j]) - ASCII_CODE(\"0\")\n            DECLARE product AS INT = valA * valB\n            DECLARE baseIndex AS INT = i + j\n            DECLARE nextIndex AS INT = baseIndex + 1\n            DECLARE totalSum AS INT = product + digits[baseIndex]\n\n            digits[baseIndex] = totalSum MOD 10\n            digits[nextIndex] = digits[nextIndex] + (totalSum DIV 10)\n\n            recursiveMul(i, j + 1)\n        END FUNCTION\n\n        CALL recursiveMul(0, 0)\n\n        DECLARE output AS string = \"\"\n        FOR key FROM lengthSum - 1 DOWNTO 0\n            output = output + TO_STRING(digits[key])\n        END FOR\n\n        WHILE LENGTH(output) > 1 AND output[0] = \"0\"\n            output = SUBSTRING(output, 1)\n        END WHILE\n\n        RETURN output\n    END FUNCTION\nEND CLASS\nPassing rate for this pseudocode: 0.9666666666666667, but was given a label of 1\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION multiply(num1 string num2 string) RETURNS string  \n        IF num1 EQUALS string zero OR num2 EQUALS string zero  \n            RETURN string zero  \n        END IF  \n\n        SET result TO a list of zeros with the LENGTH OF num1 PLUS the LENGTH OF num2  \n\n        SET num1 TO the reversal of num1  \n        SET num2 TO the reversal of num2  \n\n        FOR i FROM zero TO the LENGTH OF num1 MINUS one  \n            FOR j FROM zero TO the LENGTH OF num2 MINUS one  \n                SET mul TO the character code of the element at position i of num1 MINUS the character code of string zero MULTIPLIED BY the character code of the element at position j of num2 MINUS the character code of string zero  \n                SET p1 TO i PLUS j  \n                SET p2 TO i PLUS j PLUS one  \n                SET sum TO mul PLUS the element at position p1 of result  \n\n                SET the element at position p1 of result TO sum MODULO ten  \n                INCREMENT the element at position p2 of result BY the integer division of sum BY ten  \n            END FOR  \n        END FOR  \n\n        SET result_str TO the concatenation of the string representations of the elements of result in reverse order  \n        RETURN result_str with all leading string zeros removed  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION grayCode(n)  \n        IF n IS 0 THEN  \n            RETURN [0]  \n        END IF  \n        \n        ASSIGN resultList TO grayCode(n - 1)  \n        LET bitFlag BE 2 ^ (n - 1) * 1  \n        \n        DEFINE FUNCTION reverseList(inputList)  \n            IF inputList IS EMPTY THEN  \n                RETURN []  \n            ELSE  \n                RETURN reverseList(inputList[1:]) + [inputList[0]]  \n            END IF  \n        END FUNCTION  \n        \n        LET reversedResult BE reverseList(resultList)  \n        LET extendedList BE []  \n        \n        FOR each element IN reversedResult DO  \n            extendedList = extendedList + [(element BITWISE_OR bitFlag)]  \n        END FOR  \n        \n        RETURN resultList + extendedList  \n    END FUNCTION  \nEND CLASS\nPassing rate for this pseudocode: 0.8333333333333334, but was given a label of 1\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION grayCode(n)  \n        IF n EQUALS zero  \n            RETURN a list containing zero  \n        END IF  \n        SET prev_gray TO the result of calling grayCode with the value of n MINUS one  \n        SET mask TO one MULTIPLIED BY two RAISED TO the power of n MINUS one  \n        SET current_gray TO concatenation of prev_gray WITH a list constructed by taking each number IN the reversed prev_gray AND applying bitwise OR with mask  \n        RETURN current_gray  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION reverseWords(s)  \n        DECLARE wordList AS list  \n        wordList \u2190 EMPTY LIST  \n        DECLARE index AS INTEGER  \n        index \u2190 0  \n        WHILE index < LENGTH(s) DO  \n            WHILE index < LENGTH(s) AND s[index] = ' ' DO  \n                index \u2190 index + 1  \n            END WHILE  \n            IF index = LENGTH(s) THEN  \n                BREAK  \n            END IF  \n            DECLARE startPos AS INTEGER  \n            startPos \u2190 index  \n            WHILE index < LENGTH(s) AND s[index] \u2260 ' ' DO  \n                index \u2190 index + 1  \n            END WHILE  \n            SET word TO SUBSTRING(s, startPos, index - startPos)  \n            APPEND word TO wordList  \n        END WHILE  \n        DECLARE reversedList AS list  \n        reversedList \u2190 EMPTY LIST  \n        DECLARE pos AS INTEGER  \n        pos \u2190 LENGTH(wordList) - 1  \n        WHILE pos \u2265 0 DO  \n            APPEND wordList[pos] TO reversedList  \n            pos \u2190 pos - 1  \n        END WHILE  \n        DECLARE result AS STRING  \n        result \u2190 \"\"  \n        FOR EACH element IN reversedList DO  \n            IF result = \"\" THEN  \n                result \u2190 element  \n            ELSE  \n                result \u2190 result + \" \" + element  \n            END IF  \n        END FOR  \n        RETURN result  \n    END FUNCTION  \nEND CLASS\nPassing rate for this pseudocode: 0.9545454545454546, but was given a label of 1\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION reverseWords(s)  \n        SET words TO list of words obtained by splitting s by spaces where multiple spaces are handled automatically  \n        REVERSE the order of elements in words  \n        RETURN single string obtained by joining elements of words with single spaces between them  \n    END FUNCTION  \nEND CLASS\n\nAvg Score for all pseudocodes: 0.6283333333333333"
}