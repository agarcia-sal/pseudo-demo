{
  "prompt": "```\nTask:\nYou will be given one or more pseudocode snippets. For each snippet, output a single digit \u2014 `1` if the pseudocode is fully reproducible, or `0` otherwise.  \nOutput only the sequence of digits (one per snippet), concatenated exactly in input order, with no spaces, newlines, or any other characters.\n\nDefinition of *fully reproducible*:  \nA pseudocode snippet is considered *fully reproducible* if **any faithful implementation strictly following the snippet, with no external assumptions, unstated details, or guesswork, will pass every possible unit test related to its intended functionality** \u2014 including all normal cases, edge cases, boundary conditions, error handling, invalid input scenarios, and any atypical or corner cases implied or reasonably expected from the problem domain.\n\nKey instructions:  \n- Do **not** infer or assume any missing details, implicit constraints, or unstated initializations.  \n- Do **not** overlook ambiguous, partial, or incomplete logic, control flow, or state definitions.  \n- Be rigorously conservative: if there is *any* uncertainty, incompleteness, or logical gap that could cause failure or unpredictable behavior in *any* conceivable unit test, output `0`.  \n- Cosmetic differences, stylistic variations, or idiomatic pseudocode constructs should **not** influence your judgment unless they introduce ambiguity or incompleteness in logic, initialization, or output.\n\nRigorous Criteria Checklist: For EACH snippet, verify all these with zero ambiguity or omission:\n\n1. **Explicit and comprehensive input handling**  \n   - All valid input types, ranges, and edge cases (empty inputs, zeros, null-equivalents, min/max values, special characters, unusual or boundary conditions, etc.) are explicitly addressed or logically inevitably handled without unstated assumptions.  \n   - No reliance on implicit input guarantees, nor ignoring possible malformed or unexpected inputs if they fall within the problem scope.\n\n2. **Complete and clear state initialization and definition**  \n   - Every variable, structure, and state element is properly declared and initialized before use, with no undefined or ambiguously scoped references.  \n   - Includes any data structures, accumulators, flags, indices, counters, or helper state.\n\n3. **Deterministic, logically sound, and fully covered control flow**  \n   - All loops and recursion have clear, reachable, and terminating conditions that prevent infinite loops or premature exits that break correctness.  \n   - All conditional branches collectively cover every logical scenario; no missing cases, no contradictions, no unreachable or dead code that interferes with correctness.  \n   - Control structures (if/switch/while/for/recursion) must explicitly or implicitly handle all relevant input and intermediate states.\n\n4. **Complete, unambiguous, and correct algorithmic logic**  \n   - Each computational step, state update, and mutation is explicitly detailed, with no logical contradictions or gaps.  \n   - The intended algorithm is thoroughly captured \u2014 no essential steps omitted or vaguely implied.  \n   - Arithmetic operations, indexing, data transformations, and logical decisions must be clearly stated and consistent.\n\n5. **Robust handling of boundaries, special cases, and failure modes**  \n   - Explicit attention to boundary conditions such as minimal/maximal input sizes, zero-length structures, zero-division, overflow/underflow, empty outputs, or domain-specific corner cases.  \n   - Proper checks or safeguards to avoid undefined behavior, out-of-bounds accesses, or runtime errors.  \n   - Clear handling of error states, invalid inputs, or exceptional conditions if the problem domain requires it.\n\n6. **Fully specified, deterministic output construction**  \n   - Outputs and return values (including intermediate and final) are precisely defined and deterministically derived from prior steps.  \n   - No ambiguity about what is returned, how outputs are formed, or their format.  \n   - Consistent with the problem statement's expected output type and format.\n\n7. **Absolute self-containment with no reliance on unstated external context**  \n   - The snippet must be interpretable and implementable *as-is*, with no hidden assumptions about external functions, language-specific behavior, environment, libraries, or data.  \n   - No gaps requiring the reader or implementer to fill in missing details or to infer unstated mechanisms.\n\n8. **Style, formatting, or pseudocode idioms must not threaten clarity or reproducibility**  \n   - Variations in pseudocode expression\u2014such as loops vs recursion, array indexing style, or naming conventions\u2014are acceptable *only if* they maintain full clarity and completeness logically.  \n   - Ambiguous, overly terse, or inconsistent style causing misunderstanding or interpretative differences disqualify reproducibility.\n\nDecision rule:  \n- Output `1` if and only if **all** the above 8 criteria are fulfilled completely and without any ambiguity or omission.  \n- Output `0` otherwise, including near-perfect but imperfect snippets that risk failing some test case.\n\nOutput format:  \n- For multiple snippets, output a single string of digits (`1` or `0`), directly concatenated in the same sequence as input.  \n- Output nothing else \u2014 no explanations, comments, whitespace, or other characters.\n\nAdditional rigor notes:  \n- Do **not** guess or fill missing information even if it seems reasonable.  \n- Do **not** shortcut detailed logical evaluation of control flow, state initialization, or boundary checks.  \n- Consider *all* conceivable unit tests for correctness: edge cases, extremes, unusual inputs, error conditions, and invalid inputs consistent with problem scope.  \n- Guard against common pitfalls such as infinite recursion/loops, uninitialized variables, incomplete boundary checks, ambiguous return definitions, implicit assumptions, and unstated dependencies.\n\n---\n\nPseudocode: ```<INSERT_PSEUDOCODE_HERE>```\n```\n",
  "response": "```\nTask:\nYou will be given one or more pseudocode snippets. For each snippet, output a single digit \u2014 `1` if the pseudocode is fully reproducible, or `0` otherwise.  \nOutput only the sequence of digits (one per snippet), concatenated exactly in input order, with no spaces, newlines, or any other characters.\n\nDefinition of *fully reproducible*:  \nA pseudocode snippet is considered *fully reproducible* if **any faithful implementation strictly following the snippet, with no external assumptions, unstated details, or guesswork, will pass every possible unit test related to its intended functionality** \u2014 including all normal cases, edge cases, boundary conditions, error handling, invalid input scenarios, and any atypical or corner cases implied or reasonably expected from the problem domain.\n\nKey instructions:  \n- Do **not** infer or assume any missing details, implicit constraints, or unstated initializations.  \n- Do **not** overlook ambiguous, partial, or incomplete logic, control flow, or state definitions.  \n- Be rigorously conservative: if there is *any* uncertainty, incompleteness, or logical gap that could cause failure or unpredictable behavior in *any* conceivable unit test, output `0`.  \n- Cosmetic differences, stylistic variations, or idiomatic pseudocode constructs should **not** influence your judgment unless they introduce ambiguity or incompleteness in logic, initialization, or output.\n\nRigorous Criteria Checklist: For EACH snippet, verify all these with zero ambiguity or omission:\n\n1. **Explicit and comprehensive input handling**  \n   - All valid input types, ranges, and edge cases (empty inputs, zeros, null-equivalents, min/max values, special characters, unusual or boundary conditions, etc.) are explicitly addressed or logically inevitably handled without unstated assumptions.  \n   - No reliance on implicit input guarantees, nor ignoring possible malformed or unexpected inputs if they fall within the problem scope.\n\n2. **Complete and clear state initialization and definition**  \n   - Every variable, structure, and state element is properly declared and initialized before use, with no undefined or ambiguously scoped references.  \n   - Includes any data structures, accumulators, flags, indices, counters, or helper state.\n\n3. **Deterministic, logically sound, and fully covered control flow**  \n   - All loops and recursion have clear, reachable, and terminating conditions that prevent infinite loops or premature exits that break correctness.  \n   - All conditional branches collectively cover every logical scenario; no missing cases, no contradictions, no unreachable or dead code that interferes with correctness.  \n   - Control structures (if/switch/while/for/recursion) must explicitly or implicitly handle all relevant input and intermediate states.\n\n4. **Complete, unambiguous, and correct algorithmic logic**  \n   - Each computational step, state update, and mutation is explicitly detailed, with no logical contradictions or gaps.  \n   - The intended algorithm is thoroughly captured \u2014 no essential steps omitted or vaguely implied.  \n   - Arithmetic operations, indexing, data transformations, and logical decisions must be clearly stated and consistent.\n\n5. **Robust handling of boundaries, special cases, and failure modes**  \n   - Explicit attention to boundary conditions such as minimal/maximal input sizes, zero-length structures, zero-division, overflow/underflow, empty outputs, or domain-specific corner cases.  \n   - Proper checks or safeguards to avoid undefined behavior, out-of-bounds accesses, or runtime errors.  \n   - Clear handling of error states, invalid inputs, or exceptional conditions if the problem domain requires it.\n\n6. **Fully specified, deterministic output construction**  \n   - Outputs and return values (including intermediate and final) are precisely defined and deterministically derived from prior steps.  \n   - No ambiguity about what is returned, how outputs are formed, or their format.  \n   - Consistent with the problem statement's expected output type and format.\n\n7. **Absolute self-containment with no reliance on unstated external context**  \n   - The snippet must be interpretable and implementable *as-is*, with no hidden assumptions about external functions, language-specific behavior, environment, libraries, or data.  \n   - No gaps requiring the reader or implementer to fill in missing details or to infer unstated mechanisms.\n\n8. **Style, formatting, or pseudocode idioms must not threaten clarity or reproducibility**  \n   - Variations in pseudocode expression\u2014such as loops vs recursion, array indexing style, or naming conventions\u2014are acceptable *only if* they maintain full clarity and completeness logically.  \n   - Ambiguous, overly terse, or inconsistent style causing misunderstanding or interpretative differences disqualify reproducibility.\n\nDecision rule:  \n- Output `1` if and only if **all** the above 8 criteria are fulfilled completely and without any ambiguity or omission.  \n- Output `0` otherwise, including near-perfect but imperfect snippets that risk failing some test case.\n\nOutput format:  \n- For multiple snippets, output a single string of digits (`1` or `0`), directly concatenated in the same sequence as input.  \n- Output nothing else \u2014 no explanations, comments, whitespace, or other characters.\n\nAdditional rigor notes:  \n- Do **not** guess or fill missing information even if it seems reasonable.  \n- Do **not** shortcut detailed logical evaluation of control flow, state initialization, or boundary checks.  \n- Consider *all* conceivable unit tests for correctness: edge cases, extremes, unusual inputs, error conditions, and invalid inputs consistent with problem scope.  \n- Guard against common pitfalls such as infinite recursion/loops, uninitialized variables, incomplete boundary checks, ambiguous return definitions, implicit assumptions, and unstated dependencies.\n\n---\n\nPseudocode: ```<INSERT_PSEUDOCODE_HERE>```\n```\n",
  "score": 0.6,
  "feedback": "We have a 4 way split for the pseudocodes: true positives, which are pseudocodes that correspond to code that passes all test cases.\nWe also have true negatives, which are pseudocodes that correspond to code that do not pass all test cases.\nWe have cosmetic, which are pseudocodes that are variations of the positive pseudocodes and also pass all test cases.\nWe have near-misses, which are pseudocodes that correspond to code that almost passes all test cases but do not. They pass at least 80% of test cases\nHere is the score for this prompt on positive-labeled pseudocodes: 0.62\nHere is the score for this prompt on negative-labeled pseudocodes: 0.6066666666666667\nHere is the score for this prompt on cosmetic-labeled pseudocodes: 0.6666666666666666\nHere is the score for this prompt on near_miss-labeled pseudocodes: 0.5066666666666667\n\nThe following are pseudocodes that are reproducible but were labeled as not:\nCLASS Solution  \n    FUNCTION multiply(num1 string num2 string) RETURNS string  \n        IF num1 EQUALS string zero OR num2 EQUALS string zero  \n            RETURN string zero  \n        END IF  \n\n        SET result TO a list of zeros with the LENGTH OF num1 PLUS the LENGTH OF num2  \n\n        SET num1 TO the reversal of num1  \n        SET num2 TO the reversal of num2  \n\n        FOR i FROM zero TO the LENGTH OF num1 MINUS one  \n            FOR j FROM zero TO the LENGTH OF num2 MINUS one  \n                SET mul TO the character code of the element at position i of num1 MINUS the character code of string zero MULTIPLIED BY the character code of the element at position j of num2 MINUS the character code of string zero  \n                SET p1 TO i PLUS j  \n                SET p2 TO i PLUS j PLUS one  \n                SET sum TO mul PLUS the element at position p1 of result  \n\n                SET the element at position p1 of result TO sum MODULO ten  \n                INCREMENT the element at position p2 of result BY the integer division of sum BY ten  \n            END FOR  \n        END FOR  \n\n        SET result_str TO the concatenation of the string representations of the elements of result in reverse order  \n        RETURN result_str with all leading string zeros removed  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION isMatch(s, p)  \n        SET dp TO a two dimensional list of False with the number of rows equal to the length of s PLUS one and the number of columns equal to the length of p PLUS one  \n        SET element at position zero zero of dp TO True  \n        FOR j FROM one TO the length of p  \n            IF element at position j MINUS one of p EQUALS the character representing asterisk  \n                SET element at position zero j of dp TO the value of element at position zero j MINUS one of dp  \n            END IF  \n        END FOR  \n        FOR i FROM one TO the length of s  \n            FOR j FROM one TO the length of p  \n                IF element at position j MINUS one of p EQUALS the character representing asterisk  \n                    SET element at position i j of dp TO the value of element at position i MINUS one j of dp OR the value of element at position i j MINUS one of dp  \n                ELSE IF element at position j MINUS one of p EQUALS the character representing question mark OR element at position i MINUS one of s EQUALS element at position j MINUS one of p  \n                    SET element at position i j of dp TO the value of element at position i MINUS one j MINUS one of dp  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN element at position the length of s the length of p of dp  \n    END FUNCTION  \nEND CLASS\n\nThe following are cosmetic or modified pseudocodes of other reproducible versions of pseudocode that are reproducible but were labeled as not:\noriginal version of the pseudocode for this problem that is reproducible:\nCLASS Solution  \n    FUNCTION longestPalindrome(s)  \n        SET n TO the LENGTH OF s  \n        SET f TO a TWO DIMENSIONAL LIST of BOOLEAN TRUES with n ROWS and n COLUMNS  \n        SET k TO zero  \n        SET mx TO one  \n        FOR i FROM n MINUS two DOWN TO zero  \n            FOR j FROM i PLUS one TO n MINUS one  \n                SET element at position i and position j of f TO FALSE  \n                IF element at position i of s EQUALS element at position j of s  \n                    SET element at position i and position j of f TO element at position i PLUS one and position j MINUS one of f  \n                    IF element at position i and position j of f EQUALS TRUE AND mx LESS THAN j MINUS i PLUS one  \n                        SET k TO i  \n                        SET mx TO j MINUS i PLUS one  \n                    END IF  \n                END IF  \n            END FOR  \n        END FOR  \n        RETURN substring from position k TO position k PLUS mx MINUS one of s  \n    END FUNCTION  \nEND CLASS\nmodified version of the pseudocode for this problem that is also reproducible:\nCLASS Solution\n    FUNCTION longestPalindrome(s)\n        SET length AS THE COUNT OF s\n        SET truth_matrix AS AN ARRAY (length) OF ARRAYS (length) FILLED WITH TRUE\n        SET start_index AS 0\n        SET max_length AS 1\n        \n        SET outer_index AS length MINUS 2\n        WHILE outer_index IS GREATER THAN OR EQUAL TO 0 DO\n            SET inner_index AS outer_index PLUS 1\n            WHILE inner_index IS LESS THAN length DO\n                SET truth_matrix[outer_index][inner_index] AS FALSE\n                \n                IF NOT (s[outer_index] NOT EQUAL TO s[inner_index]) THEN\n                    SET truth_matrix[outer_index][inner_index] AS truth_matrix[outer_index PLUS 1][inner_index MINUS 1]\n                    \n                    IF truth_matrix[outer_index][inner_index] IS TRUE THEN\n                        IF (max_length LESS THAN (inner_index MINUS outer_index PLUS 1)) THEN\n                            SET start_index AS outer_index\n                            SET max_length AS (inner_index MINUS outer_index PLUS 1)\n                        END IF\n                    END IF\n                END IF\n                INCREMENT inner_index BY 1\n            END WHILE\n            DECREMENT outer_index BY 1\n        END WHILE\n        \n        RETURN s SUBSTRING FROM start_index TO (start_index PLUS max_length MINUS 1)\n    END FUNCTION\nEND CLASS\noriginal version of the pseudocode for this problem that is reproducible:\nCLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET INT_MAX TO two RAISED TO THE POWER OF thirty ONE MINUS one  \n        SET INT_MIN TO the NEGATIVE of two RAISED TO THE POWER OF thirty ONE  \n        SET result TO zero  \n        SET index TO zero  \n        SET n TO the LENGTH OF s  \n        SET sign TO one  \n        WHILE index LESS THAN n AND element at position index of s EQUALS the space character  \n            INCREMENT index BY one  \n        END WHILE  \n        IF index LESS THAN n AND (element at position index of s EQUALS the plus character OR element at position index of s EQUALS the minus character)  \n            IF element at position index of s EQUALS the minus character  \n                SET sign TO the NEGATIVE of one  \n            ELSE  \n                SET sign TO one  \n            END IF  \n            INCREMENT index BY one  \n        END IF  \n        WHILE index LESS THAN n AND element at position index of s IS A DIGIT  \n            SET digit TO the INTEGER VALUE OF element at position index of s  \n            IF result GREATER THAN INT_MAX MINUS digit DIVIDED BY ten  \n                IF sign EQUALS one  \n                    RETURN INT_MAX  \n                ELSE  \n                    RETURN INT_MIN  \n                END IF  \n            END IF  \n            SET result TO result MULTIPLIED BY ten PLUS digit  \n            INCREMENT index BY one  \n        END WHILE  \n        RETURN sign MULTIPLIED BY result  \n    END FUNCTION  \nEND CLASS\nmodified version of the pseudocode for this problem that is also reproducible:\nCLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET maxIntValue AS (2 ^ 31) - 1  \n        SET minIntValue AS 0 - (2 ^ 31)  \n        SET accumulatedNumber TO 0  \n        SET position TO 0  \n        SET lengthOfString TO LENGTH OF s  \n        SET polarity TO 1  \n\n        WHILE position < lengthOfString AND s[position] = ' '  \n            position \u2190 position + 1  \n        END WHILE  \n\n        IF position < lengthOfString THEN  \n            SWITCH s[position]  \n                CASE '-'  \n                    polarity \u2190 0 - 1  \n                    position \u2190 position + 1  \n                    BREAK  \n                CASE '+'  \n                    polarity \u2190 1  \n                    position \u2190 position + 1  \n                    BREAK  \n            END SWITCH  \n        END IF  \n\n        REPEAT UNTIL NOT (position < lengthOfString AND s[position] >= '0' AND s[position] <= '9')  \n            SET currentChar TO s[position]  \n            SET numericValue TO INTEGER VALUE OF currentChar  \n            SET boundaryCheck TO maxIntValue - (numericValue DIV 10)  \n\n            IF accumulatedNumber > boundaryCheck THEN  \n                IF polarity = 1 THEN  \n                    RETURN maxIntValue  \n                ELSE  \n                    RETURN minIntValue  \n                END IF  \n            END IF  \n\n            accumulatedNumber \u2190 (accumulatedNumber * 10) + numericValue  \n            position \u2190 position + 1  \n        END REPEAT  \n\n        RETURN polarity * accumulatedNumber  \n    END FUNCTION  \nEND CLASS\n\nThe following are pseudocodes that are not reproducible but were labeled as reproducible:\n```\nSET INT_MAX = 2^31 - 1, INT_MIN = -2^31\nINIT res = 0, i = 0, n = len(s), sign = 1\nWHILE i < n AND s[i] = ' ' : i += 1\nIF i < n AND s[i] IN ['+', '-'] : sign = -1 IF s[i] = '-' ELSE 1; i += 1\nWHILE i < n AND s[i].isdigit():\n    d = int(s[i])\n    IF res > (INT_MAX - d)//10: RETURN INT_MAX IF sign = 1 ELSE INT_MIN\n    res = res*10 + d\n    i += 1\nRETURN sign * res\n```\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET INT_MAX TO two RAISED TO THE POWER OF thirty ONE MINUS one  \n        SET INT_MIN TO the NEGATIVE of two RAISED TO THE POWER OF thirty ONE  \n        SET result TO zero  \n        SET index TO zero  \n        SET n TO the LENGTH OF s  \n        SET sign TO one  \n        WHILE index LESS THAN n AND element at position index of s EQUALS the space character  \n            INCREMENT index BY one  \n        END WHILE  \n        IF index LESS THAN n AND (element at position index of s EQUALS the plus character OR element at position index of s EQUALS the minus character)  \n            IF element at position index of s EQUALS the minus character  \n                SET sign TO the NEGATIVE of one  \n            ELSE  \n                SET sign TO one  \n            END IF  \n            INCREMENT index BY one  \n        END IF  \n        WHILE index LESS THAN n AND element at position index of s IS A DIGIT  \n            SET digit TO the INTEGER VALUE OF element at position index of s  \n            IF result GREATER THAN INT_MAX MINUS digit DIVIDED BY ten  \n                IF sign EQUALS one  \n                    RETURN INT_MAX  \n                ELSE  \n                    RETURN INT_MIN  \n                END IF  \n            END IF  \n            SET result TO result MULTIPLIED BY ten PLUS digit  \n            INCREMENT index BY one  \n        END WHILE  \n        RETURN sign MULTIPLIED BY result  \n    END FUNCTION  \nEND CLASS\nCLASS Solution\n    FUNCTION canJump(list_of_numbers)\n        SET farthest_reachable_index TO zero\n        FOR index FROM zero TO the LENGTH OF list_of_numbers MINUS one INCLUSIVE\n            IF index GREATER THAN farthest_reachable_index\n                RETURN False\n            END IF\n            SET possible_reach TO index PLUS element at position index OF list_of_numbers\n            SET farthest_reachable_index TO the GREATER OF farthest_reachable_index AND possible_reach\n        END FOR\n        RETURN farthest_reachable_index GREATER THAN OR EQUAL TO the LENGTH OF list_of_numbers MINUS one\n    END FUNCTION\nEND CLASS\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION canJump(nums)  \n        SET farthest TO zero  \n        FOR i FROM zero TO the LENGTH OF nums MINUS one  \n            IF i GREATER THAN farthest  \n                RETURN false  \n            END IF  \n            SET possible_reach TO i PLUS element at position i of nums  \n            IF possible_reach GREATER THAN farthest  \n                SET farthest TO possible_reach  \n            END IF  \n        END FOR  \n        IF farthest GREATER THAN OR EQUAL TO the LENGTH OF nums MINUS one  \n            RETURN true  \n        ELSE  \n            RETURN false  \n        END IF  \n    END FUNCTION  \nEND CLASS\n\nThe following are near-miss pseudocodes - they are almost reproducible but were labeled as reproducible:\nCLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET INT_MAX TO two POWERED BY thirty ONE MINUS one  \n        SET INT_MIN TO negative two POWERED BY thirty ONE  \n        SET result TO zero  \n        SET index TO zero  \n        SET n TO the LENGTH OF s  \n        SET sign TO one  \n        WHILE index LESS THAN n AND character at position index OF s EQUALS a single whitespace character  \n            INCREMENT index BY one  \n        END WHILE  \n        IF index LESS THAN n AND (character at position index OF s EQUALS the plus sign OR character at position index OF s EQUALS the minus sign)  \n            IF character at position index OF s EQUALS the minus sign  \n                SET sign TO negative one  \n            ELSE  \n                SET sign TO one  \n            END IF  \n            INCREMENT index BY one  \n        END IF  \n        WHILE index LESS THAN n AND character at position index OF s IS A DIGIT  \n            SET digit TO the INTEGER VALUE OF character at position index OF s  \n            IF result GREATER THAN (INT_MAX MINUS digit) DIVIDED BY ten  \n                IF sign EQUALS one  \n                    RETURN INT_MAX  \n                ELSE  \n                    RETURN INT_MIN  \n                END IF  \n            END IF  \n            SET result TO result MULTIPLIED BY ten PLUS digit  \n            INCREMENT index BY one  \n        END WHILE  \n        RETURN sign MULTIPLIED BY result  \n    END FUNCTION  \nEND CLASS\nPassing rate for this pseudocode: 0.96875, but was given a label of 1\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION myAtoi(s)  \n        SET INT_MAX TO two RAISED TO THE POWER OF thirty ONE MINUS one  \n        SET INT_MIN TO the NEGATIVE of two RAISED TO THE POWER OF thirty ONE  \n        SET result TO zero  \n        SET index TO zero  \n        SET n TO the LENGTH OF s  \n        SET sign TO one  \n        WHILE index LESS THAN n AND element at position index of s EQUALS the space character  \n            INCREMENT index BY one  \n        END WHILE  \n        IF index LESS THAN n AND (element at position index of s EQUALS the plus character OR element at position index of s EQUALS the minus character)  \n            IF element at position index of s EQUALS the minus character  \n                SET sign TO the NEGATIVE of one  \n            ELSE  \n                SET sign TO one  \n            END IF  \n            INCREMENT index BY one  \n        END IF  \n        WHILE index LESS THAN n AND element at position index of s IS A DIGIT  \n            SET digit TO the INTEGER VALUE OF element at position index of s  \n            IF result GREATER THAN INT_MAX MINUS digit DIVIDED BY ten  \n                IF sign EQUALS one  \n                    RETURN INT_MAX  \n                ELSE  \n                    RETURN INT_MIN  \n                END IF  \n            END IF  \n            SET result TO result MULTIPLIED BY ten PLUS digit  \n            INCREMENT index BY one  \n        END WHILE  \n        RETURN sign MULTIPLIED BY result  \n    END FUNCTION  \nEND CLASS\nCLASS Solution\n    FUNCTION multiply(num1 string, num2 string) RETURNS string\n        IF num1 IS \"0\" OR num2 IS \"0\"\n            RETURN \"0\"\n        END IF\n\n        DECLARE digits AS MAP from INT to INT\n        DECLARE lengthSum AS INT = LENGTH(num1) + LENGTH(num2)\n        FOR index IN RANGE(lengthSum)\n            digits[index] = 0\n        END FOR\n\n        DECLARE reversed1 AS string = \"\"\n        DECLARE reversed2 AS string = \"\"\n        FOR p FROM LENGTH(num1) - 1 DOWNTO 0\n            reversed1 = reversed1 + num1[p]\n        END FOR\n        FOR q FROM LENGTH(num2) - 1 DOWNTO 0\n            reversed2 = reversed2 + num2[q]\n        END FOR\n\n        DECLARE function recursiveMul(i INT, j INT) RETURNS VOID\n            IF i = LENGTH(reversed1)\n                RETURN\n            END IF\n            IF j = LENGTH(reversed2)\n                recursiveMul(i + 1, 0)\n                RETURN\n            END IF\n\n            DECLARE valA AS INT = ASCII_CODE(reversed1[i]) - ASCII_CODE(\"0\")\n            DECLARE valB AS INT = ASCII_CODE(reversed2[j]) - ASCII_CODE(\"0\")\n            DECLARE product AS INT = valA * valB\n            DECLARE baseIndex AS INT = i + j\n            DECLARE nextIndex AS INT = baseIndex + 1\n            DECLARE totalSum AS INT = product + digits[baseIndex]\n\n            digits[baseIndex] = totalSum MOD 10\n            digits[nextIndex] = digits[nextIndex] + (totalSum DIV 10)\n\n            recursiveMul(i, j + 1)\n        END FUNCTION\n\n        CALL recursiveMul(0, 0)\n\n        DECLARE output AS string = \"\"\n        FOR key FROM lengthSum - 1 DOWNTO 0\n            output = output + TO_STRING(digits[key])\n        END FOR\n\n        WHILE LENGTH(output) > 1 AND output[0] = \"0\"\n            output = SUBSTRING(output, 1)\n        END WHILE\n\n        RETURN output\n    END FUNCTION\nEND CLASS\nPassing rate for this pseudocode: 0.9666666666666667, but was given a label of 1\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION multiply(num1 string num2 string) RETURNS string  \n        IF num1 EQUALS string zero OR num2 EQUALS string zero  \n            RETURN string zero  \n        END IF  \n\n        SET result TO a list of zeros with the LENGTH OF num1 PLUS the LENGTH OF num2  \n\n        SET num1 TO the reversal of num1  \n        SET num2 TO the reversal of num2  \n\n        FOR i FROM zero TO the LENGTH OF num1 MINUS one  \n            FOR j FROM zero TO the LENGTH OF num2 MINUS one  \n                SET mul TO the character code of the element at position i of num1 MINUS the character code of string zero MULTIPLIED BY the character code of the element at position j of num2 MINUS the character code of string zero  \n                SET p1 TO i PLUS j  \n                SET p2 TO i PLUS j PLUS one  \n                SET sum TO mul PLUS the element at position p1 of result  \n\n                SET the element at position p1 of result TO sum MODULO ten  \n                INCREMENT the element at position p2 of result BY the integer division of sum BY ten  \n            END FOR  \n        END FOR  \n\n        SET result_str TO the concatenation of the string representations of the elements of result in reverse order  \n        RETURN result_str with all leading string zeros removed  \n    END FUNCTION  \nEND CLASS\nCLASS Solution  \n    FUNCTION grayCode(n)  \n        IF n IS 0 THEN  \n            RETURN [0]  \n        END IF  \n        \n        ASSIGN resultList TO grayCode(n - 1)  \n        LET bitFlag BE 2 ^ (n - 1) * 1  \n        \n        DEFINE FUNCTION reverseList(inputList)  \n            IF inputList IS EMPTY THEN  \n                RETURN []  \n            ELSE  \n                RETURN reverseList(inputList[1:]) + [inputList[0]]  \n            END IF  \n        END FUNCTION  \n        \n        LET reversedResult BE reverseList(resultList)  \n        LET extendedList BE []  \n        \n        FOR each element IN reversedResult DO  \n            extendedList = extendedList + [(element BITWISE_OR bitFlag)]  \n        END FOR  \n        \n        RETURN resultList + extendedList  \n    END FUNCTION  \nEND CLASS\nPassing rate for this pseudocode: 0.8333333333333334, but was given a label of 1\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION grayCode(n)  \n        IF n EQUALS zero  \n            RETURN a list containing zero  \n        END IF  \n        SET prev_gray TO the result of calling grayCode with the value of n MINUS one  \n        SET mask TO one MULTIPLIED BY two RAISED TO the power of n MINUS one  \n        SET current_gray TO concatenation of prev_gray WITH a list constructed by taking each number IN the reversed prev_gray AND applying bitwise OR with mask  \n        RETURN current_gray  \n    END FUNCTION  \nEND CLASS\nCLASS Solution\n    FUNCTION minCut(s)\n        LET length_s BE LENGTH OF s\n        IF length_s <= 1 THEN\n            RETURN 0\n        END IF\n\n        LET palindrome_matrix BE LIST OF LISTS OF FALSE WITH size length_s by length_s\n        FUNCTION mark_palindrome(sub_len, start_idx)\n            IF sub_len > length_s THEN\n                RETURN\n            END IF\n\n            IF sub_len == 1 THEN\n                SET palindrome_matrix[start_idx][start_idx] TO TRUE\n                CALL mark_palindrome(sub_len + 1, 0)\n                RETURN\n            END IF\n\n            IF start_idx > length_s - sub_len THEN\n                CALL mark_palindrome(sub_len + 1, 0)\n                RETURN\n            END IF\n\n            LET finish_idx BE start_idx + sub_len - 1\n            IF sub_len == 2 THEN\n                SET palindrome_matrix[start_idx][finish_idx] TO (s[start_idx] == s[finish_idx])\n            ELSE\n                SET palindrome_matrix[start_idx][finish_idx] TO (s[start_idx] == s[finish_idx]) AND palindrome_matrix[start_idx + 1][finish_idx - 1]\n            END IF\n\n            CALL mark_palindrome(sub_len, start_idx + 1)\n        END FUNCTION\n\n        CALL mark_palindrome(1, 0)\n\n        LET minimal_cuts BE LIST OF 0 OF LENGTH length_s\n\n        FUNCTION determine_cuts(pos)\n            IF pos == length_s THEN\n                RETURN\n            END IF\n\n            IF palindrome_matrix[0][pos] THEN\n                SET minimal_cuts[pos] TO 0\n            ELSE\n                SET minimal_cuts[pos] TO INFINITY\n                FUNCTION min_cut_inner(k)\n                    IF k > pos THEN\n                        RETURN\n                    END IF\n\n                    IF palindrome_matrix[k][pos] AND minimal_cuts[k - 1] + 1 < minimal_cuts[pos] THEN\n                        SET minimal_cuts[pos] TO minimal_cuts[k - 1] + 1\n                    END IF\n                    CALL min_cut_inner(k + 1)\n                END FUNCTION\n                CALL min_cut_inner(1)\n            END IF\n            CALL determine_cuts(pos + 1)\n        END FUNCTION\n\n        CALL determine_cuts(0)\n\n        RETURN minimal_cuts[length_s - 1]\n    END FUNCTION\nEND CLASS\nPassing rate for this pseudocode: 0.9787234042553191, but was given a label of 1\nHere is a version of the pseudocode that IS reproducible:\nCLASS Solution  \n    FUNCTION minCut(s)  \n        SET n TO the LENGTH OF s  \n        IF n LESS THAN OR EQUAL TO one  \n            RETURN zero  \n        END IF  \n        \n        SET is_palindrome TO a two dimensional collection of size n by n filled with FALSE  \n        \n        FOR i FROM zero TO n MINUS one  \n            SET element at position i at position i of is_palindrome TO TRUE  \n        END FOR  \n        \n        FOR length FROM two TO n  \n            FOR start FROM zero TO n MINUS length  \n                SET end TO start PLUS length MINUS one  \n                IF length EQUALS two  \n                    SET element at position start at position end of is_palindrome TO the condition that element at position start of s EQUALS element at position end of s  \n                ELSE  \n                    SET element at position start at position end of is_palindrome TO the condition that element at position start of s EQUALS element at position end of s AND the element at position start PLUS one at position end MINUS one of is_palindrome  \n                END IF  \n            END FOR  \n        END FOR  \n        \n        SET min_cuts TO a collection of size n filled with zero  \n        \n        FOR i FROM zero TO n MINUS one  \n            IF element at position zero at position i of is_palindrome  \n                SET element at position i of min_cuts TO zero  \n            ELSE  \n                SET element at position i of min_cuts TO positive infinity  \n                FOR j FROM one TO i  \n                    IF element at position j at position i of is_palindrome AND element at position j MINUS one of min_cuts PLUS one LESS THAN element at position i of min_cuts  \n                        SET element at position i of min_cuts TO element at position j MINUS one of min_cuts PLUS one  \n                    END IF  \n                END FOR  \n            END IF  \n        END FOR  \n        \n        RETURN element at position n MINUS one of min_cuts  \n    END FUNCTION  \nEND CLASS\n\nAvg Score for all pseudocodes: 0.6"
}